===============================
Chapel Futures Status: README
===============================

A future represents a handle to some asynchronous computation that can return a value (think begin expressions).
Chapel futures are implemented as a library (see modules/standard/Futures.chpl) that uses
- sync variables
- atomic ints
- lambdas.
Lambdas allow users to write multiple statements inside the computation body.

Users can instantiate a future (using a factory method) and use future objects, e.g.
  var f = buildFuture(int, lambda() { return someComputation(); });
The value in the future is retrieved by calling the read method:  
  var r = f.read();
This is a blocking call and waits until the future task is executed and a value is available in the future handle.

The status of a future can also be queries using the isResolved() method.
This method returns true if the future task has been executed and a value is available in the handle.


Automatic coercions
-------------------

Automatic coercions can be supported by using Chapel's support for operator overloading.
See example: test/futures/futures_with_coercions.chpl


(Future :) Compiler Issues
------------------------

1. Futures syntax / Begin expressions
It is possible to have syntax sugar for futures, e.g. instead of writing
  var f = buildFuture(int, lambda() { return someComputationReturningAnInt(); });
the user writes:
  var f = begin { return someComputationReturningAnInt(); };
The compiler then automatically does type inference to know that f is of type future(int).
The compiler also adds the syntax sugar for the call to the factory method buildFuture() after creating the lambda.

2. Issues in compiling lambdas used inside begin blocks:

test/futures/fib_with_futures.chpl fails to compile with the following error:
  In file included from /tmp/chpl-shamsimam-18982.deleteme/_main.c:31:
  /tmp/chpl-...deleteme/Futures.c:208:34: error: use of undeclared identifier 'n2'
  _return_tmp_ = this9(_cast_tmp_, n2, _endCount);

3. Current support for coercions using generics and operator overloading is limiting.
It doesnâ€™t allow type coercion for user-defined methods.
When Chapel compiler add support for Scala-like implicit conversions the following can be supported.
Example: addInts(2, aFuture)needs to be replaced intoaddInts(2, aFuture.read())
Alternatively the compiler can generate a future version of the method that transitively passes the future along down the call chain until its value is actually used.
Example:
  Original code:
   var f = buildFuture(int, lambda() { return 5; };
   addInts(2, f);
   
   proc addInts(a: int, b: int): int {
     return a + power(b, 3);
   }
   proc power(a: int, b: int): int {
     return a * a * a;
   }

gets compiled as:
   var f = buildFuture(int, lambda() { return 5; };
   addInts_if(2, f);
   
   proc addInts(a: int, b: int): int {
     return a + power(b, 3);
   }
   proc addInts_if(a: int, b: future(int)): int {
     return a + power_fi(b, 3);
   }
   proc power(a: int, b: int): int {
     return a * a * a;
   }
   proc power_fi(a: future(int), b: int): int {
     return a.read() * a.read() * a.read();
   }
