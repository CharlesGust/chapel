#
# All comments will be stripped out before releasing the final STATUS
#
============================
Chapel Implementation Status
============================

This file contains a list of unimplemented features and known bugs in the
Chapel implementation.  If you find additional bugs and unimplemented features,
or if you would like to request prioritization of items in this file, please
let us know at chapel-bugs@lists.sourceforge.net or chapel_info@cray.com.
Please feel encouraged to err on the side of mailing us with any issues you run
into.

General (see also portability section at the bottom of this file)
-----------------------------------------------------------------
- Some error messages are confusing or unhelpful.
  Workaround: Please ask us for help with interpreting the message.
- Compiler and runtime errors don't always report useful line numbers.
  Workaround: Please ask us for help finding the line in question.
- Names in a Chapel program can collide with names used internally.
  Workaround: Avoid using chpl_ or chpl__ as prefixes to symbol names
- There are several internal memory leaks including the following:
  1. All strings are leaked.
  2. Privatized domains and arrays (Block, Cyclic) are leaked.
  3. Data associated with iterators may be leaked.
  4. Data accessed in 'on' and/or 'begin' statements may be leaked.
  Workaround: Use memory tracking facilities (see README.executing).
  Workaround: Please ask us for help with your particular problem.


Types, Variables, Conversions, Expressions, and Statements
----------------------------------------------------------
- Unlabeled break and continue statements fail to compile in param for loops.
  # statements/sungeun/break_nolabel_param.future
  # statements/sungeun/continue_nolabel_param.future
- Multiple configuration parameters with different types declared in a
  single statement result in an internal error.
  # functions/bradc/paramFnNonParamArgs/multConfigTypes.future

Modules and Functions
---------------------
- Programs requiring non-linear function resolution may fail to compile.
  E.g., mutual module uses that access variables across both modules
- Variable functions that return local data may not result in an error.
  # functions/deitz/test_var_function_returns_local_via_var_function.future
- Type functions with unambigious return paths may result in "illegal
  cast" errors.
  # test/users/weili/typefnbug.future
  # This should be updated when someone knows a little more
  #  about what exactly is going on
- Param functions can return runtime variables.
  # users/weili/metaprog2.future
- Where clauses on non-generic functions ignored.
  # functions/diten/whereClauseIgnored.future
# OMITTED: b/c it's just a bit too odd
  # users/csep524/recRetArr.future
- Var functions returning multiple class types should be illegal, but
  instead they are compiled and result in runtime error.
  # functions/diten/varFnRetClasses.future
  # functions/diten/varFnRetClasses2.future
- Constructor calls with the same name in different modules are not
  properly resolved.
  # trivial/jturner/module_class_name_clash.future
- Param functions with explicitly specified return types may not
  create a param return value
  # users/bartosz/paramfn2.future


Tuples, Classes, Records, and Unions
------------------------------------
- Multiple inheritance is not implemented.
- Type select on unions is not implemented.
- User-defined constructors are not robust.
  # classes/claridge/baseConstructorCall.future, et al.
#
# Are these still accurate?
#
- Constant checking for fields of constant records is incomplete.
- Constant checking for constant fields of records or classes is incomplete.
- Constant checking for components of constant tuples is incomplete.
- Function argument with type tuple of generic class results in a
  compiler assertion.
  # functions/diten/fnGenericTupleArg.future
  # functions/vass/arg-is-tuple-with-generic-class.future
  # functions/vass/arg-is-tuple-with-no-type.future (maybe?)
- Non-sync arguments to default constructors that expect sync vars are
  not properly coerced to sync type.
  # classes/hannah/coercingIntToSyncIntOnConstructor.future
- Specifying the type of a tuple of domains results in a runtime
  error.  It may be possible to work around this by implicitly
  specifying the type by using an assignment at the declaration.
  # types/tuple/claridge/tuple_of_domains.future
# OMITTED: classes/bradc/initialize-secondary.future



Ranges, Domains, and Arrays
---------------------------
- Arrays of arrays where the inner arrays vary in size are not supported.
  # arrays/deitz/test_skyline_array.future
- Sparse domain/array slicing is not supported.
- Constant checking for domains and arrays is incomplete.
- There are no bounds checks on index types.
- There are no subset checks on subdomains.
- Array promotion/forall/for/scan expressions always evaluate to 1D arrays.
  E.g., f(A) where A promotes f() should result in an array of type:
    [A.domain] f(A(i)).type but instead results in a 1D array
  E.g., [i in D] f(i) should result in an array of type: [D] f(i).type
    but instead results in a 1D array
- Recursive records with array members (empty domains) fail to compile.
- Arrays and domains of different ranks can be zippered serially.
- Array and domain runtime type information is not preserved through
  generic instantiation.
- Range operations can result in overflow.
    e.g., (0:uint..5 by -1).length
  # ranges/sungeun/length.future
- Arrays declared over domains with negative strides may result in errors.
  # users/weili/arrNegDom-blc.future
  # users/weili/arrNegDom2.future
  # users/weili/arrNegDom3.future
  # arrays/bradc/reindex/reindex.future
- Array type aliases may fail to compile for multiple locales.
  # ???
- Array type alias fields may fail to compile.
  # is this the same as next?
- Array aliases cannot be declared as fields without an element type.
  # test/studies/hpcc/HPL/stonea/serial/hplExample1.future
- The range constructor my incorrectly compute the upper bound of a
  strided range.
  # range/claridge/strided_range_constructor.future
  # types/range/claridge/expand_strided_range.future
- Query expressions on domains and subdomains not supported.
  # domains/vass/domain-arg-query-expr.future


Iterators and Generics
----------------------
- Nested 'var' iterators may not work correctly.
- Recursive iterators may not work correctly.
  # functions/iterators/vass/recursive-iterator-in-expr-context.future
- The implicit 'setter' argument does not work in var iterators.
  # functions/deitz/iterators/iterator_uses_setter.future
- Iterators in records cannot change fields in that record.
  # functions/deitz/iterators/test_record_iterator.future
  # studies/shootout/nbody/nbody_recorditerator.future
- Subclassing uninstantiated generic classes should be prohibited but is not.
- Errors from calls to 'compilerError' may be incorrect due to dynamic dispatch.
  # classes/bradc/compilerErrorInMethod/testClear.future??
- Records cannot be generic over real parameters.
  # classes/diten/paramRealInRecord.future
- Type and parameter functions are not checked for side effects.
# OMITTED: trivial/jturner/iter_overload_simple.future


Input and Output
----------------
- Binary I/O is not implemented.
- Format control for precision/width is lacking.
  Workaround: see doc/technotes/README.format
- Input of whole arrays is not implemented.
  Workaround: use a loop, e.g., for e in A do read(e);
- Using 'on' in a writeThis method can lead to a deadlock.


Task Parallelism and Synchronization
------------------------------------
- Atomic statements are not implemented.
- Deadlocks may occur due to an insufficient number of threads.
  # multilocale/diten/needMultiLocales/coforallon_maxThreads.future
  # parallel/cobegin/deitz/test_many_threads.future (other issues too)
- Arrays may not be moved to the heap due to indirect array element accesses.


Data Parallelism
----------------
- Reductions and scans of arrays of arrays may result in errors.
- Records in reduction classes may results in out-of-bound indexing
  problems.
  # studies/kmeans/kmeansonepassreduction-mystery.future
- Some data parallel statements that should be parallelized are
  serialized with a warning message "X has been serialized".  In some
  case, this can be fixed in the program.
  E.g., Change '+ reduce for i in 1..n do i**2' to
                 '+ reduce forall i in 1..n do i**2' to avoid a
  warning that the reduce has been serialized.  In other cases, this
  is a current limitation:
  1. Scans are always serialized.
  2. Assignments from ranges to multidimensional arrays are always serialized.
  3. Assignment, reductions, and parallel iteration over opaque domains and
     arrays are always serialized.


Locales and Domain Maps
-----------------------
- On statement variable declarations are not yet supported.
  E.g., on Locales(1) var x: real;
  # multilocale/sungeun/on_statement_var_decl.future
- String assignment across locales is by reference rather than value.
- The default value for locale types is incorrect.
  # multilocale/sungeun/locale_default.future
- Domain maps may be prematurely freed.
  Workaround: This may be in the declaration. Try eliding the type.
- The local statement is not well supported.
  # John Lewis examples and other .futures forthcoming

User-Defined Reductions and Scans and User-Defined Domain Maps
--------------------------------------------------------------
- User-defined reductions and scans are not yet implemented.
- User-defined domain maps are not yet implemented.


Standard Modules, Standard Distributions, and Standard Layouts
--------------------------------------------------------------
- On some platforms, the Math module is limited by C support.
- The BlockCyclic distribution is incomplete.
- Block and Cyclic domains containing indices near the minimum or
  maximum integral type may overflow.
- Array slicing on Block and Cyclic arrays is not supported in some
  cases.


Miscellaneous
-------------
- Creating many domain types or arrays or tuples types causes the
  compilation time to become unreasonable.
  # arrays/deitz/many/test_many_arrays_of_star_tuples.future
  # arrays/deitz/many/test_many_ranks_of_arithmetic_domains.future
- Default values for formal arguments do not accept conditional
  expressions.
  # functions/deitz/default/test_default_conditional_expr.future
- Bounds checking is not complete.
  # e.g., arrays/claridge/arraySizeMismatch.future
- Overloading operations such as multiplcation for domain literal not supported.
  # domains/claridge/multiplicationSyntaxCheck.future
- Name mangling for generics may result in errors during C compilation.
  # classes/vass/instantiated_name_for_real_param.future
# OMITTED: classes/claridge/recordInClass2.future


Portability
-----------
Cray XE:
- Native conduit not yet supported.  See doc/platform/README.xe-cle
  for detals.

Cray XT:
- The memory limit for Chapel programs may need to be set manually.
  See doc/platforms/README.xt-cle for details.

Cray CX1/CX1000:
- Support is only provided using Linux.

IBM Power5/Power6 systems:
- There has been some initial success, but testing is incomplete.
  See doc/platforms/README.ibm for details.

PGI compilers (and possibly others):
- Identifiers in the generated code may exceed the back-end compiler's limit.
- Floating point literals of -0.0 may not work as intended.

