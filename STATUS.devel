#
# This file lists all the existing futures that are categorizes as "bug" or
# "unimplemented feature."
#
# All comments will be stripped out before releasing the final STATUS
#
# To remove comments use: grep -v "^\ *#" STATUS.devel (or 'make STATUS')
#
# To further facilitate generating the final STATUS file, please put the
# names of the future files on a separate line from comments (one future
# per line).  For example:
#
#        # path/to/future/blah.future
#
# If for some reason a .future is omitted prepend the name of the future
# with the 'OMITTED:' and use comments to explain.  For example:
#
#        # OMITTED: path/to/future/blah.future
#        #   b/c it's too difficult to explain
#
# For release 1.3: current to r18669-ish.
#
============================
Chapel Implementation Status
============================

This file contains a list of unimplemented features and known bugs in
the Chapel implementation.  If you find additional bugs and
unimplemented features, or if you would like to request prioritization
of items in this file, please let us know at
chapel-bugs@lists.sourceforge.net or chapel_info@cray.com.  Please
feel encouraged to err on the side of mailing us with any issues you
run into.

# OMITTED: users/wmikanik/test1.future
#  b/c the bug seems to have gone away, but we don't know the story behind it
# OMITTED: arrays/sungeun/multilocale/aliasWithDomOnDifferentLocale.future
#  b/c too weird to describe
# OMITTED: optimizations/rafa/rankChange.future
#  b/c a workaround has been put in place
# OMITTED: users/ferguson/exit.future
#  b/c only fails for qthreads
# OMITTED: users/ferguson/forall_expr.future
#  b/c only fails for qthreads intermittently
# OMITTED: users/vass/crash1callDestructorsMain.future
#  b/c future not investigated and test program too long
# OMITTED: users/vass/crash2VarSymbolTypeNULL.future
#  b/c future not investigated and test program too long
# OMITTED: users/vass/crash3tuple.future
#  b/c future not investigated and test program too long
# OMITTED: users/vass/crash4replLclsWFlds.future
#  b/c future not investigated and test program too long
# OMITTED: users/vass/iterator-cpp-assertion-crash.future
#  b/c future not investigated and test program too long
# OMITTED: users/vass/crash5insertAfter.future
#  b/c future description does not make sense
# FIX ME: memory
  # studies/graph500/v1/main.future
  # studies/hpcc/HPL/vass/bug.future
  # trivial/sidelnik/reduction.future
# FIX ME:
  # users/holtbg/tupleOfTupleIteration.future

General (see also portability section at the bottom of this file)
-----------------------------------------------------------------
- Some error messages are confusing or unhelpful.
  Workaround: Please ask us for help with interpreting the message.
  # compflags/bradc/badConfigParamOverride.future
  # sparse/bradc/accumInds-forexpr.future
- Compiler and runtime and errors don't always report useful line
  numbers and may not be formatted correctly.
  Workaround: Please ask us for help finding the line in question.
  # trivial/vass/line-number-for-toplevel-compilerError.future
  # parsing/vass/newline-in-string-compiletime-1.future
- Back-end compilers may emit warning messages.
  # memory/sungeun/no_unreachable_autoDestroy.future
- Names in a Chapel program can collide with names used internally.
  # classes/vass/duplicate-virtual-method-ok-1.future
  # trivial/figueroa/UnmangledSymbols.future
- There are several internal memory leaks including the following:
  1. All strings are leaked.
  2. Privatized domains and arrays are leaked (i.e., those that use
     the standard distributions).
  3. Data associated with iterators may be leaked.
  4. Data accessed in 'on' and/or 'begin' statements may be leaked.
  Workaround: Use memory tracking facilities (see README.executing).
  Workaround: Please ask us for help with your particular problem.
  # memory/vass/memleak-array-of-records-1.future
  # types/records/sungeun/destructor1.future
- The --gdb flag is only supported for single-locale platforms that
  support gdb.
- Separate compilation of Chapel files is not supported:
  # separate_compilation/jturner/use_classextern.future
  # separate_compilation/jturner/use_classextern2.future
  # separate_compilation/jturner/use_fcfunc.future
  # separate_compilation/jturner/use_methodextern.future
  # separate_compilation/jturner/use_methodextern2.future
  # separate_compilation/jturner/use_overload.future
  # separate_compilation/jturner/use_record.future
  # separate_compilation/jturner/use_simplefloat.future
  # separate_compilation/jturner/use_subclass.future


Types, Variables, Conversions, Expressions, and Statements
----------------------------------------------------------
- Continue statements in forall and coforall statements not implemented.
  # statements/diten/continueInForall.future
  # statements/sungeun/continue_coforall_label.future
  # statements/sungeun/continue_forall_label.future
- Querying the type of a function is not supported and currently
  returns an internal type.
  # functions/sungeun/type_illegal.future
- Unlabeled break and continue statements fail to compile in param for loops.
  # statements/sungeun/break_nolabel_param.future
  # statements/sungeun/continue_nolabel_param.future
- Casts and relational operations involving enum constants may fail to
  compile or produce incorrect answers.
  # types/enum/sungeun/cast_enum_weird_2.future
  # types/enum/sungeun/cast_expr_init_1.future
  # types/enum/sungeun/cast_expr_init_2.future
  # types/enum/sungeun/cast_neg_start_1.future
  # types/enum/sungeun/cast_neg_start_2.future
  # types/enum/sungeun/cast_neg_start_3.future
  # types/enum/sungeun/cast_neg_start_oor_1.future
  # types/enum/sungeun/cast_neg_start_oor_2.future
  # types/enum/sungeun/test_foldEnumOp.future
  # functions/diten/param_enum_to_int.future
  # functions/diten/param_enum_to_string.future
- Casts to non-type variables does not result in an error at compile time.
  # expressions/vass/cast-to-non-type-1.future
  # expressions/vass/cast-to-non-type-2.future
- Multiple configuration parameters with different types declared in a
  single statement result in an internal error.
  # functions/bradc/paramFnNonParamArgs/multConfigTypes.future
- Variables that rely on each other for initialization
  and/or type inference may result in an internal compiler error.
  # functions/deitz/test_outoforder.future


Modules and Functions
---------------------
# FIX ME?
  # functions/vass/resolution/need-ambiguous-error-1.future
- Programs requiring non-linear resolution may fail to compile.
  E.g., mutual module uses that access variables across both modules
- Function resolution may be overly conservative for methods of subclasses.
  # classes/bradc/compilerErrorInMethod/testClear.future
- Function resolution may get confused about types declared within a
  conditional block that is controlled by a param.
  # trivial/sungeun/config_param.future
- Modules that rely on each other for initialization
  and/or type inference may result in an internal compiler error.
  # functions/bradc/resolveConfig.future
  # modules/deitz/test_module_mutual_use.future
  # modules/diten/mutualuse.future
  # modules/diten/mutualuse2.future
  # modules/diten/mutualuse3.future
- Invalid where clauses may result in compiler seg fault.
  # functions/vass/where-clause-bug-1.future
- Array-of-array formal argument declarations do not work
  # arrays/bradc/arrayOfArrayArg.future
- Record argument that is compatible with the formal does not work.
  # users/ferguson/recordEquivalence.future
- Specified argument types that are not types should return a Chapel
  compile time error, but instead they may result in an internal
  compiler error or compile and run.
  # functions/deitz/test_arg_type_is_value_error.future
  # functions/vass/return-type-function-failure.future
- Recursive functions that return arrays are not yet supported
  # functions/dinan/array_return_from_recursive.future
- Recursive functions with default argument values may not work.
  # users/csep524/recRetArr.future
- Param functions can return runtime variables.
  # users/weili/metaprog2.future
- Param functions with explicitly specified return types may not
  create a param return value.
  # users/bartosz/paramfn2.future
- Var functions returning multiple class types should be illegal, but
  instead they are compiled and result in runtime error.
  # functions/diten/varFnRetClasses.future
  # functions/diten/varFnRetClasses2.future
- Var functions that return local data may not result in an error.
  # functions/deitz/test_var_function_returns_local_via_var_function.future
- Type functions with unambiguous return paths may result in "illegal
  cast" errors.
  # users/weili/typefnbug.future
  # This should be updated when someone knows a little more
  #  about what exactly is going on
- Param functions with explicit return types do not work properly.
  # functions/vass/paramret-1.future
  # functions/vass/paramret-diten.future
- Constructor calls with the same name in different modules are not
  properly resolved.
  # trivial/jturner/module_class_name_clash.future
- Support for closures and first-class functions is not complete.
  # functions/jturner/first-class-generic-function.future
  # functions/vass/closure-outlives-captured-vars.future


Tuples, Classes, Records, and Unions
------------------------------------
# OMITTED: classes/diten/record_initialize.future
#  b/c it is an issue only with --baseline
# OMITTED: classes/diten/test_destructor3.future
#   b/c we haven't yet defined them
- Multiple inheritance as defined in the spec (multiple method-only classes)
  is not implemented.
  # classes/figueroa/DestructorSubclassing2.future
  # classes/figueroa/DestructorSubclassing3.future
- Declaring members and functions using inherited param or type
  variable may not work.
  # classes/sungeun/inheritance_noUse_param1.future
  # classes/sungeun/inheritance_noUse_param2.future
  # classes/sungeun/inheritance_noUse_param3.future
  # classes/sungeun/inheritance_noUse_param4.future
  # classes/sungeun/inheritance_noUse_typeVar1.future
  # classes/sungeun/inheritance_noUse_typeVar2.future
  # classes/sungeun/inheritance_noUse_typeVar3.future
  # classes/sungeun/inheritance_noUse_typeVar4.future
  # classes/sungeun/inheritance_param1.future
  # classes/sungeun/inheritance_param2.future
  # classes/sungeun/inheritance_param3.future
  # classes/sungeun/inheritance_typeVar1.future
  # classes/sungeun/inheritance_typeVar2.future
  # classes/sungeun/inheritance_typeVar3.future
- Type select on unions is not implemented.
- User-defined constructors are not robust.
  # classes/claridge/baseConstructorCall.future
  # users/murai/test_nested_class_constructor.future
  # classes/bradc/initialize-secondary.future
  # classes/vass/nested-class-with-user-defined-constructor-1.future
  # classes/hilde/alwaysOverrideCopyInit.future
- Constant checking for components of constant tuples is incomplete.
- Constant checking for fields of constant records is incomplete.
- Incorrect casting of a class variable to a type that is not its
  superclass does not report an error.
  # classes/vass/subclass-cast-error.future
- Declaring class member using type aliases is sensitive to textual ordering.
  # arrays/deitz/part5/test_array_type_field_type.future 
  # classes/diten/type_order_problem.future
- Array alias arguments to constructors fail to compile.
  # arrays/diten/constructorArrayAliasReindex.future
- Record and class members that are defined to be array alias fail to
  compile without an explicitly specified element type.
  # classes/stonea/arrayAliasRecordMember.future
  # studies/hpcc/HPL/stonea/serial/hplExample1.future
- Multiple ambiguous definitions of class methods that are overridden
  in a subclass result in an internal compiler error.
  # classes/vass/duplicate-virtual-method-error-2.future
- Overridden iterators may not work.
  # trivial/jturner/iter_overload_simple.future
- Classes nested in procedures may result in a compile time error.
  # classes/vass/jglewis-class-in-function.future
- Non-sync arguments to default constructors that expect sync vars are
  not properly coerced to sync type.
  # classes/hannah/coercingIntToSyncIntOnConstructor.future
- Function argument with type tuple of generic class results in a
  compiler assertion.
  # functions/diten/fnGenericTupleArg.future
  # functions/vass/arg-is-tuple-with-generic-class.future
- Specifying the type of a tuple of domains results in a runtime
  error.  It may be possible to work around this by implicitly
  specifying the type by using an assignment at the declaration.
  # types/tuple/claridge/tuple_of_domains.future
- Parentheses-less function without curly braces enclosing the body
  fail to parse correctly.
  # parsing/vass/parenthesis-less-function-string.future
- Parentheses-less methods of classes/records may result in failed
  compilation if they are not declared with in the class/record
  definition.
  # classes/vass/generic-parenthesesless-1.future
  # classes/vass/generic-parenthesesless-2.future
  # classes/vass/generic-parenthesesless-3.future
  # classes/vass/generic-parenthesesless-4.future
  # classes/vass/generic-parenthesesless-5.future
  # classes/vass/generic-parenthesesless-big1.future
- Generic domain types in field declarations result in a compile time error.
  # domains/vass/generic-domain-field.future
- Invalid use of tuple expansion as an expression results in the
  expression evaluating to the first element of the tuple.
  # functions/vass/return-of-tuple-expansion-1.future
  # types/tuple/vass/tuple-expansion-with-parens-1.future
- Tuple expanded list enclosed in parenthesis does not result in a
  tuple.
  # functions/vass/return-of-tuple-expansion-2.future


Ranges, Domains, and Arrays
---------------------------
- Arrays of arrays where the inner arrays vary in size are not supported.
  # arrays/deitz/test_skyline_array.future
  # studies/590o/wk3/02arrOfArr-irregular.future
- Modifications to Sparse domains are not thread-safe.
  # domains/sungeun/sparse/forall.future
  # domains/sungeun/sparse/stress.future
- Sparse domain/array slicing is not supported.
  # arrays/stonea/sliceSparseSubdomain.future
  # sparse/bradc/sliceWithDense.future
- Constant checking for domains and arrays is not implemented.
  # domains/bradc/assignConstDom2.future
  # domains/bradc/assignConstDom.future
# FIX ME?
  # types/range/hilde/countError.future
- Subset checks on subdomains is not implemented.
- Bounds checks on index types is not implemented.
- Query expressions on domains and subdomains not supported.
  # domains/vass/domain-arg-query-expr.future
  # functions/vass/arg-is-queried-domain.future
- Array promotion/forall/for/scan expressions always evaluate to 1D arrays.
  E.g., f(A) where A promotes f() should result in an array of type:
    [A.domain] f(A(i)).type but instead results in a 1D array
  E.g., [i in D] f(i) should result in an array of type: [D] f(i).type
    but instead results in a 1D array
  # arrays/bradc/inferArrayType.future
  # reductions/bradc/minmaxlocscan-shape.future
  # sparse/bradc/inferSparseArrayType.future
- Arrays and domains of different ranks can be zippered serially.
- Arrays declared over domains with negative strides may result in errors.
  # users/weili/arrNegDom-blc.future
  # users/weili/arrNegDom2.future
  # users/weili/arrNegDom3.future
  # arrays/bradc/reindex/reindex.future
- Arrays of subdomains may not work.
  # users/jglewis/bfs_102207/driver_breadth_first_search.future
- Array and domain runtime type information is not preserved through
  generic instantiation.
- Associative domain clear() does not reset values of arrays declared
  over the domain.
  # domains/sungeun/assoc/clear.future
- Associative domains of rectangular domains result in a compile time error.
  # domains/claridge/domainOfDomains.future
- Range operations can result in overflow.
    e.g., (0:uint..5 by -1).length
  # types/range/diten/testRangeSlice.future
  # types/range/diten/testRangeSlice2.future
  # types/range/diten/testRangeSlice3.future
  # types/range/sungeun/length_broken.future
- Ranges that span the entire representable range of the index type
  do not work.
  # types/range/hilde/noCountBigUint.future
- Ranges that are sliced with another range with a different index
  type do not work.
  # types/range/vass/slice-1.future
  # types/range/vass/slice-2.future
  # types/range/vass/slice-unrep-2.future
- Range alignment is not always displayed when printing a range using
  writeln().
  # types/range/vass/writeranges-1.future
- The indexOrder() method on ranges does not work if the unbounded on
  the 'low' end.
  # types/range/vass/indexorder-nofirst-1.future
  # types/range/vass/indexorder-nofirst-2.future
- Param ranges are not supported.
  # users/sidelnik/param_range.future
- Promoting a function over an array returned by a var function fails
  to compile.
  # functions/diten/test_promote_var_fn.future
- Recursive records with array members (empty domains) fail to compile.
  # arrays/dinan/array_of_records.future


Iterators and Generics
----------------------
# OMITTED: functions/deitz/iterators/test_var_iter_in_iter.future
#  b/c it is an issue only with --no-live-analysis
# OMITTED: functions/iterators/diten/arrEltIter.future
#  b/c it is an issue only with --no-live-analysis
- Recursive iterators may not work correctly.
  # functions/iterators/vass/recursive-iterator-in-expr-context.future
  # functions/iterators/claridge/recursiveIterTypeBug.future
- Iterators in records cannot change fields in that record.
  # functions/deitz/iterators/test_record_iterator.future
- Nested 'var' iterators may not work correctly.
- The implicit 'setter' argument does not work in var iterators.
  # functions/deitz/iterators/iterator_uses_setter.future
  # functions/deitz/iterators/test_promote_var_function_and_iterate.future
- Type and parameter functions are not checked for side effects.
- Subclassing uninstantiated generic classes should be prohibited but is not.
- Errors from calls to 'compilerError' may be incorrect due to dynamic dispatch.
  # classes/bradc/compilerErrorInMethod/testClear.future


Input and Output
----------------
- Binary I/O is not implemented.
- Format control for precision/width is lacking.
  Workaround: see doc/technotes/README.format
- Input of whole arrays is not implemented.
  Workaround: use a loop, e.g., for e in A do read(e);
  # types/file/fileIO.future
- Using 'on' in a writeThis method can lead to a deadlock.
  # multilocale/bradc/needMultiLocales/writeThisUsingOn.future
  # distributions/vass/dmap-writeln-default-value.future


Task Parallelism and Synchronization
------------------------------------
# OMITTED: multilocale/deitz/needMultiLocales/test_big_recursive_on.future
#   I think what is wanted here is a multi-plexing tasking layer
# OMITTED: multilocale/deitz/needMultiLocales/test_big_recursive_on_begin.future
#   I think what is wanted here is a multi-plexing tasking layer
# OMITTED: parallel/begin/deitz/test_big_recursive_begin.future
#   I think what is wanted here is a multi-plexing tasking layer
- Atomic statements are not implemented.
- Deadlocks may occur due to an insufficient number of threads.
  # parallel/cobegin/deitz/test_many_threads.future (other issues too)
- Arrays may not be moved to the heap due to begin statements or
  other indirect array element accesses.
  # memory/deitz/test_tricky_heap_case.future
- Sync and single type qualifiers are not disallowed on types that are
  not supported.
  # parallel/single/hilde/jbreitbart.future
- Sync and single variables in records are not properly copied out
  when the record is passed as an out or inout argument.
  # types/single/sungeun/writeRecordInOutProc.future
  # types/sync/sungeun/writeRecordInOutProc.future
  # types/sync/sungeun/writeRecordOutProc.future


Data Parallelism
----------------
# OMITTED: studies/shootout/nbody/nbody_fullreduction.future
#  b/c not sure how to describe
- Some data parallel statements that should be parallelized are
  serialized with a warning message "X has been serialized".  In some
  case, this can be fixed in the program.
  E.g., Change '+ reduce for i in 1..n do i**2' to
                 '+ reduce forall i in 1..n do i**2' to avoid a
  warning that the reduce has been serialized.  In other cases, this
  is a current limitation:
  1. Scans are always serialized.
  2. Assignments from ranges to multidimensional arrays are always serialized.
  3. Assignment, reductions, and parallel iteration over opaque domains and
     arrays are always serialized.
- Reductions and scans of arrays of arrays may result in errors.
  # arrays/sungeun/array_of_arrays/bxor_reduce.future
  # arrays/sungeun/array_of_arrays/max_reduce.future
  # arrays/sungeun/array_of_arrays/sum_reduce.future
- Reductions zippered arrays of mismatched rank result in a compile time error.
  # arrays/diten/reduce2Dwith3D.future
  # arrays/diten/reduce3Dwith2D.future
- Records in reduction classes may results in out-of-bound indexing
  problems.
  # studies/kmeans/kmeansonepassreduction-mystery.future
- Parallel zippered iteration does not perform runtime size/shape checks
  # arrays/bradc/badParZip.future
  # arrays/claridge/arraySizeMismatch.future
- Whole-domain assignment operations on sparse domains are not all
  serialized as they should be.
  # domains/sungeun/sparse/minus_equals.future
  # domains/sungeun/sparse/plus_equals.future


Locales and Domain Maps
-----------------------
- The default value for locale types is incorrect.
  # types/locale/bradc/defaultLocaleVal.future
  # multilocale/sungeun/locale_default.future
- On statement variable declarations are not yet supported.
  E.g., on Locales(1) var x: real;
  # multilocale/sungeun/on_statement_var_decl.future
- String assignment across locales is by reference rather than value.
  # distributions/bradc/block1Dlocale.future
  # multilocale/diten/needMultiLocales/remoteString3.future
- The local statement is not well supported.  For example, declaring
  domains (whether explicitly via a declaration or implicitly via
  slicing results in a seg fault or non-local access error).  On
  statements should be illegal, but result in local execution.
  # multilocale/local/sungeun/local_privatization.future
  # users/jglewis/locClassSegFault.future
  # distributions/dm/t3.future


User-Defined Reductions and Scans and User-Defined Domain Maps
--------------------------------------------------------------
- User-defined reductions and scans are not yet implemented.
- User-defined domain maps are not yet implemented.
  # Someone might run into this if they were implementing a domain map


Standard Modules, Standard Distributions, and Standard Layouts
--------------------------------------------------------------
- On some platforms, the Math module is limited by the back-end C compiler.
- Extended precision math functions are not supported.
  # modules/standard/math/figueroa/extended-precision_math_functions.future
- The BlockCyclic distribution is incomplete.
- Reindexing stridable Cyclic is not fully supported.
  # users/jglewis/test_cyclic_dist.future
- Block and Cyclic domains containing indices near the minimum or
  maximum integral type may overflow.
- Array assignment fails for Block distributions with bounding boxes
  that do not overlap with the bounds of the domain.
  # arrays/sungeun/multilocale/weird_bbox_block.future
- Distribution equality is not implemented properly.
  # distributions/sungeun/equality1.future
  # distributions/sungeun/equality2.future
- Records with domain map fields do not work.
  # types/records/sungeun/distInRecord.future
  # types/records/sungeun/distInRecordInClass.future


Miscellaneous
-------------
- Creating many domain types or arrays or tuples types causes the
  compilation time to become unreasonable.
  # arrays/deitz/many/test_many_arrays_of_star_tuples.future
  # arrays/deitz/many/test_many_ranks_of_arithmetic_domains.future
- Default values for formal arguments do not accept conditional
  expressions.
  # functions/deitz/default/test_default_conditional_expr.future
- Bounds checking is not complete.
  # e.g., arrays/claridge/arraySizeMismatch.future
- Overloading operations such as multiplication for domain literals not
  supported.
  # domains/claridge/multiplicationSyntaxCheck.future
- Integer constants should be 64-bit.
  # types/range/hilde/align64.future
  # types/range/hilde/needRangeCountType.future
  # types/scalar/hilde/absMinInt.future
  # users/vass/param-uint-to-param-string.future
- Leaving off () when calling exit results in an internal error.
  # exits/sungeun/exitWithNoParensNoArgs.future
- Extern support is not robust.
  # extern/bradc/emptyRecords/emptyrecordexternfn.future
  # users/ferguson/extern_class_test.future
- Fixed length strings are not implemented.
  # trivial/jturner/fixedStringEquals.future
- Types composed of runtime types are not runtime types
  # arrays/deitz/part3/test_record_of_array_type.future
  # arrays/deitz/part3/test_record_of_domain_type.future
  # arrays/deitz/part6/test_tuple_of_array.future
  # types/tuple/diten/runtimeTypeInTuple.future
  # types/tuple/diten/runtimeTypeInTuple2.future
  # types/tuple/diten/tupleOfArray.future
  # types/tuple/diten/tupleOfArray2.future
  # types/tuple/diten/tupleOfArrayReturnType.future
  # types/tuple/stonea/returnArrayTuple.future
- Printing of a string field in a record in a class does not work.
  # types/records/sungeun/stringInRecordInClass.future
  # types/string/sungeun/string1InRecordInClass.future
  # types/string/sungeun/string2InRecordInClass.future
- Compiler warning mechanism can result it lost warning if there are
  multiple warnings.
  # trivial/vass/repeated-warning-1.future
- Compiler warning mechanism not always type-checked correctly.
  # users/vass/tuple-crash-1.future


Multi-locale/GASNet executions
------------------------------
- stdin does not work for multi-locale/GASNet executions


Portability
-----------
Cray XE:
- Native conduit not yet supported.  See doc/platform/README.xe-cle
  for details.

Cray XT:
- The memory limit for Chapel programs may need to be set manually.
  See doc/platforms/README.xt-cle for details.

Cray CX1/CX1000:
- Support is only provided using Linux.

PGI compilers (and possibly others):
- Identifiers in the generated code may exceed the back-end compiler's limit.
- Floating point literals of -0.0 may not work as intended.


IEEE floating-point standard conformance:
  The --ieee-float flag is implemented by passing appropriate flags to
  the back-end compiler.  For some compilers, 100% IEEE floating-point
  conformance is not implemented.  In such cases, the --ieee-float
  flag will request the most standard conformant floating-point
  behavior (if such behavior can be identified).

