==================================================
Initial support for calling C routines from Chapel
==================================================

This README describes some initial support that we have added to the
compiler for calling from Chapel to C.  This mechanism should be
considered a stopgap technology until we have developed and
implemented more robust concepts, which is why it's described in this
README rather than the language specification.


Calling external C routines
---------------------------

1) Prototype the C routine in your Chapel code

   We have added the _extern keyword to our compiler as a means of
   defining a function that will be defined by an external C file
   rather than the Chapel code.  For a C function foo() that takes no
   arguments and returns nothing, the prototype would appear as
   follows:

       _extern def foo();

   C functions which return values that you wish to refer to within
   your Chapel program must have those return types declared (the
   Chapel compiler cannot infer the return type as it does with Chapel
   functions since it does not analyze the C source code).  To make
   the function above return a C "double", it would be declared:

       _extern def foo(): real;

   Similarly, external functions that expect arguments must declare
   those arguments.

   All C types must be expressed in terms of their Chapel equivalents.
   This can cause portability issues in certain cases due to the fact
   that C types don't have well-defined sizes.  For example, if
   function foo returns a C "int", that type could correspond to a
   Chapel int(32) or an int(64) or possibly some other int size
   depending on your C compiler and platform.  Similarly, scalar C
   types that don't have a direct Chapel equivalent (e.g., size_t) are
   currently difficult to interface with in a portable manner.  The
   burden of making types match is on the user, though any problematic
   mismatches ought to be flagged during Chapel's C compilation step.

   Note that Chapel strings can be passed to C functions, though
   warnings can occur during C compilation due to mismatches between
   the const-ness of the char*'s used to implement the strings.

   More interesting types like records and classes are currently
   difficult to pass to C effectively.  See the description in the
   next section about "opaque" types for one way of dealing with
   these.

   Types of function arguments may be omitted, in which case the types
   will be inferred based on the Chapel callsite.  For example, the
   following Chapel code:

       _extern def foo(x: int, y): real;

       var a, b: int;

       foo(a, b);

   Would imply that external function foo takes two 32-bit integer
   values (likely an "int" or "short" in most C implementations) and
   returns a 64-bit real (double).

   External function arguments can be declared with default arguments
   in which case the default argument will be supplied by the Chapel
   compiler if it is omitted at the callsite.  For example:

       _extern def foo(x: int, y = 1.2): real;

       foo(0);

   Would cause external function foo() to be called with the arguments
   0 and 1.2.

   C varargs functions can be declared using Chapel's varargs ("...")
   syntax.  For example, the following declaration prototypes C's
   printf function:

       _extern def printf(fmt: string, vals...?numvals): int;


2) Call the C routines.

   Do this as you would call any Chapel routine.


3) Specify C implementation files.

   On your Chapel compile command line, list the header files that
   contain the external C routine prototypes, as well as the source
   (.c) or object (.o) files that contain their definition.  For
   example, if the foo() function defined above was defined in foo.h
   and foo.c, it could be added to the compilation using either:

       chpl foo.h foo.c myProgram.chpl
or:    chpl foo.h foo.o myProgram.chpl (if foo.c had already been compiled)

   The effect of naming such files on the command line is as follows:

   * During Chapel's C code generation stage, any header files listed
     on the compiler's command line will be #include'd by the
     generated code in order to ensure that the appropriate prototype
     is used before making any calls to the routine.

   * During Chapel's C compilation stage, any C files on the command
     line will be compiled using the same flags as the
     Chapel-generated C files (use --print-commands to see these
     compile commands).

   * During Chapel's link step, any .o files created by this C compile
     step will be linked to the .o files listed on the compiler's
     command-line as well as the compiler-generated code and runtime
     libraries.


Referring to External C Structures
----------------------------------

External C struct types can be referred to within Chapel by prefixing
a Chapel record definition with the _extern keyword.  For example,
given an external C structure defined in foo.h called fltdbl:

    typedef struct _fltdbl {
      float x;
      double y;
    } fltdbl;

This type could be referred to within a Chapel program using:

   _extern record fltdbl {
     ...
   }

Within the Chapel declaration, some or all of the fields from the C
structure may be specified.  The order of these fields need not match
the order they were specified within the C code.  Any fields that are
not specified (or that cannot be specified because there is no
equivalent Chapel type) cannot be referenced within the Chapel code.
Thus, the following declaration would permit access to both fields x
and y within variables of type fltdbl:

   _extern record fltdbl {
     var x: real(32);
     var y: real(64);
   }

as would the following declaration:

   _extern record fltdbl {
     var x: real(32);
     var y: real(64);
   }

Alternatively, the external declaration could only mention one of the
fields.  For example, the following declaration would permit field y
to be accessed, but not field x:

   _extern record fltdbl {
     var y: real(64);
   }

Alternatively, the external declaration can avoid mentioning any
fields, which would permit variables of that struct type to be passed
between Chapel and C routines, but their fields could not be accessed
within the Chapel program.

   _extern record fltdbl {
   }

A C header file containing the struct's definition in C must be
specified on the chpl compiler command line.  Note that currently only
typdef'd C structures are supported.  In the future we anticipate both
typedef'd and non-typedef'd structures to be declared using _extern
declarations.


Opaque Types
------------

You can refer to external pointer-based C types that cannot be
described in Chapel using the "opaque" keyword.  As the name implies,
these types are opaque as far as Chapel is concerned and cannot be
used for operations other than argument passing and assignment
(to/from other similarly opaque types).

For example, Chapel could be used to call an external C function that
returns a pointer to a structure as follows:

    _extern def returnStructPtr(): opaque;

    var structPtr: opaque = returnStructPtr();

However, because structPtr's type is opaque, it cannot be used for
much apart from assigning it to other opaque variables of matching
underlying type, or passing it back to an external C routine that
expects a pointer-to-struct of that type:

    _extern def operateOnStructPtr(ptr: opaque);

    var copyOfStructPtr = structPtr;

    operateOnStructPtr(structPtr);


Referring to External C Types
-----------------------------

You can refer to external types defined in C using _extern plus the
normal type alias keyword.  By leaving off any sort of type
definition, you are telling the Chapel compiler that it can't assume
it knows anything about how the type is represented or how to operate
on it.  Effectively, it defines a new primitive type in Chapel.  For
example, the following declaration says that there is an external type
named 'foo':

    _extern type foo;

This permits you to declare variables of type 'foo' and to declare
external functions that accept or return arguments of type 'foo'.
Over time we will also add support for describing things about
external types, but at present that support is incomplete.


Referring to External C Variables
---------------------------------

Similarly, an external variable or constant can be referred to within
Chapel by prefixing its declaration with the _extern keyword.  For
example:

    _extern var bar: foo;

would refer to an external variable defined in the C code of type foo.


Future Directions
-----------------

The current implementation was implemented as a quick hack to give
users access to C in limited ways.  Over time, we will be developing a
stronger story for making calls between C and Chapel.  If the features
above are insufficient for your needs in the near-term, please let us
know at: chapel_info@cray.com.
