==================================================
Initial support for calling C routines from Chapel
==================================================

This README describes initial support in our Chapel compiler for
calling from Chapel to C.  This mechanism should be considered a
stopgap technology until we have developed and implemented more robust
concepts, which is why it's described in this README rather than the
language specification.


Calling external C routines
---------------------------

Step 1: Prototype the C routine in your Chapel code

   We have added the _extern keyword to our compiler as a means of
   defining a function that will be defined by an external C routine
   rather than within the Chapel code.  For a C function foo() that
   takes no arguments and returns nothing, the prototype would appear
   as follows:

       _extern proc foo();

   C functions that return values which you wish to refer to within
   your Chapel program must have those return types declared (the
   Chapel compiler cannot infer the return type as it does with Chapel
   functions since it does not analyze the C source code).  To make
   the function above return a C "double", it would be declared:

       _extern proc foo(): real;

   Similarly, external functions that expect arguments must declare
   those arguments.

   All C types must be expressed in terms of their Chapel equivalents.
   This can cause portability challenges in certain cases due to the
   fact that C types don't have well-defined sizes.  For example, if
   function foo() returns a C "int", that type might correspond to a
   Chapel int(32) or an int(64) depending on your C compiler and
   platform.  The burden of making types match is on the user, though
   any problematic mismatches ought to be flagged during Chapel's C
   compilation step by a good C compiler.

   Note that Chapel strings can be passed to C functions, though
   warnings can occur during C compilation due to mismatches between
   the const-ness of the char*'s used to implement the strings.

   More interesting Chapel types like records or classes are currently
   difficult to pass to C effectively.  See the description in the
   following section about "opaque" types for one way of dealing with
   these.  External C types can be referenced in function prototypes
   as well.  See the following section on referring to external C
   structures for more information.

   Types of function arguments may be omitted, in which case the types
   will be inferred based on the Chapel callsite.  For example, the
   following Chapel code:

       _extern proc foo(x: int, y): real;

       var a, b: int;

       foo(a, b);

   Would imply that external function foo takes two 32-bit integer
   values (likely an 'int' for most C compilers) and returns a 64-bit
   real ('double' in C).  External function declarations with omitted
   type arguments can also be used to support calls to external C
   macros that may support multiple argument signatures.

   External function arguments can be declared with default arguments
   in which case the default argument will be supplied by the Chapel
   compiler if it is omitted at the callsite.  For example:

       _extern proc foo(x: int, y = 1.2): real;

       foo(0);

   Would cause external function foo() to be called with the arguments
   0 and 1.2.

   C varargs functions can be declared using Chapel's varargs ("...")
   syntax.  For example, the following declaration prototypes C's
   printf function:

       _extern proc printf(fmt: string, vals...?numvals): int;

   External C functions or macros that accept type arguments can also
   be prototyped in Chapel by declaring the argument as a type.  For
   example:

       _extern foo(type t);

   Calling such a routine with a Chapel type will cause the name of
   the type to be passed to the routine.


Step 2: Call the C routines.

   Do this as you would call any Chapel routine.


Step 3: Specify C implementation files.

   On your Chapel compile command line, list the header files that
   contain the external C routine prototypes, as well as the source
   (.c), object (.o), or archive (.a) files that contain their
   definition.  For example, if the foo() function defined above was
   defined in foo.h and foo.c, it could be added to the compilation
   using either:

       chpl foo.h foo.c myProgram.chpl
or:    chpl foo.h foo.o myProgram.chpl (if foo.c had already been compiled)
or:    chpl foo.h -lfoo myProgram.chpl (if foo.c had been archived in libfoo.a)

   The effect of naming such files on the command line is as follows:

   * During Chapel's C code generation stage, any header files listed
     on the compiler's command line will be #include'd by the
     generated code in order to ensure that the appropriate prototype
     is used before making any calls to the routine.

   * During Chapel's C compilation stage, any C files on the command
     line will be compiled using the same flags as the
     Chapel-generated C files (use --print-commands to see these
     compile commands).

   * During Chapel's link step, any .o files created by this C compile
     step will be linked to the .o and .a files listed on the
     compiler's command-line along with the compiler-generated code
     and runtime libraries.


Referring to External C Structures
----------------------------------

External C struct types can be referred to within Chapel by prefixing
a Chapel record definition with the _extern keyword.  For example,
given an external C structure defined in foo.h called fltdbl:

    typedef struct _fltdbl {
      float x;
      double y;
    } fltdbl;

This type could be referred to within a Chapel program using:

   _extern record fltdbl {
     ...
   }

Within the Chapel declaration, some or all of the fields from the C
structure may be specified.  The order of these fields need not match
the order they were specified within the C code.  Any fields that are
not specified (or that cannot be specified because there is no
equivalent Chapel type) cannot be referenced within the Chapel code.
Thus, the following declaration would permit access to both fields x
and y within variables of type fltdbl:

   _extern record fltdbl {
     var x: real(32);
     var y: real(64);
   }

as would the following declaration:

   _extern record fltdbl {
     var y: real(64);
     var x: real(32);
   }

Alternatively, the external declaration could only mention one of the
fields.  For example, the following declaration would permit field y
to be accessed by a Chapel program, but not field x (though both would
still be stored in any variables of type fltdbl).

   _extern record fltdbl {
     var y: real(64);
   }

Alternatively, the external declaration can avoid mentioning any
fields, which would permit variables of that struct type to be passed
between Chapel and C routines, but their fields could not be accessed
within the Chapel program.

   _extern record fltdbl {
   }

A C header file containing the struct's definition in C must be
specified on the chpl compiler command line.  Note that currently only
typdef'd C structures are supported.  In the future we anticipate both
typedef'd and non-typedef'd structures to be declared using _extern
declarations.


Referring to External C Types
-----------------------------

You can refer to external types defined in C using _extern plus the
normal type alias keyword.  By leaving off any sort of type
definition, you are telling the Chapel compiler that it can't assume
it knows anything about how the type is represented or how to operate
on it.  Effectively, it defines a new primitive type in Chapel.  For
example, the following declaration says that there is an external type
named 'foo':

    _extern type foo;

This permits you to declare variables of type 'foo' and to declare
external functions that accept or return arguments of type 'foo'.
Because Chapel knows nothing about the type 'foo' it cannot be
manipulated within Chapel apart from passing it between routines.  The
type symbol 'foo' must be declared in a C header file given on
Chapel's compiler command-line.

If an external C type can be described in Chapel, that definition can
be given, permitting Chapel to interact with the type directly.  For
example, if the standard C type corresponded to a 64-bit int, you
could describe this in Chapel using:

    _extern type size_t = int(64);

This capability can also be used to create aliases for C types when
they don't conflict with Chapel types.  For example:

    _extern type double = real(64);

C array types can be described within Chapel using its homogenous
tuple type.  For example, given the following C typedef:

    typedef double vec[3];

This could be described in Chapel using:

    _extern type vec = 3*real(64);


Referring to External C Variables
---------------------------------

Similarly, an external variable or constant can be referred to within
Chapel by prefixing its declaration with the _extern keyword.  For
example:

    _extern var bar: foo;

would refer to an external variable named 'bar' defined in the C code
of type 'foo'.


Opaque Types
------------

You can refer to external pointer-based C types that cannot be
described in Chapel using the "opaque" keyword.  As the name implies,
these types are opaque as far as Chapel is concerned and cannot be
used for operations other than argument passing and assignment
(to/from other similarly opaque types).

For example, Chapel could be used to call an external C function that
returns a pointer to a structure as follows:

    _extern proc returnStructPtr(): opaque;

    var structPtr: opaque = returnStructPtr();

However, because structPtr's type is opaque, it cannot be used for
much apart from assigning it to other opaque variables of matching
underlying type, or passing it back to an external C routine that
expects a pointer-to-struct of that type:

    _extern proc operateOnStructPtr(ptr: opaque);

    var copyOfStructPtr = structPtr;

    operateOnStructPtr(structPtr);

Note that as our support for external C types improves to the point
that we can describe pointer types directly, we will likely deprecate
this feature.


Future Directions
-----------------

The current implementation was implemented as a means for us to
leverage existing C routines and types.  Over time, we will be
developing a stronger story for making calls between C and Chapel.  If
the features above are insufficient for your needs in the near-term,
please let us know at: chapel_info@cray.com.
