====================
Prototype GMP module
====================

This README describes a prototype implementation of a standard GMP
(GNU Multiple Precision Arithmetic Library) module in Chapel.  It
should be considered incomplete in that (a) only a subset of the full
GMP interface is supported, and (b) the performance is currently
lacking due to extraneous copies in the Chapel code that have not yet
been optimized away.  If there is sufficient interest, we can expand
this prototype to support the full GMP interface and performance.

We have used this prototype GMP module to implement a port of the
standard GMP Chudnovsky algorithm for computing pi to arbitrary digits
in pi.  If you are interested in receiving a copy of this Chapel
program, or simply in expressing your support for GMP within Chapel,
please contact us at chapel_info@cray.com.


Using the GMP Module
--------------------

Step 1: Build GMP

          cd $CHPL_HOME/third-party 
          gmake gmp


Step 2: Have your Chapel program 'use' the standard GMP module

          use GMP;   // put this statement in your Chapel program


Step 3: Start using the supported subset of GMP types and routines
        (see below for a complete listing)

Step 4: When you compile your program, add the following chpl compiler arguments:
        gmp.h -lgmp -I../../../runtime/include -I../../../runtime/include/tasks/`../../../util/chplenv/tasks` -I../../../runtime/include/threads/`../../../util/chplenv/threads` ../../../runtime/include/chplgmp.h  ../../../runtime/src/chplgmp.c

        (hopefully we can add these automatically in the future).

Using the BigInt class
-------------------------------------

The GMP Chapel module provides a BigInt class wrapping GMP integers.
At the present time, only the functions for mpz (ie signed integer)
GMP types are supported with BigInt; future work will be to make
fixed-size wrappers for mpn types and a class for floating-point types.

See the source code in modules/standard/GMP.chpl. Also, the BigInt methods
all wrap GMP functions with the obvious names. The BigInt methods are
locale-aware. Also, methods BigInt objects are setting the receiver,
so e.g. myBigInt.add(x,y) sets myBigInt to x + y.

A code example:
 var a = new BigInt(); // initialize a GMP value, set it to zero

 a.fac_ui(100); // set a to 100!
 
 writeln(a); // output 100!

 delete a; // free memory used by the GMP value

 var b = new BigInt("48473822929893829847"); // initialize from a decimal string
 b.add_ui(b, 1); // add one to b
 
 delete b; // free memory used by b

Calling GMP functions directly
-------------------------------------

The GMP Chapel module supports calling GMP functions directly,
if you know what you are doing. For a full reference to GMP capabilities,
please refer to the GMP website (http://gmplib.org).

At present, Chapel's GMP module supports the following GMP types:

  mp_bitcnt_t
  mpf_t
  mpz_t

And the following GMP routines:

  gmp_fprintf()
  gmp_printf()

  mpf_add()
  mpf_clear()
  mpf_div_2exp()
  mpf_get_d()
  mpf_get_prec()
  mpf_init()
  mpf_mul()
  mpf_mul_ui()
  mpf_out_str()
  mpf_set_d()
  mpf_set_default_prec()
  mpf_set_prec_raw()
  mpf_set_z()
  mpf_sub()
  mpf_ui_div()
  mpf_ui_sub()

  mpz_add()
  mpz_add_ui()
  mpz_addmul_ui()
  mpz_clear()
  mpz_init()
  mpz_mul()
  mpz_mul_ui()
  mpz_neg()
  mpz_set_ui()
  mpz_sizeinbase()
  mpz_tdiv_q()

It also supports the following standard C types (which will eventually
be moved into a module of their own):

  double
  long
  size_t
