\sekshun{Domains and Arrays}
\label{Domains_and_Arrays}
\index{domains}
\index{arrays}

A \emph{domain} describes a collection of names for data.  These names
are referred to as the \emph{indices} of the domain.  All indices for
a particular domain are values with some common type.  Valid types for
indices are primitive types and class references or unions, tuples or
records whose fields are valid types for indices.  This excludes
ranges, domains, and arrays.  Domains have a rank and a total order on
their elements.  An \emph{array} is a map from a domain's indices to a
collection of variables.  Chapel supports a variety of kinds of
domains and arrays defined over those domains as well as a mechanism
to allow application-specific implementations of arrays.

Arrays abstract mappings from sets of values to variables.  This key
use of data structures coupled with the generic syntactic support for
array usage increases software reusability.  By separating the sets of
values into their own abstraction, \emph{i.e.}, domains, distributions
can be associated with sets rather than variables.  This enables the
orthogonality of data distributions.  Distributions are discussed
in~\rsec{Domain_Maps}.

\subsection{Domains}
\label{Domains}

Domains are first-class ordered sets of indices.  There are five kinds
of domains:
\begin{itemize}
\item
Arithmetic domains are rectilinear sets of Cartesian indices that can
have an arbitrary rank.
\item
Sparse domains are subdomains that support a notion of an implicit
``zero element'' for array elements described by its base domain but
not the domain itself.
\item
Associative domains are sets of indices where the type of the index is
some type that is not an array, domain, or range.  Associative domains
define dictionaries or associative arrays implemented via hash tables.
\item
Enumerated domains are a special case of associative domains where the
indices are defined by an enumerated type.
\item
Opaque domains are sets of anonymous indices.  Opaque domains define
graphs and unspecified sets.
\end{itemize}

\subsubsection{Domain Types}
\label{Domain_Types}
\index{domains!types}

Domain types vary based on the kind of the domain.  The type of an
arithmetic domain is parameterized by the rank of the domain and the
integral type of the indices.  The type of a sparse domain is
parameterized by the type of the domain that defines its bounding
index set.  The type of an associative domain is parameterized by the
type of the index.  The type of an opaque domain is unique.  The type
of an enumerated domain is parameterized by the enumerated type.

The syntax of a domain type is summarized as follows:
\begin{syntax}
domain-type:
  arithmetic-domain-type
  associative-domain-type
  opaque-domain-type
  enumerated-domain-type
  sparse-domain-type
  subdomain-type
\end{syntax}  

\begin{example}
In the code
\begin{chapel}
var D: domain(2) = [1..n, 1..n];
\end{chapel}
\chpl{D} is defined as a two-dimensional arithmetic domain and is
initialized to contain the set of indices $(i,j)$ for all $i$ and $j$
such that $i \in {1, 2, \ldots, n}$ and $j \in {1, 2, \ldots, n}$.
\end{example}

\subsubsection{Index Types}
\label{Index_Types}
\index{domains!index types}

Each domain has a corresponding \emph{index} type which is the type of
the domain's indices qualified by its status as an index.  Variables
of this type can be declared using the following syntax:
\begin{syntax}
index-type:
  `index' ( domain-expression )
\end{syntax}
If the type of the indices of the domain is \chpl{int}, then the index
type can be converted into this type.

A value with a type that is the same as the type of the indices in a
domain but is not the index type can be converted into the index type
using a special ``method'' called \chpl{index}.

\begin{example}
In the code
\begin{chapel}
var j = D.index(i);
\end{chapel}
the type of the variable \chpl{j} is the index type of
domain \chpl{D}.  The variable \chpl{i}, which must have the same type
as the underlying type of the indices of \chpl{D}, is verified to be
in domain \chpl{D} before it is assigned to \chpl{j}.
\end{example}

Values of index type are known to be valid and may have specialized
representations to facilitate accessing arrays defined for that
domain. It may therefore be less expensive to access arrays using
values of appropriate index type rather than values of the more
general type the domain is defined over.

\subsubsection{Domain Assignment}
\label{Domain_Assignment}
\index{domains!assignment}

Domain assignment is by value.  If arrays are declared over a domain,
domain assignment impacts these arrays as discussed
in~\rsec{Association_of_Arrays_to_Domains}, but the arrays remain
associated with the same domain regardless of the assignment.

\subsubsection{Formal Arguments of Domain Type}
\label{Formal_Arguments_of_Domain_Type}
\index{formal arguments!domains}
\index{domains!as formal arguments}

Domains are passed to functions by reference.  Formal arguments that
receive domains are aliases of the actual arguments.  It is a
compile-time error to pass a domain to a formal argument that has a
non-blank intent.

\subsubsection{Iteration over Domains}
\label{Iteration_over_Domains}

All domains support iteration via forall and for loops over the
indices in the set that the domain defines.  The type of the indices
returned by iterating over a domain is the index type of the domain.

\subsubsection{Domain Promotion of Scalar Functions}
\label{Domain_Promotion_of_Scalar_Functions}
\index{domains!promotion}

Domain promotion of a scalar function is defined over the domain type
and the type of the indices of the domain (not the index type).

\begin{example}
Given an array \chpl{A} with element type \chpl{int} declared over a
one-dimensional domain \chpl{D} with integral type \chpl{int}, then
the array can be assigned the values given by the indices in the
domain by writing
\begin{chapel}
A = D;
\end{chapel}
\end{example}

\subsection{Arrays}
\label{Arrays}
\index{arrays}

Arrays associate variables or elements with the sets of indices in a
domain.  Arrays must be declared over domains and have a specified
element type.

\subsubsection{Array Types}
\label{Array_Types}
\index{arrays!types}

The type of an array is parameterized by the type of the domain that
it is declared over and the element type of the array.  Array types
are given by the following syntax:
\begin{syntax}
array-type:
  [ domain-expression ] type-specifier

domain-expression:
  expression
\end{syntax}
The \sntx{domain-expression} must specify a domain that the array can
be declared over.  This can be a domain literal.  If it is a domain
literal, the square brackets around the domain literal can be omitted.

\begin{example}
In the code
\begin{chapel}
var A: [D] real;
\end{chapel}
\chpl{A} is declared to be an array over domain \chpl{D} with
elements of type \chpl{real}.
\end{example}

An array's element type can be referred to using the member symbol
\chpl{eltType}.

\begin{example}
In the following example, \chpl{x} is declared to be of type
\chpl{real} since that is the element type of array \chpl{A}.
\begin{chapel}
var A: [D] real;
var x: A.eltType;
\end{chapel}
\end{example}

\subsubsection{Array Indexing}
\label{Array_Indexing}
\index{arrays!indexing}

Arrays can be indexed by indices in the domain they are declared over.
The indexing results in an access of the element that is mapped by
this index.

\begin{example}
If \chpl{A} is an array with element type \chpl{real} declared over a
one-dimensional arithmetic domain \chpl{[1..n]}, then the first
element in \chpl{A} can be accessed via the expression \chpl{A(1)} and
set to zero via the assignment \chpl{A(1) = 0.0}.
\end{example}

Indexing into an array with a domain is call array slicing and is
discussed in the next section.

Arithmetic arrays also support indexing over the components of their
indices for multidimensional arithmetic domains (where the indices are
tuples), as described in~\rsec{Arithmetic_Array_Indexing}.

One-dimensional arrays may be indexed by 1-tuples of their index
types.
\begin{example}
The code
\begin{chapel}
def f(A: [], is...)
  return A(is);
\end{chapel}
defines a function that takes an array as the first argument and a
variable-length argument list.  It then indexes into the array using
the tuple that captures the actual arguments.  This function works
even for one-dimensional arrays because one-dimensional arrays can be
indexed into by 1-tuples.
\end{example}

\subsubsection{Array Slicing}
\label{Array_Slicing}
\index{arrays!slicing}

An array can be indexed by a domain that has the same type as the
domain which the array was declared over.  Indexing in this manner has
the effect of array slicing.  The result is a new array declared over
the indexing domain where the elements in the array alias the elements
in the array being indexed.

\begin{example}
Given the definitions
\begin{chapel}
var OuterD: domain(2) = [0..n+1, 0..n+1];
var InnerD: domain(2) = [1..n, 1..n];
var A, B: [OuterD] real;
\end{chapel}
the assignment given by
\begin{chapel}
A(InnerD) = B(InnerD);
\end{chapel}
assigns the elements in the interior of \chpl{B} to the elements in
the interior of \chpl{A}.
\end{example}

Arithmetic arrays also support slicing by indexing into them with
ranges or tuples of ranges as described
in~\rsec{Arithmetic_Array_Slicing}.

\subsubsection{Array Assignment}
\label{Array_Assignment}
\index{arrays!assignment}

Array assignment is by value.  Arrays can be assigned arrays, ranges,
domains, iterators, or tuples.  If \chpl{A} is an lvalue of array type
and \chpl{B} is an expression of either array, range, or domain type,
or an iterator, then the assignment
\begin{chapel}
A = B;
\end{chapel}
is equivalent to
\begin{chapel}
forall (i,e) in (A.domain,B) do
  A(i) = e;
\end{chapel}
If the zipper iteration is illegal, then the assignment is illegal.
Notice that the assignment is implemented with the semantics of
a \chpl{forall} loop.

Arrays can be assigned tuples of values of their element type if the
tuple contains the same number of elements as the array.  For
multidimensional arrays, the tuple must be a nested tuple such that
the nesting depth is equal to the rank of the array and the shape of
this nested tuple must match the shape of the array.  The values are
assigned element-wise.

Arrays can also be assigned single values of their element type.  In
this case, each element in the array is assigned this value.
If \chpl{e} is an expression of the element type of the array or a
type that can be implicitly converted to the element type of the
array, then the assignment
\begin{chapel}
A = e;
\end{chapel}
is equivalent to
\begin{chapel}
forall i in A.domain do
  A(i) = e;
\end{chapel}

\subsubsection{Formal Arguments of Array Type}
\label{Formal_Arguments_of_Array_Type}
\index{arrays!as formal arguments}

Arrays are passed to functions by reference.  Formal arguments that
receive arrays are aliases of the actual arguments.  The ordinary rule
that disallows assignment to formal arguments of blank intent does not
apply to arrays.

When a formal argument has array type, the element type of the array
can be omitted and/or the domain of the array can be queried or
omitted.  In such cases, the argument is generic and is discussed
in~\rsec{Formal_Arguments_of_Generic_Array_Types}.

If a non-queried domain is specified in the array type of a formal
argument, the domain must match the domain of the actual argument.
This is verified at runtime.  There is an exception if the domain is
an arithmetic domain; it is described
in~\rsec{Formal_Arguments_of_Arithmetic_Array_Type}.

\subsubsection{Iteration over Arrays}
\label{Iteration_over_Arrays}

All arrays support iteration via forall and for loops over the
elements mapped to by the indices in the array's domain.

\subsubsection{Array Promotion of Scalar Functions}
\label{Array_Promotion_of_Scalar_Functions}
\index{arrays!promotion}

Array promotion of a scalar function is defined over the array type
and the element type of the array.  The domain of the returned array,
if an array is captured by the promotion, is the domain of the array
that promoted the function.  In the event of zipper promotion over
multiple arrays, the promoted function returns an array with a domain
that is equal to the domain of the first argument to the function that
enables promotion.  If the first argument is an iterator or a range,
the result is a one-based one-dimensional array.

\begin{example}
Whole array operations is a special case of array promotion of scalar
functions.  In the code
\begin{chapel}
A = B + C;
\end{chapel}
if \chpl{A}, \chpl{B}, and \chpl{C} are arrays, this code assigns each
element in \chpl{A} the element-wise sum of the elements in \chpl{B}
and \chpl{C}.
\end{example}

\subsubsection{Array Initialization}
\label{Array_Initialization}
\index{arrays!initialization}

By default, the elements in an array are initialized to the default
values associated with the element type of the array.  There is an
expectation that this default initialization can be overridden for
performance reasons by explicitly marking the array type or variable.

\subsubsection{Array Aliases}
\label{Array_Aliases}
\index{=>@\chpl{=>}}

Array slices alias the data in arrays rather than copying it.  Such
array aliases can be captured and optionally reindexed with the array
alias operator \chpl{=>}.  The syntax for capturing an alias to an
array requires a new variable declaration:
\begin{syntax}
array-alias-declaration:
  identifier reindexing-expression[OPT] => array-expression ;

reindexing-expression:
  [ domain-expression ]

array-expression:
  expression
\end{syntax}
The identifier is an alias to the array specified in
the \sntx{array-expression}.

The optional \sntx{reindexing-expression} allows the domain of the
array alias to be reindexed.  The shape of the domain in
the \sntx{reindexing-expression} must match the shape of the domain of
the \sntx{array-expression}.  Indexing via the alias is governed by
the new indices.

\begin{example}
In the code
\begin{chapel}
var A: [1..5, 1..5] int;
var AA: [0..2, 0..2] => A[2..4, 2..4];
\end{chapel}
an array alias \chpl{AA} is created to alias the interior of
array \chpl{A} given by the slice \chpl{A[2..4, 2..4]}.  The
reindexing expression changes the indices defined by the domain of the
alias to be zero-based in both dimensions.  Thus \chpl{AA(1,1)} is
equivalent to \chpl{A(3,3)}.
\end{example}

\subsection{Arithmetic Domains and Arrays}
\label{Arithmetic_Domains_and_Arrays}
\index{domains!arithmetic}
\index{arrays!arithmetic}

An arithmetic domain is a rectilinear set of Cartesian indices.
Arithmetic domains are specified as a tuple of ranges enclosed in
square brackets.

\subsubsection{Arithmetic Domain Literals}
\label{Arithmetic_Domain_Literals}
\index{domains!arithmetic literals}

An arithmetic domain literal is a square tuple of ranges.
\begin{example}
The expression \chpl{[1..5, 1..5]} defines a $5 \times 5$ arithmetic
domain with the indices $(1, 1), (1, 2), \ldots, (5, 5)$.
\end{example}

\subsubsection{Arithmetic Domain Types}
\label{Arithmetic_Domain_Types}

The type of an arithmetic domain is determined by three components:
(1) the rank of the arithmetic domain (the number of ranges that
define it); (2) an underlying integral type called the
\emph{dimensional index type} which must be identical to each of the
integral element types of the ranges that define the arithmetic
domain; (3) a boolean value indicating whether any of the ranges that
define the domain are stridable or not.  By default, the dimensional
index type of an arithmetic domain is \chpl{int} and the stridability
value is set to false.

The arithmetic domain type is specified by the syntax of a function
call to the keyword \chpl{domain} that takes at least an argument
called \chpl{rank} that is a parameter of type \chpl{int} and
optionally an integral type named \chpl{dim_type} and a boolean value
named \chpl{stridable}.  Its syntax is summarized as follows:
\begin{syntax}
arithmetic-domain-type:
  `domain' ( named-expression-list )
\end{syntax}

\begin{example}
The expression \chpl{[1..5, 1..5]} defines an arithmetic domain with
type \chpl{domain(2, int, false)}.
\end{example}

\subsubsection{Strided Arithmetic Domains}
\label{Strided_Arithmetic_Domains_and_Arrays}
\index{domains!arithmetic, strided}
\index{arrays!arithmetic, strided}

If the ranges that define an arithmetic domain are strided, then the
arithmetic domain is said to be strided and the stridable parameter
must be set to true.  For domains with inferred type, if the
initializing expression uses stridable ranges, the domain will be
inferred to have a stridable parameter of true.

The \chpl{by} operator can be applied to any arithmetic domain to
create a strided arithmetic domain.  It is predefined over an
arithmetic domain and an integer or a tuple of integers.  In the
integer case, the ranges in each dimension are strided by the integer.
In the tuple of integers case, the size of the tuple must match the
rank of the domain; the integers stride each dimension of the domain.
If the ranges are already strided, the strides applied by
the \chpl{by} operator are multiplied to the strides of the ranges.

\subsubsection{Arithmetic Domain Slicing}
\label{Arithmetic_Domain_Slicing}

Arithmetic domains support slicing by indexing into them specifying a
range per dimension.  Square brackets should be used for
multidimensional domains, while either square brackets or parenthesis
can be used for 1D domains.  

For multi-dimensional arithmetic domains, slicing with a rank change
is supported by substituting integral values within a dimension's
range for an actual range.  The resulting domain will have a rank less
than the arithmetic domain's rank and equal to the number of ranges
that are passed in to take the slice.

The result is a subdomain of the domain being sliced, as described
in~\rsec{Subdomains}, as defined by the intersection of the two
domains.  Partially unbounded or completely unbounded ranges may be
used to specify that the slice should extend to the domain's lower
and/or upper bound.

\begin{example}
The following code declares a 2D arithmetic domain \chpl{D}, and then
a number of subdomains of \chpl{D} by slicing into \chpl{D} using
bounded and unbounded ranges.  The \chpl{InnerD} domain describes the
inner indices of D, \chpl{Col2OfD} describes the 2nd column of
\chpl{D}, and \chpl{AllButLastRow} describes all of \chpl{D} except
for the last row.

\begin{chapel}
const D: domain(2) = [1..n, 1..n],
      InnerD = D[2..n-1, 2..n-1],
      Col2OfD = D[.., 2..2],
      AllButLastRow = D[..n-1, ..];
\end{chapel}
\end{example}


\subsubsection{Arithmetic Array Indexing}
\label{Arithmetic_Array_Indexing}

In addition to being indexed by indices defined by their arithmetic
domains, arithmetic arrays can be indexed directly by values of the
dimensional index type where the number of values is equal to the rank
of the array.  This has the semantics of first moving the values into
a tuple and then indexing into the array.  The index represented by
the tuple must be an element of the array's domain or an out-of-bounds
error will occur.

\begin{example}
Given the definition
\begin{chapel}
  var ij = (i,j);
\end{chapel}
the indexing expressions \chpl{A(ij)} and \chpl{A(i,j)} are
equivalent.
\end{example}

\subsubsection{Arithmetic Array Slicing}
\label{Arithmetic_Array_Slicing}
\index{arrays!slice}

An arithmetic array can be sliced by any arithmetic domain that is a
subdomain of the array's defining domain.  If the subdomain
relationship is not met, an out-of-bounds error will occur.  The
result is a subarray whose indices are those of the slicing domain and
whose elements are an alias of the original array's.  If the indices
in the slicing

Arithmetic arrays also support slicing by ranges directly.  If each
dimension is indexed by a range, this is equivalent to slicing the
array by the arithmetic domain defined by those ranges.

For multi-dimensional arithmetic arrays, slicing with a rank change is
supported by substituting integral values within a dimension's range
for an actual range.  The resulting array will have a rank less than
the arithmetic array's rank and equal to the number of ranges that are
passed in to take the slice.

\begin{example}
Given an array
\begin{chapel}
var A: [1..n, 1..n] int;
\end{chapel}
the slice \chpl{A[1..n, 1]} is a one-dimensional array whose elements
are the first column of \chpl{A}.
\end{example}

Array slices may also be expressed using partially unbounded or
completely unbounded ranges.  This is equivalent to slicing the
array's defining domain by the specified ranges to create a subdomain
as described in~\rsec{Arithmetic_Domain_Slicing} and then using that
subdomain to slice the array.

\subsubsection{Formal Arguments of Arithmetic Array Type}
\label{Formal_Arguments_of_Arithmetic_Array_Type}
\index{formal arguments!arithmetic arrays}
\index{arrays!as formal arguments}

Formal arguments of arithmetic array type allow an arithmetic domain
to be specified that does not match the arithmetic domain of the
actual arithmetic array that is passed to the formal argument.  In
this case, the shape (size in each dimension and rank) of the domain
of the actual array must match the shape of the domain of the formal
array.  The indices are translated in the formal array, which is a
reference to the actual array.

\begin{example}
In the code
\begin{chapel}
def foo(X: [1..5] int) { ... }
var A: [1..10 by 2] int;
foo(A);
\end{chapel}
the array \chpl{A} is strided and its elements can be indexed by the
odd integers between one and nine.  In the function \chpl{foo}, the
array \chpl{X} references array \chpl{A} and the same elements can be
indexed by the integers between one and five.
\end{example}

\subsection{Sparse Domains and Arrays}
\label{Sparse_Domains_and_Arrays}
\index{domains!sparse}
\index{arrays!sparse}

Sparse domains are used in Chapel to describe irregular index subsets
and to define sparse arrays.  Sparse arrays are typically used to
represent data aggregates in which a value occurs so frequently that
it would be wasteful to store it explicitly for each occurrence.  This
value is commonly described as the ``zero value'', though we refer to
it as the \emph{implicitly replicated value} or \emph{IRV} since it
may be a value other than zero.

\subsubsection{Sparse Domain Types}

A sparse domain type is specified by the syntax
\begin{syntax}
sparse-domain-type:
  `sparse' `subdomain' ( domain-expression )
\end{syntax}
This syntax specifies that the domain is a sparse subset of the
indices in the domain specified by the \sntx{domain-expression},
sometimes called the \emph{base domain} or \emph{parent domain}.

\begin{example}
The following code declares a 2D dense domain \chpl{D}, followed by a
2D sparse subdomain of \chpl{D} named \chpl{SpsD}.  Since \chpl{SpsD}
is uninitialized, it will initially describe the empty set of indices
from \chpl{D}.
\begin{chapel}
const D: domain(2) = [1..n, 1..n];
var SpsD: sparse subdomain(D);
\end{chapel}
\end{example}


\subsubsection{Sparse Domain Assignment}

Sparse domains can be assigned aggregates of indices from their parent
domain.  Common methods for expressing such aggregates are to use a
tuple of indices, a forall expression that enumerates indices, or an
iterator that generates indices.

\begin{example}
The following three assignments show ways of assigning indices to a
sparse domain, \chpl{SpsD}.  The first assigns the domain two index
values, \chpl{(1,1)} and \chpl{(n,n)}.  The second assigns the domain
all of the indices along the diagonal from
\chpl{(1,1)}$\ldots$\chpl{(n,n)}.  The third invokes an iterator that
is written to \chpl{yield} indices read from a file named
``inds.dat''.  Each of these assignments has the effect of replacing
the previous index set with a completely new set of values.
\begin{chapel}
SpsD = ((1,1), (n,n));
SpsD = [i in 1..n] (i,i);
SpsD = readIndicesFromFile("inds.dat");
\end{chapel}
\end{example}

Sparse domains can be emptied by using a method \chpl{clear} that
clears out its index set.

\begin{example}
The following call will cause the sparse domain \chpl{SpsD} to
describe an empty set of indices as it was when initially declared.
\begin{chapel}
SpsD.clear();
\end{chapel}
\end{example}

As with other domain types, reassigning a domain's index set will
cause arrays declared in terms of that domain to store elements
corresponding to the new indices of the domain.  These elements will
be initialized to the array's IRV by default.



\subsubsection{Modifying a Sparse Domain}

Indices can be incrementally added to or removed from sparse domains.
Sparse domains support a method \chpl{add} that takes an index and
adds it to the sparse domain's index set.  All arrays declared over
this sparse domain will now store an element corresponding to this
index, initialized to be its IRV.

Sparse domains support a method \chpl{remove} that takes an index and
removes this index from the sparse domain.  The values in the arrays
indexed by the removed index are lost.

The operators \chpl{+=} and \chpl{-=} have special semantics for
sparse domains; they are interpreted as calls to the \chpl{add}
and \chpl{remove} methods respectively.  The statement
\begin{chapel}
D += i;
\end{chapel}
is equivalent to
\begin{chapel}
D.add(i);
\end{chapel}
Similarly, the statement
\begin{chapel}
D -= i;
\end{chapel}
is equivalent to
\begin{chapel}
D.remove(i);
\end{chapel}

As with other methods and operators, the \chpl{add}, \chpl{remove},
\chpl{+=}, and \chpl{-=} operators can be invoked in a promoted manner
by specifying an aggregate of indices rather than a single index at a
time.

\subsubsection{Sparse Arrays}

An array declared over a sparse domain can be indexed using all of the
indices in the domain's parent domain.  If it is read using an index
that is not part of the sparse domain's index set, the IRV value is
returned.  Otherwise, the array's unique value corresponding to the
index is returned.

Sparse arrays can only be written at locations corresponding to
indices in their domain's index set.  In general, writing to other
locations will result in a runtime error.

By default a sparse array's IRV is defined as the default value for
the array's element type.  The IRV can be set to any value of the
array's element type by assigning to a pseudo-field named ``IRV'' in
the array.  It is an error to assign a value to the IRV by assigning
to an array element whose index is not described by the sparse domain.

\begin{example}
The following code example declares a sparse array, \chpl{SpsA} using
the sparse domain \chpl{SpsD} (For this example, assume that
\chpl{n}$>$1).  Lines 2 assigns two indices to \chpl{SpsD}'s index set
and then lines 3--4 store the values 1.1 and 9.9 to the corresponding
values of \chpl{SpsA}.  The IRV of \chpl{SpsA} will initially be 0.0
since its element type is \chpl{real}.  However, the fifth line sets
the IRV to be the value 5.5, causing \chpl{SpsA} to represent the
value 1.1 in its low corner, 9.9 in its high corner, and 5.5
everywhere else.  The final statement is an error since it attempts to
assign to \chpl{SpsA} at an index not described by its domain,
\chpl{SpsD}.

\begin{chapel}
var SpsA: [SpsD] real;
SpsD = ((1,1), (n,n));
SpsA(1,1) = 1.1;
SpsA(n,n) = 9.9;
SpsA.IRV = 5.5;
SpsA(1,n) = 0.0;  // ERROR!
\end{chapel}
\end{example}



\subsection{Associative Domains and Arrays}
\label{Associative_Domains_and_Arrays}
\index{domains!associative}
\index{arrays!associative}

An associative domain type can be defined over any scalar type and is
given by the following syntax:
\begin{syntax}
associative-domain-type:
  `domain' ( scalar-type )

scalar-type:
  type-specifier
\end{syntax}
A scalar type is any primitive type, tuple of scalar types, or class,
record, or union where all of the fields have scalar types.
Enumerated types are scalar types but domains declared over enumerated
types are described in~\rsec{Enumerated_Domains_and_Arrays}.  Arrays
declared over associative domains are dictionaries mapping from values
to variables.

\subsubsection{Changing the Indices in Associative Domains}

As with sparse domains, indices can be added or removed to associative
domains.  Associative domains support a method \chpl{add} that takes
an index and adds this index to the associative domain.  All arrays
declared over this associative domain can now access elements
corresponding to this index.

Associative domains support a method \chpl{remove} that takes an index
and removes this index from the associative domain.  The values in the
arrays indexed by the removed index are lost.

The operators \chpl{+=} and \chpl{-=} have special semantics for
associative domains; they are interpreted as calls to the \chpl{add}
and \chpl{remove} methods respectively.  The statement
\begin{chapel}
D += i;
\end{chapel}
is equivalent to
\begin{chapel}
D.add(i);
\end{chapel}
Similarly, the statement
\begin{chapel}
D -= i;
\end{chapel}
is equivalent to
\begin{chapel}
D.remove(i);
\end{chapel}

Like sparse domains, associative domains can be emptied by using a
method \chpl{clear} that clears out its index set.

\begin{example}
The following call will cause the associative domain \chpl{HashD} to
describe an empty set of indices as it was when initially declared.
\begin{chapel}
HashD.clear();
\end{chapel}
\end{example}

\subsubsection{Testing Membership in Associative Domains}

An associative domain supports a \chpl{member} method that can test
whether a particular value is part of the index set. It
returns \chpl{true} if the index is in the associative domain and
otherwise returns \chpl{false}.

\subsection{Opaque Domains and Arrays}
\label{Opaque_Domains_and_Arrays}
\index{domains!opaque}
\index{arrays!opaque}

An opaque domain is a form of associative domain where there is no
algebra on the types of the indices.  The indices are, in essence,
opaque.  The opaque domain type is given by the following syntax:
\begin{syntax}
opaque-domain-type:
  `domain' ( `opaque' )
\end{syntax}

New index values for opaque domains are explicitly requested via a
method called \chpl{create}.  Indices can be removed by a method
called \chpl{remove}.

Opaque domains permit more efficient implementations than associative
domains under the assumption that creation of new domain index values
is rare.

\subsection{Enumerated Domains and Arrays}
\label{Enumerated_Domains_and_Arrays}
\index{domains!enumerated}
\index{arrays!enumerated}

Enumerated domains are a special case of associative domains where the
indices are the constants defined by an enumerated type.  The syntax
of an enumerated domain type is summarized as follows:
\begin{syntax}
enumerated-domain-type:
  `domain' ( enum-type )
\end{syntax}

Enumerated domains are initialized with indices for each constant
defined in the enumerated type they are declared over.

An enumerated domain is specified identically to the associative
domain type, except that the type is an enumerated type rather than
some other value type.

\subsection{Association of Arrays to Domains}
\label{Association_of_Arrays_to_Domains}
\index{domains!association to arrays}
\index{arrays!association to domains}

When an array is declared, it is linked during execution to the domain
over which it was declared.  This linkage is constant and cannot be
changed.

When indices are added or removed from a domain, the change impacts
the arrays declared over this particular domain.  In the case of
adding an index, an element is added to the array and initialized to
the default value associated with the element type.  In the case of
removing an index, the element in the array is removed.

When a domain is reassigned a new value, the array is also impacted.
Values that could be indexed by both the old domain and the new domain
are preserved in the array.  Values that could only be indexed by the
old domain are lost.  Values that can only be indexed by the new
domain have elements added to the new array and initialized to the
default value associated with their type.

For performance reasons, there is an expectation that a method will be
added to domains to allow non-preserving assignment, \emph{i.e.}, all
values in the arrays associated with the assigned domain will be lost.

An array's domain can only be modified directly, via the domain's name
or an alias created by passing it to a function via blank intent.  In
particular, the domain may not be modified via the array's
\chpl{.domain} method, nor by using the domain query syntax on a
function's formal array argument
(\rsec{Formal_Arguments_of_Generic_Array_Types}).

\begin{rationale}
When multiple arrays are declared using a single domain, modifying the
domain affects all of the arrays.  Allowing an array's domain to be
queried and then modified suggests that the change should only affect
that array.  By requiring the domain to be modified directly, the user
is encouraged to think in terms of the domain distinctly from a
particular array.

In addition, this choice has the beneficial effect that arrays
declared via an anonymous domain have a constant domain.  Constant
domains are considered a common case and have potential compilation
benefits such as eliminating bounds checks.  Therefore making this
convenient syntax support a common, optimizable case seems prudent.
\end{rationale}

\subsection{Subdomains}
\label{Subdomains}
\index{subdomains}
\index{domains!subdomains}

A subdomain is a domain whose indices are a subset of those described
by a \emph{base domain}.  A subdomain is specified by the following
syntax:
\begin{syntax}
subdomain-type:
  `subdomain' ( domain-expression )
\end{syntax}
The ordering of the indices in the subdomain is consistent with the
ordering of the indices in the base domain.

Subdomains are verified during execution even as domains are
reassigned.  The indices in a subdomain are known to be indices in a
domain, allowing for fast bounds-checking.

\subsection{Predefined Functions and Methods on Domains}
\index{domains!predefined functions}

There is an expectation that this list of predefined functions and
methods will grow.

\begin{protohead}
def $Domain$.numIndices: dim_type
\end{protohead}
\begin{protobody}
Returns the number of indices in the domain.
\end{protobody}

\begin{protohead}
def $Domain$.member(i: index($Domain$)): bool
\end{protohead}
\begin{protobody}
Returns whether or not index \chpl{i} is a member of the domain's
index set.
\end{protobody}

\begin{protohead}
def $Domain$.order(i: index($Domain$)): dim_type
\end{protohead}
\begin{protobody}
If \chpl{i} is a member of the domain, returns the ordinal value of
\chpl{i} using a total ordering of the domain's indices using 0-based
indexing.  Otherwise, it returns \chpl{(-1):dim_type}.  For arithmetic
domains, this ordering will be based on a row-major ordering of the
indices; for other domains, the ordering may be
implementation-dependent and unstable as elements are added and
removed from the domain.
\end{protobody}


\subsubsection{Predefined Functions and Methods on Arithmetic Domains}

We expect that this list of predefined functions and methods will
grow.

\begin{protohead}
def $Domain$.rank param
\end{protohead}
\begin{protobody}
Returns the rank of the domain.
\end{protobody}

\begin{protohead}
def $Domain$.dim(d: int): range
\end{protohead}
\begin{protobody}
Returns the range of indices described by dimension \chpl{d} of the
domain.
\end{protobody}

\begin{example}
In the code
\begin{chapel}
for i in D.dim(1) do
  for j in D.dim(2) do
    writeln(A(i,j));
\end{chapel}
domain \chpl{D} is iterated over by two nested loops.  The first
dimension of \chpl{D} is iterated over in the outer loop.  The second
dimension is iterated over in the inner loop.
\end{example}

% BLC: ``integral'' isn't really correct in the two 1D cases below,
% however, we don't really seem to have a user-level name for the
% per-dimension index type in the language that I can see.

\begin{protohead}
def $Domain$.low: $integral$        // for 1D domains
def $Domain$.low: index($Domain$)   // for multidimensional domains
\end{protohead}
\begin{protobody}
Returns the low index of the domain as a scalar value for 1D domains
and as an index value for a multidimensional domain.
\end{protobody}

\begin{protohead}
def $Domain$.high: $integral$        // for 1D domains
def $Domain$.high: index($Domain$)   // for multidimensional domains
\end{protohead}
\begin{protobody}
Returns the high index of the domain as a scalar value for 1D domains
and as an index value for a multidimensional domain.
\end{protobody}

\begin{protohead}
def $Domain$.position(i: index($Domain$)): rank*dim_type
\end{protohead}
\begin{protobody}
Returns a tuple holding the order of index i in each range defining
the domain.
\end{protobody}


\subsection{Predefined Functions and Methods on Arrays}
\index{arrays!predefined functions}

There is an expectation that this list of predefined functions and
methods will grow.

\begin{protohead}
def $Array$.eltType type
\end{protohead}
\begin{protobody}
Returns the element type of the array.
\end{protobody}

\begin{protohead}
def $Array$.rank param
\end{protohead}
\begin{protobody}
Returns the rank of the array.
\end{protobody}

\begin{protohead}
def $Array$.domain: this.domain
\end{protohead}
\begin{protobody}
Returns the domain of the given array.  This domain is constant,
implying that the domain cannot be resized by assigning to its domain
field, only by modifying the domain directly.
\end{protobody}

\begin{protohead}
def $Array$.numElements: this.domain.dim_type
\end{protohead}
\begin{protobody}
Returns the number of elements in the array.
\end{protobody}

\begin{protohead}
def reshape(A: $Array$, D: $Domain$): $Array$
\end{protohead}
\begin{protobody}
Returns a copy of the array containing the same values but in the
shape of the new domain.  The number of indices in the domain must
equal the number of elements in the array.  The elements of the array
are copied into the new array using the default iteration orders over
both arrays.
\end{protobody}
