\sekshun{Expressions}
\label{Expressions}

This section defines expressions in Chapel.  Forall expressions are
described in~\rsec{Forall_Expressions}.

The syntax for an expression is given by:
\begin{syntax}
expression:
  literal-expression
  variable-expression
  enum-constant-expression
  member-access-expression
  call-expression
  query-expression
  cast-expression
  lvalue-expression
  parenthesized-expression
  unary-expression
  binary-expression
  let-expression
  if-expression
  for-expression
  parallel-expression
  reduce-expression
  scan-expression
  module-access-expression
  tuple-expression
  tuple-expand-expression
  locale-access-expression
\end{syntax}

The expressions that create and limit
parallelism, \sntx{parallel-expression}, are discussed
in~\rsec{Task_Parallelism_and_Synchronization}
and~\rsec{Data_Parallelism}.  Reductions and
scans, \sntx{reduce-expression} and \sntx{scan-expression}, are
defined in~\rsec{Reductions_and_Scans}.  Module access
expressions, \sntx{module-access-expression}, are defined
in~\rsec{Explicit_Naming}.  Tuple
expressions, \sntx{tuple-expression}, are defined
in~\rsec{Tuple_Values}.  Tuple expand
expressions, \sntx{tuple-expand-expression}, are defined
in~\rsec{Tuple_Expansion}.  Locale access
expressions, \sntx{locale-access-expression}, are defined
in~\rsec{Querying_the_Locale_of_a_Variable}.

\subsection{Literal Expressions}
\label{Literal_Expressions}

A literal value for any of the built-in
types~(\rsec{Primitive_Type_Literals}) is a literal expression.
Literal expressions are given by the following syntax:
\begin{syntax}
literal-expression:
  bool-literal
  integer-literal
  real-literal
  imaginary-literal
  string-literal
  range-literal
\end{syntax}

\subsection{Variable Expressions}
\label{Variable_Expressions}

A use of a variable, constant, parameter, or formal argument, is
itself an expression.  The syntax of a variable expression is given
by:
\begin{syntax}
variable-expression:
  identifier
\end{syntax}

\subsection{Enumeration Constant Expression}
\label{Enumeration_Constant_Expression}

A use of an enumeration constant is itself an expression.  Such a
constant must be preceded by the enumeration type name.  The syntax of
an enumeration constant expression is given by:
\begin{syntax}
enum-constant-expression:
  enum-type . identifier
\end{syntax}

\begin{example}
For an example of using enumeration constants,
see~\rsec{Enumerated_Types}.
\end{example}

\subsection{Parenthesized Expressions}
\label{Parenthesized_Expressions}

A \sntx{parenthesized-expression} is an expression that is delimited
by parentheses as given by:
\begin{syntax}
parenthesized-expression:
  ( expression )
\end{syntax}
Such an expression evaluates to the expression.  The parentheses is
ignored and has only syntactic effect.

\subsection{Call Expressions}
\label{Call_Expressions}
\index{function calls}

The syntax to call a function is given by:
\begin{syntax}
call-expression:
  expression ( named-expression-list )
  expression [ named-expression-list ]
  parenthesesless-function-identifier

named-expression-list:
  named-expression
  named-expression , named-expression-list

named-expression:
  expression
  identifier = expression

parenthesesless-function-identifier:
  identifier
\end{syntax}

A \sntx{call-expression} is resolved to a particular function
according to the algorithm for function resolution described
in~\rsec{Function_Resolution}.

Functions can be called using either parentheses or brackets.  The
only difference in the call has to do with promotion and is discussed
in~\rsec{Promotion}.

Functions that are defined without parentheses are called without
parentheses as defined by scope resolution.  Functions without
parentheses are discussed in~\rsec{Functions_without_Parentheses}.

A \sntx{named-expression} is an expression that may be optionally
named.  The optional \sntx{identifier} represents a named actual
argument described in~\rsec{Named_Arguments}.

\subsubsection{Indexing Expressions}
\label{Indexing_Expressions}
\index{indexing}

Indexing into arrays, tuples, and domains shares the same syntax of a
call expression.  Indexing, at its core, is nothing more than a call
to the indexing function defined on these types.

\subsubsection{Member Access Expressions}
\label{Member_Access_Expressions}
\index{member access}

Member access expressions are call expressions to members of classes,
records, or unions.  The syntax for a member access is given by:
\begin{syntax}
member-access-expression:
  expression . identifier
\end{syntax}
The member access may be an access of a field or a function inside a
class, record, or union.

\subsection{The Query Expression}
\label{The_Query_Expression}
\index{?@\chpl{?}}

A query expression is used to query a type or value within a formal
argument type expression.  The syntax of a query expression is given
by:
\begin{syntax}
query-expression:
  ? identifier[OPT]
\end{syntax}
Querying is restricted to querying the type of a formal argument, the
element type of an formal argument that is an array, the domain of a
formal argument that is an array, the size of a primitive type, or a
type or parameter field of a formal argument type.

The identifier can be omitted.  This is useful for ensuring the
genericity of a generic type that defines default values for all of
its generic fields when specifying a formal argument as discussed
in~\rsec{Formal_Arguments_of_Generic_Type}.

\begin{example}
The following code defines a generic function where the type of the
first parameter is queried and stored in the type alias \chpl{t} and
the domain of the second argument is queried and stored in the
variable \chpl{D}:
\begin{chapel}
def foo(x: ?t, y: [?D] t) {
  for i in D do
    y[i] = x;
}
\end{chapel}
This allows a generic specification of a function to assign a
particular value to all elements of an array.  The value and the
elements of the array are constrained to be the same type.  This
function can be rewritten without query expression as follows:
\begin{chapel}
def foo(x, y: [] x.type) {
  for i in y.domain do
    y[i] = x;
}
\end{chapel}
\end{example}

There is an expectation that query expressions will be allowed in more
places in the future.

\subsection{Casts}
\label{Casts}
\index{casts}

A cast is specified with the following syntax:
\begin{syntax}
cast-expression:
  expression : type-specifier
\end{syntax}
The expression is converted to the specified type.  Except for the
casts listed below, casts are restricted to valid explicit
conversions~(\rsec{Explicit_Conversions}).

The following cast has a special meaning and does not correspond to an
explicit conversion:
\begin{itemize}
\item \index{complex!casts from tuples}
  A cast from a 2-tuple to \chpl{complex} converts the 2-tuple into a
  complex where the first component becomes the real part and the
  second component becomes the imaginary part.  The size of the
  complex is determined from the size of the components based on
  implicit conversions.
\end{itemize}

\subsection{LValue Expressions}
\label{lvalue}
\index{lvalue}

An {\em lvalue} is an expression that can be used on the left-hand
side of an assignment statement or on either side of a swap statement,
that can be passed to a formal argument of a function that
has \chpl{out} or \chpl{inout} intent, or that can be returned by a
variable function.  Valid lvalue expressions include the following:
\begin{itemize}
\item
 Variable expressions.
\item
 Member access expressions.
\item
 Call expressions of variable functions.
\item
 Indexing expressions.
\end{itemize}

LValue expressions are given by the following syntax:
\begin{syntax}
lvalue-expression:
  variable-expression
  member-access-expression
  call-expression
\end{syntax}
The syntax is less restrictive than the definition above.  For
example, not all \sntx{call-expression}s are lvalues.

\subsection{Operator Precedence and Associativity}
\label{Operator_Precedence_and_Associativity}
\index{operators!precedence}
\index{operators!associativity}

The following table summarizes the precedence of operators and their
associativity.  Operators listed earlier have higher precedence than
those listed later.
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
{\bf operators} & {\bf associativity} & {\bf use} \\
\hline
\verb@. () []@ & left & member access, function call, index expression \\
\verb@:@ & left & cast\\
\verb@**@ & right & exponentiation \\
\verb@reduce scan@ & left & reduction and scan\\
\verb@! ~@ & right & logical and bitwise negation \\
\verb@* / %@ & left & multiplication, division, and modulus \\
unary \verb@+ -@ & right & positive identity and negation \\
\verb@+ -@ & left & addition and subtraction \\
\verb@<< >>@ & left & shift left and shift right \\
\verb@<= >= < >@ & left & ordered comparison \\
\verb@== !=@ & left & equality comparison \\
\verb@&@ & left & bitwise/logical and \\
\verb@^@ & left & bitwise/logical xor \\
\verb@|@ & left & bitwise/logical or \\
\verb@&&@ & left & short-circuiting logical and \\
\verb@||@ & left & short-circuiting logical or \\
\verb@..@ & left & range construction \\
\verb@in@ & left & forall expression \\
\verb@by #@ & left & striding ranges and domains, counting ranges \\
\verb@if...then...[else]@ & left & conditional expressions \\
\verb@forall...in@ & left & parallel iteration expressions \\
\verb@for...in@ & left & serial iteration expressions \\
\verb@,@ & left & comma separated expressions \\
\hline
\end{tabular}
\end{center}

\begin{rationale}
In general, our operator precedence is based on that of the C family
of languages including C++, Java, Perl, and C\#.  We comment on a few
of the differences and unique factors here.

We find that there is tension between the relative precedence of
exponentiation, unary minus/plus, and casts.  The following three
expressions show our intuition for how these expressions should be
parenthesized.

\begin{center}
\begin{tabular}{lcl}
\chpl{-2**4} & wants & \chpl{-(2**4)} \\
\chpl{-2:uint} & wants & \chpl{(-2):uint} \\
\chpl{2:uint**4:uint} & wants & \chpl{(2:uint)**(4:uint)} \\
\end{tabular}
\end{center}

Trying to support all three of these cases results in a
circularity---exponentiation wants precedence over unary minus, unary
minus wants precedence over casts, and casts want precedence over
exponentiation.  We chose to break the circularity by making unary
minus have a lower precedence.  This means that for the second case
above:


\begin{center}
\begin{tabular}{lcl}
\chpl{-2:uint} & requires & \chpl{(-2):uint} \\
\end{tabular}
\end{center}

We also chose to depart from the C family of languages by making unary
plus/minus have lower precedence than binary multiplication, division,
and modulus as in Fortran.  We have found very few cases that
distinguish between these cases.  An interesting one is:

\begin{center}
\begin{tabular}{l}
\chpl{const minint = min(int(32));}\\
\chpl{...-minint/2...}
\end{tabular}
\end{center}

Intuitively, this should result in a positive value, yet C's
precedence rules results in a negative value due to asymmetry in
modern integer representations.  If we learn of cases that argue in
favor of the C approach, we would likely reverse this decision in
order to more closely match C.

We were tempted to diverge from the C precedence rules for the binary
bitwise operators to make them bind less tightly than comparisons.
This would allow us to interpret:

\begin{center}
\begin{tabular}{lcl}
\chpl{a | b == 0} & as & \chpl{(a | b) == 0} \\
\end{tabular}
\end{center}

However, given that no other popular modern language has made this
change, we felt it unwise to stray from the pack.  The typical
rationale for the C ordering is to allow these operators to be used as
non-short-circuiting logical operations.

One final area of note is the precedence of reductions.  Two common
cases tend to argue for making reductions very low or very high in the
precedence table:

\begin{center}
\begin{tabular}{lcl}
\chpl{max reduce A - min reduce A} & wants & \chpl{(max reduce A) - (min reduce A)} \\
\chpl{max reduce A * B} & wants & \chpl{max reduce (A * B)} \\
\end{tabular}
\end{center}

The first statement would require reductions to have a higher
precedence than the arithmetic operators while the second would
require them to be lower.  We opted to make reductions have high
precedence due to the argument that they tend to resemble unary
operators.  Thus, to support our intuition:

\begin{center}
\begin{tabular}{lcl}
\chpl{max reduce A * B} & requires & \chpl{max reduce (A * B)} \\
\end{tabular}
\end{center}

This choice also has the (arguably positive) effect of making the
unparenthesized version of this statement result in an aggregate value
if A and B are both aggregates---the reduction of A results in a
scalar which promotes when being multiplied by B, resulting in an
aggregate.  Our intuition is that users who forget the parenthesis
will learn of their error at compilation time because the resulting
expression is not a scalar as expected.

\end{rationale}

\subsection{Operator Expressions}
\label{Binary_Expressions}
\label{Unary_Expressions}

The application of operators to expressions is itself an expression.
The syntax of a unary expression is given by:
\begin{syntax}
unary-expression:
  unary-operator expression

unary-operator: one of
  + - ~ !
\end{syntax}

The syntax of a binary expression is given by:
\begin{syntax}
binary-expression:
  expression binary-operator expression

binary-operator: one of
  + - * / % ** & | ^ << >> && || == != <= >= < > `by' #
\end{syntax}

The operators are defined in subsequent sections.

\subsection{Arithmetic Operators}
\label{Arithmetic_Operators}
\index{operators!arithmetic}

This section describes the predefined arithmetic operators.  These
operators can be redefined over different types using operator
overloading~(\rsec{Function_Overloading}).

All integral arithmetic operators are implemented over integral types
of size 32 and 64 bits only.  For example, adding two 8-bit integers
is done by first converting them to 32-bit integers and then adding
the 32-bit integers.  The result is a 32-bit integer.

\subsubsection{Unary Plus Operators}
\label{Unary_Plus_Operators}
\index{+ (unary)@\chpl{+} (unary)}

The unary plus operators are predefined as follows:
\begin{chapel}
def +(a: int(32)): int(32)
def +(a: int(64)): int(64)
def +(a: uint(32)): uint(32)
def +(a: uint(64)): uint(64)
def +(a: real(32)): real(32)
def +(a: real(64)): real(64)
def +(a: imag(32)): imag(32)
def +(a: imag(64)): imag(64)
def +(a: complex(32)): complex(32)
def +(a: complex(64)): complex(64)
def +(a: complex(128)): complex(128)
\end{chapel}
For each of these definitions, the result is the value of the operand.

\subsubsection{Unary Minus Operators}
\label{Unary_Minus_Operators}
\index{- (unary)@\chpl{-} (unary)}

The unary minus operators are predefined as follows:
\begin{chapel}
def -(a: int(32)): int(32)
def -(a: int(64)): int(64)
def -(a: uint(64))
def -(a: real(32)): real(32)
def -(a: real(64)): real(64)
def -(a: imag(32)): imag(32)
def -(a: imag(64)): imag(64)
def -(a: complex(32)): complex(32)
def -(a: complex(64)): complex(64)
def -(a: complex(128)): complex(128)
\end{chapel}
For each of these definitions that return a value, the result is the
negation of the value of the operand.  For integral types, this
corresponds to subtracting the value from zero.  For real and
imaginary types, this corresponds to inverting the sign.  For complex
types, this corresponds to inverting the signs of both the real and
imaginary parts.

It is an error to try to negate a value of type \chpl{uint(64)}.  Note
that negating a value of type \chpl{uint(32)} first converts the type
to \chpl{int(64)} using an implicit conversion.

\subsubsection{Addition Operators}
\label{Addition_Operators}
\index{+@\chpl{+}}

The addition operators are predefined as follows:
\begin{chapel}
def +(a: int(32), b: int(32)): int(32)
def +(a: int(64), b: int(64)): int(64)
def +(a: uint(32), b: uint(32)): uint(32)
def +(a: uint(64), b: uint(64)): uint(64)
def +(a: uint(64), b: int(64))
def +(a: int(64), b: uint(64))

def +(a: real(32), b: real(32)): real(32)
def +(a: real(64), b: real(64)): real(64)

def +(a: imag(32), b: imag(32)): imag(32)
def +(a: imag(64), b: imag(64)): imag(64)

def +(a: complex(64), b: complex(64)): complex(64)
def +(a: complex(128), b: complex(128)): complex(128)

def +(a: real(32), b: imag(32)): complex(64)
def +(a: imag(32), b: real(32)): complex(64)
def +(a: real(64), b: imag(64)): complex(128)
def +(a: imag(64), b: real(64)): complex(128)

def +(a: real(32), b: complex(64)): complex(64)
def +(a: complex(64), b: real(32)): complex(64)
def +(a: real(64), b: complex(128)): complex(128)
def +(a: complex(128), b: real(64)): complex(128)

def +(a: imag(32), b: complex(64)): complex(64)
def +(a: complex(64), b: imag(32)): complex(64)
def +(a: imag(64), b: complex(128)): complex(128)
def +(a: complex(128), b: imag(64)): complex(128)
\end{chapel}
For each of these definitions that return a value, the result is the
sum of the two operands.

It is a compile-time error to add a value of type \chpl{uint(64)} and
a value of type \chpl{int(64)}.

Addition over a value of real type and a value of imaginary type
produces a value of complex type.  Addition of values of complex type
and either real or imaginary types also produces a value of complex
type.

\subsubsection{Subtraction Operators}
\label{Subtraction_Operators}
\index{-@\chpl{-}}

The subtraction operators are predefined as follows:
\begin{chapel}
def -(a: int(32), b: int(32)): int(32)
def -(a: int(64), b: int(64)): int(64)
def -(a: uint(32), b: uint(32)): uint(32)
def -(a: uint(64), b: uint(64)): uint(64)
def -(a: uint(64), b: int(64))
def -(a: int(64), b: uint(64))

def -(a: real(32), b: real(32)): real(32)
def -(a: real(64), b: real(64)): real(64)

def -(a: imag(32), b: imag(32)): imag(32)
def -(a: imag(64), b: imag(64)): imag(64)

def -(a: complex(64), b: complex(64)): complex(64)
def -(a: complex(128), b: complex(128)): complex(128)

def -(a: real(32), b: imag(32)): complex(64)
def -(a: imag(32), b: real(32)): complex(64)
def -(a: real(64), b: imag(64)): complex(128)
def -(a: imag(64), b: real(64)): complex(128)

def -(a: real(32), b: complex(64)): complex(64)
def -(a: complex(64), b: real(32)): complex(64)
def -(a: real(64), b: complex(128)): complex(128)
def -(a: complex(128), b: real(64)): complex(128)

def -(a: imag(32), b: complex(64)): complex(64)
def -(a: complex(64), b: imag(32)): complex(64)
def -(a: imag(64), b: complex(128)): complex(128)
def -(a: complex(128), b: imag(64)): complex(128)
\end{chapel}
For each of these definitions that return a value, the result is the
value obtained by subtracting the second operand from the first
operand.

It is a compile-time error to subtract a value of type \chpl{uint(64)}
from a value of type \chpl{int(64)}, and vice versa.

Subtraction of a value of real type from a value of imaginary type,
and vice versa, produces a value of complex type.  Subtraction of
values of complex type from either real or imaginary types, and vice
versa, also produces a value of complex type.

\subsubsection{Multiplication Operators}
\label{Multiplication_Operators}
\index{*@\chpl{*}}

The multiplication operators are predefined as follows:
\begin{chapel}
def *(a: int(32), b: int(32)): int(32)
def *(a: int(64), b: int(64)): int(64)
def *(a: uint(32), b: uint(32)): uint(32)
def *(a: uint(64), b: uint(64)): uint(64)
def *(a: uint(64), b: int(64))
def *(a: int(64), b: uint(64))

def *(a: real(32), b: real(32)): real(32)
def *(a: real(64), b: real(64)): real(64)

def *(a: imag(32), b: imag(32)): real(32)
def *(a: imag(64), b: imag(64)): real(64)

def *(a: complex(64), b: complex(64)): complex(64)
def *(a: complex(128), b: complex(128)): complex(128)

def *(a: real(32), b: imag(32)): imag(32)
def *(a: imag(32), b: real(32)): imag(32)
def *(a: real(64), b: imag(64)): imag(64)
def *(a: imag(64), b: real(64)): imag(64)

def *(a: real(32), b: complex(64)): complex(64)
def *(a: complex(64), b: real(32)): complex(64)
def *(a: real(64), b: complex(128)): complex(128)
def *(a: complex(128), b: real(64)): complex(128)

def *(a: imag(32), b: complex(64)): complex(64)
def *(a: complex(64), b: imag(32)): complex(64)
def *(a: imag(64), b: complex(128)): complex(128)
def *(a: complex(128), b: imag(64)): complex(128)
\end{chapel}
For each of these definitions that return a value, the result is the
product of the two operands.

It is a compile-time error to multiply a value of type \chpl{uint(64)} and
a value of type \chpl{int(64)}.

Multiplication of values of imaginary type produces a value of real
type.  Multiplication over a value of real type and a value of
imaginary type produces a value of imaginary type.  Multiplication of
values of complex type and either real or imaginary types produces a
value of complex type.

\subsubsection{Division Operators}
\label{Division_Operators}
\index{/@\chpl{/}}

The division operators are predefined as follows:
\begin{chapel}
def /(a: int(32), b: int(32)): int(32)
def /(a: int(64), b: int(64)): int(64)
def /(a: uint(32), b: uint(32)): uint(32)
def /(a: uint(64), b: uint(64)): uint(64)
def /(a: uint(64), b: int(64))
def /(a: int(64), b: uint(64))

def /(a: real(32), b: real(32)): real(32)
def /(a: real(64), b: real(64)): real(64)

def /(a: imag(32), b: imag(32)): real(32)
def /(a: imag(64), b: imag(64)): real(64)

def /(a: complex(64), b: complex(64)): complex(64)
def /(a: complex(128), b: complex(128)): complex(128)

def /(a: real(32), b: imag(32)): imag(32)
def /(a: imag(32), b: real(32)): imag(32)
def /(a: real(64), b: imag(64)): imag(64)
def /(a: imag(64), b: real(64)): imag(64)

def /(a: real(32), b: complex(64)): complex(64)
def /(a: complex(64), b: real(32)): complex(64)
def /(a: real(64), b: complex(128)): complex(128)
def /(a: complex(128), b: real(64)): complex(128)

def /(a: imag(32), b: complex(64)): complex(64)
def /(a: complex(64), b: imag(32)): complex(64)
def /(a: imag(64), b: complex(128)): complex(128)
def /(a: complex(128), b: imag(64)): complex(128)
\end{chapel}
For each of these definitions that return a value, the result is the
quotient of the two operands.

It is a compile-time error to divide a value of type \chpl{uint(64)} by
a value of type \chpl{int(64)}, and vice versa.

Division of values of imaginary type produces a value of real type.
Division over a value of real type and a value of imaginary type
produces a value of imaginary type.  Division of values of complex
type and either real or imaginary types produces a value of complex
type.

\subsubsection{Modulus Operators}
\label{Modulus_Operators}
\index{\%@\chpl{\%}}

The modulus operators are predefined as follows:
\begin{chapel}
def %(a: int(32), b: int(32)): int(32)
def %(a: int(64), b: int(64)): int(64)
def %(a: uint(32), b: uint(32)): uint(32)
def %(a: uint(64), b: uint(64)): uint(64)
def %(a: uint(64), b: int(64))
def %(a: int(64), b: uint(64))
\end{chapel}
For each of these definitions that return a value, the result is the
remainder when the first operand is divided by the second operand.

It is a compile-time error to take the remainder of a value of
type \chpl{uint(64)} and a value of type \chpl{int(64)}, and vice
versa.

There is an expectation that the predefined modulus operators will be
extended to handle real, imaginary, and complex types in the future.

\subsubsection{Exponentiation Operators}
\label{Exponentiation_Operators}
\index{**@\chpl{**}}

The exponentiation operators are predefined as follows:
\begin{chapel}
def **(a: int(32), b: int(32)): int(32)
def **(a: int(64), b: int(64)): int(64)
def **(a: uint(32), b: uint(32)): uint(32)
def **(a: uint(64), b: uint(64)): uint(64)
def **(a: uint(64), b: int(64))
def **(a: int(64), b: uint(64))

def **(a: real(32), b: real(32)): real(32)
def **(a: real(64), b: real(64)): real(64)
\end{chapel}
For each of these definitions that return a value, the result is the
value of the first operand raised to the power of the second operand.

It is a compile-time error to take the exponent of a value of
type \chpl{uint(64)} by a value of type \chpl{int(64)}, and vice
versa.

There is an expectation that the predefined exponentiation operators
will be extended to handle imaginary and complex types in the future.

\subsection{Bitwise Operators}
\label{Bitwise_Operators}
\index{operators!bitwise}

This section describes the predefined bitwise operators.  These
operators can be redefined over different types using operator
overloading~(\rsec{Function_Overloading}).

\subsubsection{Bitwise Complement Operators}
\label{Bitwise_Complement_Operators}
\index{\~@\chpl{\~}}

The bitwise complement operators are predefined as follows:
\begin{chapel}
def ~(a: bool): bool
def ~(a: int(32)): int(32)
def ~(a: int(64)): int(64)
def ~(a: uint(32)): uint(32)
def ~(a: uint(64)): uint(64)
\end{chapel}
For each of these definitions, the result is the bitwise complement of
the operand.

\subsubsection{Bitwise And Operators}
\label{Bitwise_And_Operators}
\index{&@\chpl{&}}

The bitwise and operators are predefined as follows:
\begin{chapel}
def &(a: bool, b: bool): bool
def &(a: int(32), b: int(32)): int(32)
def &(a: int(64), b: int(64)): int(64)
def &(a: uint(32), b: uint(32)): uint(32)
def &(a: uint(64), b: uint(64)): uint(64)
def &(a: uint(64), b: int(64))
def &(a: int(64), b: uint(64))
\end{chapel}
For each of these definitions that return a value, the result is
computed by applying the logical and operation to the bits of the
operands.

It is a compile-time error to apply the bitwise and operator to a
value of type \chpl{uint(64)} and a value of type \chpl{int(64)}, and
vice versa.

\subsubsection{Bitwise Or Operators}
\label{Bitwise_Or_Operators}
\index{|@\chpl{|}}

The bitwise or operators are predefined as follows:
\begin{chapel}
def |(a: bool, b: bool): bool
def |(a: int(32), b: int(32)): int(32)
def |(a: int(64), b: int(64)): int(64)
def |(a: uint(32), b: uint(32)): uint(32)
def |(a: uint(64), b: uint(64)): uint(64)
def |(a: uint(64), b: int(64))
def |(a: int(64), b: uint(64))
\end{chapel}
For each of these definitions that return a value, the result is
computed by applying the logical or operation to the bits of the
operands.

It is a compile-time error to apply the bitwise or operator to a value
of type \chpl{uint(64)} and a value of type \chpl{int(64)}, and vice
versa.

\subsubsection{Bitwise Xor Operators}
\label{Bitwise_Xor_Operators}
\index{^@\chpl{^}}

The bitwise xor operators are predefined as follows:
\begin{chapel}
def ^(a: bool, b: bool): bool
def ^(a: int(32), b: int(32)): int(32)
def ^(a: int(64), b: int(64)): int(64)
def ^(a: uint(32), b: uint(32)): uint(32)
def ^(a: uint(64), b: uint(64)): uint(64)
def ^(a: uint(64), b: int(64))
def ^(a: int(64), b: uint(64))
\end{chapel}
For each of these definitions that return a value, the result is
computed by applying the XOR operation to the bits of the operands.

It is a compile-time error to apply the bitwise xor operator to a
value of type \chpl{uint(64)} and a value of type \chpl{int(64)}, and
vice versa.

\subsection{Shift Operators}
\label{Shift_Operators}
\index{<<@\chpl{<<}}
\index{>>@\chpl{>>}}

This section describes the predefined shift operators.  These
operators can be redefined over different types using operator
overloading~(\rsec{Function_Overloading}).

The shift operators are predefined as follows:
\begin{chapel}
def <<(a: int(32), b): int(32)
def >>(a: int(32), b): int(32)
def <<(a: int(64), b): int(64)
def >>(a: int(64), b): int(64)
def <<(a: uint(32), b): uint(32)
def >>(a: uint(32), b): uint(32)
def <<(a: uint(64), b): uint(64)
def >>(a: uint(64), b): uint(64)
\end{chapel}
The type of the second actual argument must be any integral type.

The \chpl{<<} operator shifts the bits of \chpl{a} left by the
integer \chpl{b}.  The new low-order bits are set to zero.

The \chpl{>>} operator shifts the bits of \chpl{a} right by the
integer \chpl{b}.  When \chpl{a} is negative, the new high-order bits
are set to one; otherwise the new high-order bits are set to zero.

The value of \chpl{b} must be non-negative.

\subsection{Logical Operators}
\label{Logical_Operators}
\index{operators!logical}

This section describes the predefined logical operators.  These
operators can be redefined over different types using operator
overloading~(\rsec{Function_Overloading}).

\subsubsection{The Logical Negation Operator}
\label{Logical_Negation_Operators}
\index{!@\chpl{!}}

The logical negation operator is predefined as follows:
\begin{chapel}
def !(a: bool): bool
\end{chapel}
The result is the logical negation of the operand.

\subsubsection{The Logical And Operator}
\label{Logical_And_Operators}
\index{&&@\chpl{&&}}

The logical and operator is predefined over bool type.  It returns
true if both operands evaluate to true; otherwise it returns false.
If the first operand evaluates to false, the second operand is not
evaluated and the result is false.

The logical and operator over expressions \chpl{a} and \chpl{b} given
by
\begin{chapel}
a && b
\end{chapel}
is evaluated as the expression
\begin{chapel}
if isTrue(a) then isTrue(b) else false
\end{chapel}

The function \chpl{isTrue} is predefined over bool type as follows:
\begin{chapel}
def isTrue(a:bool) return a;
\end{chapel}
Overloading the logical and operator over other types is accomplished
by overloading the \chpl{isTrue} function over other types.

\subsubsection{The Logical Or Operator}
\label{Logical_Or_Operators}
\index{||@\chpl{||}}

The logical or operator is predefined over bool type.  It returns
true if either operand evaluate to true; otherwise it returns false.
If the first operand evaluates to true, the second operand is not
evaluated and the result is true.

The logical or operator over expressions \chpl{a} and \chpl{b} given
by
\begin{chapel}
a || b
\end{chapel}
is evaluated as the expression
\begin{chapel}
if isTrue(a) then true else isTrue(b)
\end{chapel}

The function \chpl{isTrue} is predefined over bool type as described
in~\rsec{Logical_And_Operators}.  Overloading the logical or operator
over other types is accomplished by overloading the \chpl{isTrue}
function over other types.

\subsection{Relational Operators}
\label{Relational_Operators}
\index{operators!relational}

This section describes the predefined relational operators.  These
operators can be redefined over different types using operator
overloading~(\rsec{Function_Overloading}).

\subsubsection{Ordered Comparison Operators}
\label{Ordered_Comparison_Operators}

\index{<@\chpl{<}}
The ``less than'' comparison operators are predefined over numeric
types as follows:
\begin{chapel}
def <(a: int(32), b: int(32)): bool
def <(a: int(64), b: int(64)): bool
def <(a: uint(32), b: uint(32)): bool
def <(a: uint(64), b: uint(64)): bool
def <(a: real(32), b: real(32)): bool
def <(a: real(64), b: real(64)): bool
def <(a: imag(32), b: imag(32)): bool
def <(a: imag(64), b: imag(64)): bool
\end{chapel}
The result of \chpl{a < b} is true if \chpl{a} is less than \chpl{b};
otherwise the result is false.

\index{>@\chpl{>}}
The ``greater than'' comparison operators are predefined over numeric
types as follows:
\begin{chapel}
def >(a: int(32), b: int(32)): bool
def >(a: int(64), b: int(64)): bool
def >(a: uint(32), b: uint(32)): bool
def >(a: uint(64), b: uint(64)): bool
def >(a: real(32), b: real(32)): bool
def >(a: real(64), b: real(64)): bool
def >(a: imag(32), b: imag(32)): bool
def >(a: imag(64), b: imag(64)): bool
\end{chapel}
The result of \chpl{a > b} is true if \chpl{a} is greater
than \chpl{b}; otherwise the result is false.

\index{<=@\chpl{<=}}
The ``less than or equal to'' comparison operators are predefined over
numeric types as follows:
\begin{chapel}
def <=(a: int(32), b: int(32)): bool
def <=(a: int(64), b: int(64)): bool
def <=(a: uint(32), b: uint(32)): bool
def <=(a: uint(64), b: uint(64)): bool
def <=(a: real(32), b: real(32)): bool
def <=(a: real(64), b: real(64)): bool
def <=(a: imag(32), b: imag(32)): bool
def <=(a: imag(64), b: imag(64)): bool
\end{chapel}
The result of \chpl{a <= b} is true if \chpl{a} is less than or equal
to \chpl{b}; otherwise the result is false.

\index{>=@\chpl{>=}}
The ``greater than or equal to'' comparison operators are predefined
over numeric types as follows:
\begin{chapel}
def >=(a: int(32), b: int(32)): bool
def >=(a: int(64), b: int(64)): bool
def >=(a: uint(32), b: uint(32)): bool
def >=(a: uint(64), b: uint(64)): bool
def >=(a: real(32), b: real(32)): bool
def >=(a: real(64), b: real(64)): bool
def >=(a: imag(32), b: imag(32)): bool
def >=(a: imag(64), b: imag(64)): bool
\end{chapel}
The result of \chpl{a >= b} is true if \chpl{a} is greater than or
equal to \chpl{b}; otherwise the result is false.

The ordered comparison operators are predefined over strings as follows:
\begin{chapel}
def <(a: string, b: string): bool
def >(a: string, b: string): bool
def <=(a: string, b: string): bool
def >=(a: string, b: string): bool
\end{chapel}
Comparisons between strings are defined based on the ordering of the
character set used to represent the string, which is applied
elementwise to the string's characters in order.


\subsubsection{Equality Comparison Operators}
\label{Equality_Comparison_Operators}
\index{==@\chpl{==}}
\index{!=@\chpl{!=}}

The equality comparison operators are predefined over bool and the
numeric types as follows:
\begin{chapel}
def ==(a: int(32), b: int(32)): bool
def ==(a: int(64), b: int(64)): bool
def ==(a: uint(32), b: uint(32)): bool
def ==(a: uint(64), b: uint(64)): bool
def ==(a: real(32), b: real(32)): bool
def ==(a: real(64), b: real(64)): bool
def ==(a: imag(32), b: imag(32)): bool
def ==(a: imag(64), b: imag(64)): bool
def ==(a: complex(64), b: complex(64)): bool
def ==(a: complex(128), b: complex(128)): bool
\end{chapel}
The result of \chpl{a == b} is true if \chpl{a} and \chpl{b} contain
the same value; otherwise the result is false.  The result of \chpl{a
\!= b} is equivalent to \chpl{\!(a == b)}.

The equality comparison operators are predefined over classes as
follows:
\begin{chapel}
def ==(a: object, b: object): bool
def !=(a: object, b: object): bool
\end{chapel}
The result of \chpl{a == b} is true if \chpl{a} and \chpl{b} reference
the same storage location; otherwise the result is false.  The result
of \chpl{a \!= b} is equivalent to \chpl{\!(a == b)}.

Default equality comparison operators are generated for records if the
user does not define them.  These operators are described
in~\rsec{Record_Comparison_Operators}.

The equality comparison operators are predefined over strings as
follows:
\begin{chapel}
def ==(a: string, b: string): bool
def !=(a: string, b: string): bool
\end{chapel}
The result of \chpl{a == b} is true if the sequence of characters
in \chpl{a} matches exactly the sequence of characters in \chpl{b};
otherwise the result is false.  The result of \chpl{a \!= b} is
equivalent to \chpl{\!(a == b)}.

\subsection{Miscellaneous Operators}
\label{Miscellaneous_Operators}

This section describes several miscellaneous operators.  These
operators can be redefined over different types using operator
overloading~(\rsec{Function_Overloading}).

\subsubsection{The String Concatenation Operator}
\label{The_String_Concatenation_Operator}
\index{+@\chpl{+}}

The string concatenation operator \chpl{+} is predefined over numeric, boolean,
and enumerated types with strings. It casts its operands to string type and
concatenation of them together.

\begin{example}
The code
\begin{chapel}
"result: "+i
\end{chapel}
where \chpl{i} is an integer appends the value of \chpl{i} to the
string literal.  If \chpl{i} is \chpl{3}, then the resulting string
would be \chpl{"result: 3"}.
\end{example}

\subsubsection{The Arithmetic Domain By Operator}
\label{The_Arithmetic_Domain_By_Operator}
\index{by@\chpl{by}}

The operator \chpl{by} is predefined on arithmetic domains.  It is
described in~\rsec{Strided_Arithmetic_Domains_and_Arrays}.

\subsubsection{The Range By Operator}
\label{The_Range_By_Operator}
\index{by@\chpl{by}}

The operator \chpl{by} is predefined on ranges.  It is
described in~\rsec{Strided_Ranges}.

\subsubsection{The Range Count Operator}
\label{The_Range_Count_Operator}
\index{#@\chpl{#}}

The operator \chpl{#} is predefined on ranges. It is described
in ~\rsec{Count_Operator}.

\subsection{Let Expressions}
\label{Let_Expressions}
\index{let@\chpl{let}}

A let expression allows variables to be declared at the expression
level and used within that expression.  The syntax of a let expression
is given by:
\begin{syntax}
let-expression:
  `let' variable-declaration-list `in' expression
\end{syntax}
The scope of the variables is the let-expression.
\begin{example}
Let expressions are useful for defining variables in the context of
expression.  In the code
\begin{chapel}
  let x: real = a*b, y = x*x in 1/y
\end{chapel}
the value determined by \chpl{a*b} is computed and converted to type
real if it is not already a real.  The square of the real is then
stored in \chpl{y} and the result of the expression is the reciprocal
of that value.
\end{example}

\subsection{Conditional Expressions}
\label{Conditional_Expressions}
\index{conditional!expression}
\index{if@\chpl{if}}
\index{then@\chpl{then}}
\index{else@\chpl{else}}

A conditional expression is given by the following syntax:
\begin{syntax}
if-expression:
  `if' expression `then' expression `else' expression
  `if' expression `then' expression
\end{syntax}
The conditional expression is evaluated in two steps.  First, the
expression following the \chpl{if} keyword is evaluated.  Then, if the
expression evaluated to true, the expression following the \chpl{then}
keyword is evaluated and taken to be the value of this expression.
Otherwise, the expression following the \chpl{else} keyword is
evaluated and taken to be the value of this expression.  In both
cases, the unselected expression is not evaluated.

The `else' keyword can be omitted only when the conditional expression
is immediately nested inside a forall expression.  Such an expression
is used to filter predicates as described
in~\rsec{Filtering_Predicates_For} and~\rsec{Filtering_Predicates_Forall}.

\subsection{For Expressions}
\label{For_Expressions}
\index{for@\chpl{for}}

A for expression is given by the following syntax:
\begin{syntax}
for-expression:
  `for' index-expression `in' iterator-expression `do' expression
  `for' iterator-expression `do' expression
\end{syntax}
The for-expression evaluates a for-loop~(\rsec{The_For_Loop}) in the
context of an expression and has the semantics of calling an
iterator~(\rsec{Iterators}) that yields the evaluated expressions on
each iteration.

\subsubsection{Filtering Predicates in For Expressions}
\label{Filtering_Predicates_For}
\index{for expressions!and conditional expressions}

A conditional expression that is immediately enclosed in a for
expression does not require an else-part.  Such a conditional
expression filters the evaluated expressions and only returns an
expression if the condition holds.

\begin{example}
The code
\begin{chapel}
var A = for i in 1..10 do if i % 3 != 0 then i;
\end{chapel}
declares an array A that is initialized to the integers between
1 and 10 that are not divisible by 3.
\end{example}
