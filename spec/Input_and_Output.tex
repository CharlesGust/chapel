\sekshun{Input and Output}
\label{Input_and_Output}
\index{input/output}

Input/output (I/O) facilities in Chapel include
the types \chpl{file} and \chpl{channel},
the constants \chpl{stdin}, \chpl{stdout} and \chpl{stderr},
the functions \chpl{open}, \chpl{close}, \chpl{reader}, \chpl{writer},
\chpl{read} and \chpl{write},
and others.

\index{input/output!file}
\index{input/output!channel}
A \emph{file} in Chapel identifies a file in the underlying operating system.
% TODO: define the typical sequence as "open a file" -> "create a channel"
%
Reads and writes to a file are done via one or more \emph{channels}
associated with the file.
Each channel provides sequential access to its file, optionally
starting at an offset. Channels operate independently,
thus enabling concurrent I/O without contending for locks.
%
Explicit flushing and synchronization operations can be used
to make the data written to a channel available to other channels
and to commit the data to the file device for persistence.

\index{input/output!I/O style}
Reading and writing of Chapel's basic types is regulated by
an applicable \emph{I/O style}.
In particular, the I/O style controls whether binary or text I/O
should be performed. For binary I/O it specifies, for example, byte order
and string encoding. For text I/O it specifies string representation,
the base, field width and precision for numeric types, and so on.
Each channel has an associated I/O style. It applies to
all read/write operations on that channel, except when the program
specifies explicitly an I/O style for a particular read or write.

I/O facilities in Chapel also include the ability to write data
to strings and to define dynamically the output format or actions
to be taken when writing values of a given type.

I/O facilities are presented as follows:

\begin{itemize}

\item the \chpl{file} type and file operations
      \rsec{IO_files}

\item the \chpl{channel} type and channel operations
      \rsec{IO_channels}

\item I/O style details
      \rsec{IO_io_style}

\item the \chpl{stdin}, \chpl{stdout} and \chpl{stderr} channels
      \rsec{IO_std_channels}

\item the supporting data types for I/O
      \rsec{IO_data_types}

\item error handling for I/O functions
      \rsec{IO_error_handling}

\item writing and reading operations and supporting data types
      \rsec{IO_writing_reading}

\end{itemize}


% TODO: MF suggests adding a section with a further example about
% how to use a channel or a file.


\section{Files}
\label{IO_files}


\subsection{The {\em file} Type and Values}
\label{IO_file_type}
\index{input/output!file}
\index{input/output!file!default value}

%REVIEW: vass: in our implementation there is an actual object
% containing state etc.; multiple such objects can represent
% one file. A Chapel 'file' object is a reference to such
% actual object.
% This should be reflected here and/or in the chapter intro.

A value of the \chpl{file} type represents a file in the underlying
operating system in an implementation-defined way. The default value
of the \chpl{file} type does not represent any OS file.

The details of how the OS file is accessed are determined
when opening a file (\rsec{IO_open_file})
or creating its associated channel (\rsec{IO_channel_creation}).


\subsection{Functions for Opening Files}
\label{IO_open_file}
\index{input/output!open, opentmp, openmem}

The following functions are provided for opening a file.
Once a file is open, it is necessary to create associated channel(s)
for reading from and/or writing to the file (\rsec{IO_channel_creation}).
The \chpl{error} argument is explained in \rsec{IO_error_handling}.

\begin{protohead}
proc open(out error:syserr, path:string, mode:iomode, hints:iohints=IOHINT_NONE, style:iostyle = defaultStyle()
          ):file;
proc open(path:string, mode:iomode, hints:iohints=IOHINT_NONE, style:iostyle = defaultStyle()):file;
\end{protohead}
\begin{protobody}
Opens a file specified by $path$, with
the access mode $mode$ (\rsec{IO_iomode_type})
and the hints $hints$ (\rsec{IO_iohints_type}).
The $style$ argument defines the I/O style (\rsec{IO_io_style})
for use by default when creating channels associated with this file
(\rsec{IO_channel_creation}).
\end{protobody}

\begin{protohead}
proc opentmp(out error:syserr, hints:iohints=IOHINT_NONE, style:iostyle = defaultStyle()):file;
proc opentmp(hints:iohints=IOHINT_NONE, style:iostyle = defaultStyle()):file;
\end{protohead}
\begin{protobody}
% TODO: for writing only?
Similar to \chpl{open}, but the created file is temporary:
it is created in an OS-dependent temporary directory (e.g. \chpl{/tmp})
and is deleted upon closing.
\end{protobody}

\begin{protohead}
proc openmem(out error:syserr, style:iostyle = defaultStyle());
proc openmem(style:iostyle = defaultStyle()):file;
\end{protohead}
\begin{protobody}
% TODO: for writing only?
Similar to \chpl{opentmp}, but
the created file is backed up by a buffer in memory, not by a disk.
\end{protobody}


\subsection{Functions for Closing Files}
\label{IO_closing_files}

In order to free the resources allocated for a file or a channel, it
must be closed using one of the following methods:

\index{input/output!close (file)}
\begin{protohead}
proc file.close(out error:syserr);
proc file.close();
\end{protohead}
\begin{protobody}
Close a file.
The \chpl{error} argument is explained in \rsec{IO_error_handling}.
\end{protobody}

%TODO: can one be closed multiple times?
It is an error to perform any I/O operations on a file
that has been closed.
It is an error to close a file when it has channels that
have not been closed.

Closing a file, when completed successfully, also commits
all file data to the disk or other persistent storage,
if applicable.

\begin{future}
In the future we plan to implement reference counting for files
and channels. Each file and channel will be closed automatically
when no references remain to it. For example, if only a local
variable refers to a channel, the channel will be closed
when that variable goes out of scope.
% any more here?
The ability for the program to close a file or a channel
explicitly will remain available.
\end{future}


\subsection{Synchronization of File Data}
\label{IO_file_synchronization}

The following synchronization operation is available.

\index{input/output!fsync}
\begin{protohead}
proc file.fsync(out error:syserr);
proc file.fsync();
\end{protohead}
\begin{protobody}
Commits all file data to the disk or other persistent storage, if
applicable. This ensures that the file data will be available to
applications executing later.
\end{protobody}


\section{Channels}
\label{IO_channels}


\subsection{The {\em channel} Type and Values}
\label{IO_channel_type}
\index{input/output!channel}

The \chpl{channel} type is generic. It has the following arguments,
none of which have defaults:

\begin{itemize}

\item \chpl{writing} is a boolean indicating whether the channels of this type
      support writing (when \chpl{true}) or reading (when \chpl{false}).

\item \chpl{kind} is an enum \chpl{iokind} that allows narrowing
      this channel's I/O style for more efficient binary I/O,
      as described in (\rsec{IO_iokind_type}).

\item \chpl{locking} is a boolean indicating whether it is
      safe to use this channel concurrently (when \chpl{true}).
      Safety is implemented by guarding all channel operations, except
      as indicated, with a channel-specific lock.

\end{itemize}

\index{input/output!channel!default value}
The representation of a \chpl{channel} value is implementation-defined.
The default value of the \chpl{channel} type is not associated
with any file and so cannot be used to perform I/O.


\subsection{Functions for Channel Creation and Manipulation}
\label{IO_channel_creation}

\index{input/output!reader}
\begin{protohead}
proc file.reader(out error:syserr, param kind=iokind.dynamic, param locking=true,
                 start:int(64) = 0, end:int(64) = max(int(64)), hints:iohints = IOHINT_NONE,
                 style:iostyle = this._style): channel(false, kind, locking);
proc file.reader(param kind=iokind.dynamic, param locking=true,
                 start:int(64) = 0, end:int(64) = max(int(64)), hints:iohints = IOHINT_NONE,
                 style:iostyle = this._style): channel(false, kind, locking);
\end{protohead}
\begin{protobody}
Creates a channel for reading from the file.

The arguments are as follows:

\begin{itemize}

\item \chpl{error} is explained in \rsec{IO_error_handling}.

\item \chpl{kind} and \chpl{locking} determine the corresponding parameters of
      the \chpl{channel} type that is returned (see \rsec{IO_channel_type})

\item \chpl{start} and \chpl{end} define the region of the file that
      the channel will read from. The default values for these arguments enable
      the channel to access the entire file.
      A channel will never read beyond its maximum end position.

\item \chpl{hints} provides hints about the I/O that this channel
      will perform (\rsec{IO_iohints_type}).
      If \chpl{hints} is \chpl{IOHINT_NONE}, the hints provided when opening
      the file will be used.

\item \chpl{style} defines this channel's I/O style (\rsec{IO_io_style}).
      If the corresponding actual argument is omitted,
      the I/O style will be set to the style specified when the file
      was opened (\rsec{IO_open_file}).

\end{itemize}

\end{protobody}

\index{input/output!writer}
\begin{protohead}
proc file.writer(out error:syserr, param kind=iokind.dynamic, param locking=true,
                 start:int(64) = 0, end:int(64) = max(int(64)), hints:iohints = IOHINT_NONE,
                 style:iostyle = this._style): channel(true,kind,locking);
proc file.writer(param kind=iokind.dynamic, param locking=true,
                 start:int(64) = 0, end:int(64) = max(int(64)), hints:iohints = IOHINT_NONE,
                 style:iostyle = this._style): channel(true,kind,locking);
\end{protohead}
\begin{protobody}
Creates a channel for writing to the file.

The arguments are the same as for \chpl{file.reader}, except for the following:

\begin{itemize}

\item \chpl{start} and \chpl{end} define the region of the file that
      the channel will write to. The defaults for these arguments enable
      the channel to access the entire file.

      A channel will never write beyond its maximum end position,
      and it will extend the file only as necessary to store data
      written to the channel. In other words, specifying end here
      does not impact the file size; only the section of the file
      that this channel can write to. After all channels to a file
      are closed, that file will have a size equal to the last
      position of any channel.

\end{itemize}

\end{protobody}


\subsection{Functions for Closing Channels}
\label{IO_closing_channels}

In order to free the resources allocated for a file or a channel, it
must be closed using one of the following methods:

\index{input/output!close (channel)}
\begin{protohead}
proc channel.close(out error:syserr);
proc channel.close();
\end{protohead}
\begin{protobody}
Close a channel.
The \chpl{error} argument is explained in \rsec{IO_error_handling}.
\end{protobody}

%TODO: can one be closed multiple times?
It is an error to perform any I/O operations on a channel
that has been closed.
It is an error to close a file when it has channels that
have not been closed.

\begin{future}
In the future we plan to implement reference counting for files
and channels. Each file and channel will be closed automatically
when no references remain to it. For example, if only a local
variable refers to a channel, the channel will be closed
when that variable goes out of scope.
% any more here?
The ability for the program to close a file or a channel
explicitly will remain available.
\end{future}


\subsection{Synchronization of Channel Data}
\label{IO_channel_synchronization}

The following synchronization operation is available.

\index{input/output!flush}
\begin{protohead}
proc channel.flush(out error:syserr);
proc channel.flush();
\end{protohead}
\begin{protobody}
Makes all writes to the channel available to other concurrent views of the
channel's file. These include other channels for the same file and
other applications accessing the file concurrently.
This does not guarantee persistence of the written data, however.
\end{protobody}


\subsection{I/O Style}
\label{IO_io_style}

A channel's I/O style is established upon channel creation
(\rsec{IO_channel_creation}).
It is represented by a value of the \chpl{iostyle} type
(\rsec{IO_iostyle_type}.


\subsection{The {\em stdin}, {\em stdout}, and {\em stderr} Channels}
\label{IO_std_channels}
\index{input/output!stdin, stdout, stderr}

Chapel provides the predefined channels \chpl{stdin}, \chpl{stdout},
and \chpl{stderr} to access the corresponding operating system streams
standard input, standard output, and standard error.

\chpl{stdin} supports reading;
\chpl{stdout} and \chpl{stderr} support writing.
All three channels are safe to use concurrently and
consult their I/O styles at run time to determine the I/O format.


\section{Supporting Data Types}
\label{IO_data_types}

File and channel operations make use of the type presented in this section.


\subsection{The {\em iokind} Type}
\label{IO_iokind_type}
\index{input/output!iokind}

The \chpl{iokind} type is an enum. Its constants are intended
as arguments to the \chpl{channel} type,
where they narrow down the channels' I/O style (\rsec{IO_io_style})
when performing binary I/O of numeric types:

\begin{itemize}

\item \chpl{dynamic} means that each channel's run-time I/O style will
      have full effect.      

\item \chpl{native} forces the endianness that is native
      to the target platform for binary I/O.

\item \chpl{big} forces big-endian binary I/O.

\item \chpl{little} forces little-endian binary I/O.

\end{itemize}

In the case of \chpl{native}, \chpl{big}, or \chpl{little},
the channel's I/O style is consulted at run time for
text or string I/O.


\subsection{The {\em iomode} Type}
\label{IO_iomode_type}
\index{input/output!iomode}

The \chpl{iomode} type is an enum. Its constants are intended
as arguments when opening files, with the following meanings:

\begin{itemize}

\item \chpl{r} - open an existing file for reading.

\item \chpl{rw} - open an existing file for reading and writing.

\item \chpl{cw} - create a new file for writing.
      If the file already exists, its contents are removed
      when the file is opened in this mode.

\item \chpl{cwr} is like \chpl{cw},
      but reading from the file is also allowed.

\end{itemize}


\subsection{The {\em iohints} Type}
\label{IO_iohints_type}
\index{input/output!iohints}

The \chpl{iohints} type is an alias for an integer type.
When passed to functions for opening a file (\rsec{IO_open_file}),
a \chpl{iohints} value is interpreted to be a bit mask obtained
by a bitwise OR of the following constants:

%TODO: describe what these hints could affect.

\begin{itemize}

\item \chpl{IOHINT_NONE} provides no hints.

\item \chpl{IOHINT_CACHED} suggests that the file data is or should be
      cached in memory.

\item \chpl{IOHINT_RANDOM} suggests to expect random access pattern.

\item \chpl{IOHINT_SEQUENTIAL} suggests to expect sequential access pattern.

\end{itemize}

\begin{future}
Other hints are likely to be added in the future.
\end{future}


\subsection{The {\em iostyle} Type}
\label{IO_iostyle_type}
\index{input/output!iostyle}
\index{input/output!I/O style}

The \chpl{iostyle} type is implementation-defined.
Modifications to a copy of an \chpl{iostyle} value (e.g.
obtained upon an assignment or argument passing)
are not reflected in the original.

A channel's I/O style is a value of the \chpl{iostyle} type.
It is set when the channel is created and can be modified later
(\rsec{IO_channel_creation}, \rsec{IO_channel_style_mods}).
It defines how Chapel's basic types should be read or written.
For example, it defines whether binary or text I/O
should be performed, the byte order (big or little endian)
and string format for binary I/O, string delimiters,
numeric base and precision for text I/O, etc.

Methods that examine or modify an \chpl{iostyle} value
are provided for the channel I/O style
(\rsec{IO_channel_style_mods}).

\index{input/output!iostyle!default value}
The default value of the \chpl{iostyle} type does not define
a valid I/O style.
Instead, the result of \chpl{defaultStyle()} should be used where
a default is desired (\rsec{IO_channel_style_mods})

%TODO: we may want the default value to define the default
%I/O style, but this seems to be a low priority.


% Only defaultStyle() will remain in the spec,
% because modifyStyle() has been eliminated.
\label{IO_channel_style_mods}

The following operations provide access to and modification of
a channel's I/O style. Like most other methods on channels,
these operations are guarded with a channel-specific lock
when the channel type's \chpl{locking} parameter is \chpl{true}.

\index{input/output!defaultStyle}
\begin{protohead}
proc defaultStyle():iostyle;
\end{protohead}
\begin{protobody}
The return value defines the default I/O style,
which provides reasonable defaults for most channel I/O operations.
\end{protobody}

\index{input/output!modifyStyle}
\begin{protohead}
proc channel.modifyStyle(f:func(iostyle, iostyle));
\end{protohead}
\begin{protobody}
Modify the channel's I/O style. The argument is
%the new I/O style or
a function that takes the channel's current I/O style and returns
the new I/O style to be set for the channel.
\end{protobody}

\begin{future}
Operations that retrieve or set a channel's I/O style
or modify its individual aspects will also be provided.
\end{future}


\subsection{The {\em syserr} Type}
\label{IO_syserr_type}
\index{input/output!syserr}

The \chpl{syserr} type is an alias for an integer type.
Its values represent success or an error condition of most Chapel I/O
functions, which are accessible as described in \rsec{IO_error_handling}.

The zero value represents success. It can also be obtained as \chpl{ENOERR}.

Non-zero values represent errors. They can be obtained via symbolic
names that are defined in C for \chpl{errno}, for example
\chpl{EEOF}, \chpl{EACCES}, etc.

%TODO: how to get string descriptions of errors?


\section{Error Handling}
\label{IO_error_handling}
\index{input/output!error handling}
\index{input/output!syserr}

Most I/O functions have two versions: with the \chpl{out error:syserr}
argument and without. The version that takes the \chpl{error} argument
returns the success or error code (\rsec{IO_syserr_type}) in that argument.
The version that does not accept \chpl{error} halts with an error message
if an error condition is encountered.

\begin{future}
If exceptions are added to Chapel, the no-\chpl{error} versions
could be changed to throw exceptions instead of halting.
\end{future}

In most cases I/O errors are reported by the function during whose
call those errors occurred. However, in some cases errors are
reported only upon \chpl{file.close} \rsec{IO_closing_files}
or \chpl{file.fsync} \rsec{IO_file_synchronization}.
Therefore, one of these two functions must be invoked to ensure
that the data has arrived on disk successfully or an error is reported.


% TODO: the following is retained from the previous version of
% the I/O chapter with only minor changes. May need more rewriting.

\section{Writing and Reading}
\label{IO_writing_reading}


\subsection{The {\em write}, {\em writeln}, {\em read}, and {\em readln} 
Functions}
\index{writeln@\chpl{writeln}}
\index{write@\chpl{write}}
\index{read@\chpl{read}}
\index{readln@\chpl{readln}}
\index{read}
\index{write}
\index{input/output!read, readln}
\index{input/output!write, writeln}

The predefined function \chpl{write} takes an arbitrary number of
arguments and prints each out in turn to \chpl{stdout}.  The predefined
function \chpl{writeln} is identical to \chpl{write} except that it
outputs an additional {\em end-of-line} character after writing out
the argument expressions.  Both of these functions will generate their
output atomically with respect to other calls to these functions from
other tasks.

The predefined function \chpl{read} takes an arbitrary number of
variable expressions and reads into each in turn from \chpl{stdin}.
For text I/O, any whitespace is skipped over and is used only to separate one
argument from the next.  The predefined function \chpl{readln} is
identical except that upon reading all of its arguments it scans ahead
in the input stream until just after the next {\em end-of-line}
character.

The \chpl{read} and \chpl{readln} functions are also defined to take
an arbitrary number of types as arguments.  In this case, the
functions read an expression of each argument type.  In the event that
a single type is specified, the return value is the value that was
read; if multiple types are specified, a tuple of the values is
returned.

These functions are provided for convenience.
\chpl{write} and \chpl{writeln} invoke the correspondingly-named methods
on the \chpl{stdout} channel (\rsec{IO_channel_write}).
\chpl{read} and \chpl{readln} invoke the correspondingly-named methods
on the \chpl{stdin} channel (\rsec{IO_channel_read}).

\begin{chapelexample}{writeln.chpl}
The \chpl{writeln} function allows for a simple implementation
of the {\em Hello-World} program:
\begin{chapel}
writeln("Hello, World!");
\end{chapel}
\begin{chapelprintoutput}
Hello, World!
\end{chapelprintoutput}
\end{chapelexample}

\begin{example}
The following code shows three ways to read values into a pair of
variables \chpl{x} and \chpl{y}:
\begin{chapel}
var x: int;
var y: real;

/* reading into variable expressions */
read(x, y);

/* reading via a single type argument */
x = read(int);
y = read(real);

/* reading via multiple type arguments */
(x, y) = read(int, real);
\end{chapel}
\end{example}


\subsection{The {\em write} and {\em writeln} Methods on Channels}
\label{IO_channel_write}
\index{input/output!write}
\index{input/output!writeln}
\index{write!on channels}

The \chpl{channel} type supports methods \chpl{write} and \chpl{writeln}
for output.  These methods are defined to take an arbitrary number of
arguments.  Each argument is written in turn by calling
the \chpl{writeThis} method on that argument.
Default \chpl{writeThis} methods are bound to any type that the user
does not explicitly create one for.

Like most other methods on channels,
these operations are guarded with a channel-specific lock
when the channel type's \chpl{locking} parameter is \chpl{true}.


\subsection{The {\em read} and {\em readln} Methods on Channels}
\label{IO_channel_read}
\index{input/output!read}
\index{input/output!readln}
\index{read!on channels}

The \chpl{channel} type supports \chpl{read} and \chpl{readln} methods.
The \chpl{read} method takes an arbitrary number of arguments, reading
in each argument from channel.  The \chpl{readln} method also
takes an arbitrary number of arguments, reading in each argument
from a single line or multiple lines in the channel and 
advancing the channel pointer to the next line after the last argument 
is read.

The \chpl{channel} type also supports overloaded methods \chpl{read}
and \chpl{readln} that take an arbitrary number of types as arguments.
These methods read values of the specified types from the channel and
return them in a tuple.  If only one type is read, the value is not
returned in a tuple, but is returned directly.

\begin{example}
The following line of code reads a value of type \chpl{int} from
\chpl{stdin} and uses it to initialize variable \chpl{x} (causing
\chpl{x} to have an inferred type of \chpl{int}):
\begin{chapel}
var x = stdin.read(int);
\end{chapel}
\end{example}


\subsection{The {\em write} and {\em writeln} Methods on Strings}
\label{stringwrite}
\index{write!on strings}

The \chpl{write} and \chpl{writeln} methods can also be called on
strings to write the output to a string instead of a channel.


%?? \subsection{The {\em read} and {\em readln} method on strings}


\subsection{User-Defined {\em writeThis} Methods}

To define the output for a given type, the user must define a method
called \chpl{writeThis} on that type that takes a single argument of
\chpl{Writer} type.  If such a method does not exist, a default method is
created.


%TODO: \subsection{User-Defined {\em readThis} Methods}


\subsection{Generalized {\em write} and {\em writeln}}
\label{writer}
\index{Writer@\chpl{Writer}}

The \chpl{Writer} class contains no arguments and serves as a base
class to allow user-defined classes to be written to.  If a class is
defined to be a subclass of Writer, it must override
the \chpl{writeIt} method that takes a \chpl{string} as an argument.

\begin{chapelexample}{UserWriter.chpl}
The following code defines a subclass of \chpl{Writer} that overrides
the \chpl{writeIt} method to allow it to be written to.  It also
overrides the \chpl{writeThis} method to override the default way that
it is written.
\begin{chapel}
class C: Writer {
  var data: string;
  proc writePrimitive(x) {
    var s = x:string;
    data += s.substring(1);
  }
  proc writeThis(x: Writer) {
    x.write(data);
  }
}

var c = new C();
c.write(41, 32, 23, 14);
writeln(c);
\end{chapel}
The \chpl{C} class filters the arguments sent to it, printing out only
the first letter.  The output to the above is thus:
% TODO: when 'chapelprintoutput' is extended with some wording,
% move things around so that the printed text is well-composed.
\begin{chapelprintoutput}
4321
\end{chapelprintoutput}
\end{chapelexample}


%TODO: \subsection{Generalized {\em read} and {\em readln}}


%TODO: define the error behavior of read/write/readThis/writeThis/Reader/Writer


\subsection{Default {\em write} and {\em read} Methods}
\index{write!default methods}
\index{read!default methods}

% TODO: these should be moved to the chapters for the corresponding
% data types

% TODO: these are methods on channels, taking arguments of all types.
% Need to make that clear in the text.

Default \chpl{write} methods are created for all types for which a user-defined
\chpl{write} method is not provided.  They have the following semantics:
\begin{itemize}
\item
{\bf arrays} Outputs the elements of the array in row-major order
where rows are separated by line-feeds and blank lines are used to
separate other dimensions.
\item
{\bf domains} Outputs the dimensions of the domain enclosed
by \chpl{[} and \chpl{]}.
\item
{\bf ranges} Outputs the lower bound of the range followed
by \chpl{..} followed by the upper bound of the range.  If the stride
of the range is not one, the output is additionally followed by the
word \chpl{by} followed by the stride of the range.
\item
{\bf tuples} Outputs the components of the tuple in order delimited
by \chpl{(} and \chpl{)}, and separated by commas.
\item
{\bf classes} Outputs the values within the fields of the class
prefixed by the name of the field and the character \chpl{=}.  Each
field is separated by a comma.  The output is delimited by \chpl{\{}
and \chpl{\}}.
\item
{\bf records} Outputs the values within the fields of the class
prefixed by the name of the field and the character \chpl{=}.  Each
field is separated by a comma.  The output is delimited by \chpl{(}
and \chpl{)}.
\end{itemize}

Default \chpl{read} methods are created for all types for which a user-defined
\chpl{read} method is not provided.  The default \chpl{read} methods are
defined to read in the output of the default \chpl{write} method.
