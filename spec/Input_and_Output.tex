\sekshun{Input and Output}
\label{Input_and_Output}
\index{input/output}

Input/output (I/O) facilities in Chapel include
the types \chpl{file} and \chpl{channel},
the constants \chpl{stdin}, \chpl{stdout} and \chpl{stderr},
the functions \chpl{open}, \chpl{close}, \chpl{reader}, \chpl{writer},
\chpl{read} and \chpl{write},
and others.

\index{input/output!file}
\index{input/output!channel}
A \emph{file} in Chapel identifies a file in the underlying operating system.
% TODO: define the typical sequence as "open a file" -> "create a channel"
%
Reads and writes to a file are done via one or more \emph{channels}
associated with the file.
Each channel provides sequential access to its file, optionally
starting at an offset. Channels operate independently of each other,
thus enabling concurrent I/O without contending for locks.
%
Explicit flushing/synchronization operations can be used
to make the data written to a channel available to other channels
and other views of the file.

\index{input/output!I/O style}
Each channel has an \emph{I/O style} that defines
how Chapel's basic types should be read or written.
In particular, the style controls various aspects of binary and text I/O,
including byte order, how strings are encoded in binary channels, base
for numeric text I/O, field widths, and precision.
The I/O style is defined upon channel creation and can be modified later.

I/O facilities in Chapel also include the ability to write data
to strings and to define in the program the output format or actions
to be taken when writing values of a given type.

I/O facilities are presented as follows:

\begin{itemize}

\item the \chpl{file}, \chpl{channel}, and other predefined data types
      available for I/O
      \rsec{IO_data_types}

\item the predefined channels \chpl{stdin}, \chpl{stdout} and \chpl{stderr}
      \rsec{IO_std_channels}

\item functions for opening a file, such as \chpl{open}
      \rsec{IO_open_file}

%Open a \chpl{file} by calling \chpl{open} or similar functions.

\item channel creation via the methods \chpl{reader} and \chpl{writer}
      \rsec{IO_channel_creation}

\item manipulation of a channel's I/O style
      \rsec{IO_channel_style_mods}

% Create one or more \chpl{channel}s by calling \chpl{reader}
% and/or \chpl{writer} on the resulting file.

\item functions for closing channels and files
      % explicitly
      \rsec{IO_closing_files_channels}

% Close the channel(s) and the file by calling \chpl{close} on them.

\item functions for reading data from and/or writing data to a channel
      or a string and for user-defined output formatting

% Read data from and/or write data to the file
% by calling \chpl{read}, \chpl{write} or similar functions
% on the channel(s).

\item functions for synchronizing channel and file data
      with other channels and file viewers
      \rsec{IO_synchronization}

% Optionally ensure that the data written to a channel
% is available to other applications or other views
% of the file by calling \chpl{flush} or \chpl{close}
% on the channel followed by \chpl{fsync} on the channel's file.

\item error handling for I/O functions
      \rsec{IO_error_handling}

\end{itemize}


% TODO: MF suggests adding a section with a further example about
% how to use a channel or a file.


\section{Predefined Data Types and Values for I/O}
\label{IO_data_types}


\subsection{The {\em file} Type and Values}
\label{IO_file_type}
\index{input/output!file}
\index{input/output!file!default value}

A value of the \chpl{file} type represents a file in the underlying
operating system in an implementation-defined way. The default value
of the \chpl{file} type does not represent any OS file.

The details of how the OS file is accessed are determined
when opening a file (\rsec{IO_open_file})
or creating its associated channel (\rsec{IO_channel_creation}).


\subsection{The {\em channel} Type and Values}
\label{IO_channel_type}
\index{input/output!channel}

The \chpl{channel} type is generic. It has the following parameters,
none of which have defaults:

\begin{itemize}

\item \chpl{writing} is a boolean indicating whether the channels of this type
      support writing (when \chpl{true}) or reading (when \chpl{false}).

\item \chpl{kind} is an enum \chpl{iokind} that allows narrowing
      this channel's I/O style for more efficient binary I/O,
      as described in (\rsec{IO_iokind_type}).

\item \chpl{locking} is a boolean indicating whether it is
      safe to use this channel concurrently (when \chpl{true}).
      Safety is implemented by guarding all channel operations, except
      as indicated, with a channel-specific lock.

\end{itemize}

\index{input/output!channel!default value}
The representation of \chpl{channel} values is implementation-defined.
The default value of a \chpl{channel} type is not associated
with any file and so cannot be used to perform I/O.

A channel's I/O style,
which defines certain properties of file access (\rsec{IO_io_style}),
is defined upon channel creation and can be modified later
(\rsec{IO_channel_style_mods}).


\subsection{The {\em iokind} Type}
\label{IO_iokind_type}
\index{input/output!iokind}

The \chpl{iokind} type is an enum. Its constants are intended
as parameters of the \chpl{channel} type,
where they narrow down the channels' I/O style (\rsec{IO_io_style})
when performing binary I/O of numeric types:

\begin{itemize}

\item \chpl{dynamic} means that each channel's run-time I/O style will
      have full effect.      

\item \chpl{native} forces the endianness that is native
      to the target platform for binary I/O.

\item \chpl{big} forces big-endian binary I/O.

\item \chpl{little} forces little-endian binary I/O.

\end{itemize}

In the case of \chpl{native}, \chpl{big}, or \chpl{little},
the channel's I/O style is consulted at run time for
text or string I/O.


\subsection{The {\em iomode} Type}
\label{IO_iomode_type}
\index{input/output!iomode}

The \chpl{iomode} type is an enum. Its constants are intended
as arguments when opening files, with the following meanings:

\begin{itemize}

\item \chpl{r} is like ``r'' in C, means open an existing file for reading.

\item \chpl{w} is like ``w'' in C, means create a new file or
      truncate an existing one, and open it for writing.

\item \chpl{rw} is like ``r+'' in C, means open an existing file for reading
      and writing, but the file must exist.

\item \chpl{wr} is like ``w+'' in C, means open an existing file for reading
      and writing, creating or truncating the file if it exists.

\end{itemize}


\subsection{The {\em iohints} Type}
\label{IO_iohints_type}
\index{input/output!iohints}

The \chpl{iohints} type is an alias for an integer type.
When passed to functions for opening a file (\rsec{IO_open_file}),
a \chpl{iohints} value is interpreted to be a bit mask obtained
by a bitwise OR of the following constants:

\begin{itemize}

\item \chpl{HINT_CACHED} suggests that the file data is or should be
      cached in memory.

\item \chpl{HINT_RANDOM} suggests to expect random access pattern.

\item \chpl{HINT_SEQUENTIAL} suggests to expect sequential access pattern.

\end{itemize}

The zero value indicates that no hints are provided and the default
choices are to be made.

\begin{future}
These hints may be renamed and other hints are likely to be added
in the future.
\end{future}


\subsection{The {\em iostyle} Type and Channel I/O Style}
\label{IO_iostyle_type}
\label{IO_io_style}
\index{input/output!iostyle}
\index{input/output!I/O style}

The \chpl{iostyle} type is implementation-defined.
Modifications to a copy of an \chpl{iostyle} value (e.g.
obtained upon an assignment or argument passing)
are not reflected in the original.

A channel's I/O style is a value of the \chpl{iostyle} type.
It is set when the channel is created and can be modified later
(\rsec{IO_channel_creation}, \rsec{IO_channel_style_mods}).
It defines how Chapel's basic types should be read or written.
For example, it defines whether binary or text I/O
should be performed, the byte order (big or little endian)
and string format for binary I/O, string delimiters,
numeric base and precision for text I/O, etc.

Methods that examine or modify an \chpl{iostyle} value
are provided for the channel I/O style
(\rsec{IO_channel_style_mods}).

\index{input/output!iostyle!default value}
The default value of the \chpl{iostyle} type does not define
a valid I/O style.
Instead, the result of \chpl{defaultStyle()} should be used where
a default is desired (\rsec{IO_channel_style_mods})

%TODO: we may want the default value to define the default
%I/O style, but this seems to be a low priority.


\subsection{The {\em err\_t} Type}
\label{IO_err_type}
\index{input/output!err-t}

The \chpl{err_t} type is an alias for an integer type.
Its values represent success or an error condition of most Chapel I/O
functions, which are accessible as described in \rsec{IO_error_handling}.

The zero value represents success. It can also be obtained as \chpl{ENOERR}.

Non-zero values represent errors. They can be obtained via symbolic
names that are defined in C for \chpl{errno}, for example
\chpl{EEOF}, \chpl{EACCES}, etc.

%TODO: how to get string descriptions of errors?


\section{The Predefined Channels {\em stdin}, {\em stdout}, and {\em stderr}}
\label{IO_std_channels}
\index{input/output!stdin, stdout, stderr}

Chapel provides the predefined channels \chpl{stdin}, \chpl{stdout},
and \chpl{stderr} to access the corresponding operating system streams
standard input, standard output, and standard error.

\chpl{stdin} supports reading;
\chpl{stdout} and \chpl{stderr} support writing.
All three channels are safe to use concurrently and
consult their I/O styles at run time to determine the I/O format.


\section{Functions for Opening Files}
\label{IO_open_file}
\index{input/output!open, opentmp, openmem}

The following functions are provided for opening a file.
Once a file is open, it is necessary to create associated channel(s)
for reading from and/or writing to the file (\rsec{IO_channel_creation}).
The \chpl{error} argument is explained in \rsec{IO_error_handling}.

\begin{protohead}
proc open(path:string, m:iomode, out error:err_t, hints:iohints=0, style:iostyle = defaultStyle()
          ):file;
proc open(path:string, m:iomode, hints:iohints=0, style:iostyle = defaultStyle()):file;
\end{protohead}
\begin{protobody}
Open a file specified by $path$, with
the access iomode $m$ (\rsec{IO_iomode_type})
and file use hints $hints$ (\rsec{IO_iohints_type}).
The $style$ argument defines the I/O style (\rsec{IO_io_style})
for use by default when creating channels associated with this file
(\rsec{IO_channel_creation}).
\end{protobody}

\begin{protohead}
proc opentmp(out error:err_t, hints:iohints=0, style:iostyle = defaultStyle()):file;
proc opentmp(hints:iohints=0, style:iostyle = defaultStyle()):file;
\end{protohead}
\begin{protobody}
% TODO: for writing only?
These are similar to \chpl{open}, but the file they create is temporary:
it is created in an OS-dependent directory (e.g. \chpl{/tmp})
and is deleted upon closing.
\end{protobody}

\begin{protohead}
proc openmem(out error:err_t, style:iostyle = defaultStyle());
proc openmem(style:iostyle = defaultStyle()):file;
\end{protohead}
\begin{protobody}
% TODO: for writing only?
These are similar to \chpl{open}, but create a file
that is backed up by a buffer in memory and deleted upon closing.
\end{protobody}


\section{Functions for Channel Creation and Manipulation}
\label{IO_channel_creation}

\index{input/output!reader}
\index{input/output!writer}
\begin{protohead}
proc file.reader(out error:err_t, param kind=iokind.dynamic, param locking=true,
                 start:int(64) = 0, end:int(64) = max(int(64)), hints:iohints = 0,
                 style:iostyle = this._style): channel(false, kind, locking);
proc file.reader(param kind=iokind.dynamic, param locking=true,
                 start:int(64) = 0, end:int(64) = max(int(64)), hints:iohints = 0,
                 style:iostyle = this._style): channel(false, kind, locking);
proc file.writer(out error:err_t, param kind=iokind.dynamic, param locking=true,
                 start:int(64) = 0, end:int(64) = max(int(64)), hints:iohints = 0,
                 style:iostyle = this._style): channel(true,kind,locking);
proc file.writer(param kind=iokind.dynamic, param locking=true,
                 start:int(64) = 0, end:int(64) = max(int(64)), hints:iohints = 0,
                 style:iostyle = this._style): channel(true,kind,locking);
\end{protohead}
\begin{protobody}
The \chpl{reader} function creates a channel for reading from the file.
The \chpl{writer} function creates a channel for writing to the file.

The arguments are as follows:

\begin{itemize}

\item \chpl{error} is explained in \rsec{IO_error_handling}.

\item \chpl{kind} and \chpl{locking} determine the corresponding parameters of
      the \chpl{channel} type that is returned (see \rsec{IO_channel_type})

\item \chpl{start} and \chpl{end} define the region of the file that
      the channel will write to. The defaults for these arguments enable
      the channel to access the entire file.

      A channel will never read/write beyond its maximum end position,
      and it will extend the file only as necessary to store data
      written to the channel. In other words, specifying end here
      does not impact the file size; only the section of the file
      that this channel can write to. After all channels to a file
      are closed, that file will have a size equal to the last
      position of any channel.

\item \chpl{hints} provides hints about the I/O that this channel
      will perform, as described in \rsec{IO_iohints_type}.
      If \chpl{hints} is zero, the hints provided when opening
      the file will be used.

\item \chpl{style} sets this channel's I/O style (\rsec{IO_io_style}).
      If the corresponding actual argument is omitted,
      the I/O style will be set to the style specified when the file
      was opened (\rsec{IO_open_file}).

\end{itemize}

\end{protobody}


\section{Functions for Manipulating a Channel's I/O Style}
\label{IO_channel_style_mods}

The following operations provide access to and modification of
a channel's I/O style. Like most other methods on channels,
these operations are guarded with a channel-specific lock
when the channel type's \chpl{locking} parameter is \chpl{true}.

\index{input/output!defaultStyle}
\begin{protohead}
proc defaultStyle():iostyle;
\end{protohead}
\begin{protobody}
The return value defines the default I/O style,
which provides reasonable defaults for most channel I/O operations.
\end{protobody}

\index{input/output!modifyStyle}
\begin{protohead}
proc channel.modifyStyle(f:func(iostyle, iostyle));
\end{protohead}
\begin{protobody}
Modify the channel's I/O style. The argument is
%the new I/O style or
a function that takes the channel's current I/O style and returns
the new I/O style to be set for the channel.
\end{protobody}

\begin{future}
Operations that retrieve or set a channel's I/O style
or modify its individual aspects will also be provided.
\end{future}


\section{Closing Channels and Files}
\label{IO_closing_files_channels}

In order to free the resources allocated for a file or a channel, it
must be closed using one of the following methods:

\index{input/output!close}
\begin{protohead}
proc file.close(out error:err_t);
proc file.close();
proc channel.close(out error:err_t);
proc channel.close();
\end{protohead}
\begin{protobody}
Close a file or a channel.
The \chpl{error} argument is explained in \rsec{IO_error_handling}.
\end{protobody}

%TODO: can one be closed multiple times?
It is an error to perform any I/O operations on a channel or file
that has been closed or whose copy has been closed. Here, ``copy''
is a value that results from an assignment or argument passing.
%
It is an error to close a file when it has channels that
have not been closed.

Closing a file, when completed successfully, also commits
all file data to the disk or other persistent storage,
if applicable.

\begin{future}
In the future we plan to implement reference counting for files
and channels. Each file and channel will be closed automatically
when no references remain to it. For example, if only a local
variable refers to a channel, the channel will be closed
when that variable goes out of scope.
% any more here?
The ability for the program to close a file or a channel
explicitly will remain available.
\end{future}


\section{Synchronizing Channel and File Data}
\label{IO_synchronization}

The following synchronization operations are available.

\index{input/output!flush}
\begin{protohead}
proc channel.flush(out error:err_t);
proc channel.flush();
\end{protohead}
\begin{protobody}
Make all writes to the channel available to other concurrent views of the
channel's file. These include other channels for the same file and
other applications accessing the file concurrently.
This does not guarantee persistence of the written data, however.
\end{protobody}

\index{input/output!fsync}
\begin{protohead}
proc file.fsync(out error:err_t);
proc file.fsync();
\end{protohead}
\begin{protobody}
Commits all file data to the disk or other persistent storage, if
applicable. This ensures that the file data will be available to
applications executing later.
\end{protobody}


\section{Error Handling}
\label{IO_error_handling}
\index{input/output!error}
\index{input/output!err-t}

Most I/O functions have two versions: with the \chpl{out error:err_t}
argument and without. The version that takes the \chpl{error} argument
returns the success or error code (\rsec{IO_err_type}) in that argument.
The version that does not accept \chpl{error} halts with an error message
if an error condition is encountered.

\begin{future}
If exceptions are added to Chapel, the no-\chpl{error} versions
could be changed to throw exceptions instead of halting.
\end{future}

In most cases I/O errors are reported by the function during whose
call those errors occurred. However, in some cases errors are
reported only upon \chpl{file.close} \rsec{IO_closing_files_channels}
or \chpl{file.fsync} \rsec{IO_synchronization}.
Therefore, one of these two functions must be invoked to ensure
that the data has arrived on disk successfully or an error is reported.


% TODO: the following is retained from the previous version of
% the I/O chapter with only minor changes. May need more rewriting.

\section{The {\em write}, {\em writeln}, {\em read}, and {\em readln} 
functions}
\index{writeln@\chpl{writeln}}
\index{write@\chpl{write}}
\index{read@\chpl{read}}
\index{readln@\chpl{readln}}
\index{read}
\index{write}
\index{input/output!read, readln}
\index{input/output!write, writeln}

The predefined function \chpl{write} takes an arbitrary number of
arguments and prints each out in turn to \chpl{stdout}.  The predefined
function \chpl{writeln} is identical to \chpl{write} except that it
outputs an additional {\em end-of-line} character after writing out
the argument expressions.  Both of these functions will generate their
output atomically with respect to other calls to these functions from
other tasks.

The predefined function \chpl{read} takes an arbitrary number of
variable expressions and reads into each in turn from \chpl{stdin}.
For text I/O, any whitespace is skipped over and is used only to separate one
argument from the next.  The predefined function \chpl{readln} is
identical except that upon reading all of its arguments it scans ahead
in the input stream until just after the next {\em end-of-line}
character.

The \chpl{read} and \chpl{readln} functions are also defined to take
an arbitrary number of types as arguments.  In this case, the
functions read an expression of each argument type.  In the event that
a single type is specified, the return value is the value that was
read; if multiple types are specified, a tuple of the values is
returned.

These functions are provided for convenience.
\chpl{write} and \chpl{writeln} invoke the correspondingly-named methods
on the \chpl{stdout} channel (\rsec{IO_channel_write}).
\chpl{read} and \chpl{readln} invoke the correspondingly-named methods
on the \chpl{stdin} channel (\rsec{IO_channel_read}).

\begin{chapelexample}{writeln.chpl}
The \chpl{writeln} function allows for a simple implementation
of the {\em Hello-World} program:
\begin{chapel}
writeln("Hello, World!");
\end{chapel}
\begin{chapelprintoutput}
Hello, World!
\end{chapelprintoutput}
\end{chapelexample}

\begin{example}
The following code shows three ways to read values into a pair of
variables \chpl{x} and \chpl{y}:
\begin{chapel}
var x: int;
var y: real;

/* reading into variable expressions */
read(x, y);

/* reading via a single type argument */
x = read(int);
y = read(real);

/* reading via multiple type arguments */
(x, y) = read(int, real);
\end{chapel}
\end{example}

\section{User-Defined {\em writeThis} Methods}

To define the output for a given type, the user must define a method
called \chpl{writeThis} on that type that takes a single argument of
\chpl{Writer} type.  If such a method does not exist, a default method is
created.

\section{The {\em write} and {\em writeln} Methods on Channels}
\label{IO_channel_write}
\index{input/output!write}
\index{input/output!writeln}
\index{write!on channels}

The \chpl{channel} type supports methods \chpl{write} and \chpl{writeln}
for output.  These methods are defined to take an arbitrary number of
arguments.  Each argument is written in turn by calling
the \chpl{writeThis} method on that argument.
Default \chpl{writeThis} methods are bound to any type that the user
does not explicitly create one for.

Like most other methods on channels,
these operations are guarded with a channel-specific lock
when the channel type's \chpl{locking} parameter is \chpl{true}.

%TODO: define 'readThis', too

\subsection{The {\em write} and {\em writeln} method on strings}
\label{stringwrite}
\index{write!on strings}

The \chpl{write} and \chpl{writeln} methods can also be called on
strings to write the output to a string instead of a channel.

\subsection{Generalized {\em write} and {\em writeln}}
\label{writer}
\index{Writer@\chpl{Writer}}

The \chpl{Writer} class contains no arguments and serves as a base
class to allow user-defined classes to be written to.  If a class is
defined to be a subclass of Writer, it must override
the \chpl{writeIt} method that takes a \chpl{string} as an argument.

\begin{chapelexample}{UserWriter.chpl}
The following code defines a subclass of \chpl{Writer} that overrides
the \chpl{writeIt} method to allow it to be written to.  It also
overrides the \chpl{writeThis} method to override the default way that
it is written.
\begin{chapel}
class C: Writer {
  var data: string;
  proc writePrimitive(x) {
    var s = x:string;
    data += s.substring(1);
  }
  proc writeThis(x: Writer) {
    x.write(data);
  }
}

var c = new C();
c.write(41, 32, 23, 14);
writeln(c);
\end{chapel}
The \chpl{C} class filters the arguments sent to it, printing out only
the first letter.  The output to the above is thus:
% TODO: when 'chapelprintoutput' is extended with some wording,
% move things around so that the printed text is well-composed.
\begin{chapelprintoutput}
4321
\end{chapelprintoutput}
\end{chapelexample}


\section{The {\em read} and {\em readln} Methods on Channels}
\label{IO_channel_read}
\index{input/output!read}
\index{input/output!readln}
\index{read!on channels}

The \chpl{channel} type supports \chpl{read} and \chpl{readln} methods.
The \chpl{read} method takes an arbitrary number of arguments, reading
in each argument from channel.  The \chpl{readln} method also
takes an arbitrary number of arguments, reading in each argument
from a single line or multiple lines in the channel and 
advancing the channel pointer to the next line after the last argument 
is read.

The \chpl{channel} type also supports overloaded methods \chpl{read}
and \chpl{readln} that take an arbitrary number of types as arguments.
These methods read values of the specified types from the channel and
return them in a tuple.  If only one type is read, the value is not
returned in a tuple, but is returned directly.

\begin{example}
The following line of code reads a value of type \chpl{int} from
\chpl{stdin} and uses it to initialize variable \chpl{x} (causing
\chpl{x} to have an inferred type of \chpl{int}):
\begin{chapel}
var x = stdin.read(int);
\end{chapel}
\end{example}


\section{Default {\em read} and {\em write} methods}
\index{write!default methods}
\index{read!default methods}

% TODO: these should be moved to the chapters for the corresponding
% data types

Default \chpl{write} methods are created for all types for which a user
\chpl{write} method is not defined.  They have the following semantics:
\begin{itemize}
\item
{\bf arrays} Outputs the elements of the array in row-major order
where rows are separated by line-feeds and blank lines are used to
separate other dimensions.
\item
{\bf domains} Outputs the dimensions of the domain enclosed
by \chpl{[} and \chpl{]}.
\item
{\bf ranges} Outputs the lower bound of the range followed
by \chpl{..} followed by the upper bound of the range.  If the stride
of the range is not one, the output is additionally followed by the
word \chpl{by} followed by the stride of the range.
\item
{\bf tuples} Outputs the components of the tuple in order delimited
by \chpl{(} and \chpl{)}, and separated by commas.
\item
{\bf classes} Outputs the values within the fields of the class
prefixed by the name of the field and the character \chpl{=}.  Each
field is separated by a comma.  The output is delimited by \chpl{\{}
and \chpl{\}}.
\item
{\bf records} Outputs the values within the fields of the class
prefixed by the name of the field and the character \chpl{=}.  Each
field is separated by a comma.  The output is delimited by \chpl{(}
and \chpl{)}.
\end{itemize}

Default \chpl{read} methods are created for all types for which a user
\chpl{read} method is not defined.  The default \chpl{read} methods are
defined to read in the output of the default \chpl{write} method.
