\sekshun{Iterators}
\label{Iterators}
\index{iterators}

An iterator is a function that conceptually returns multiple values
rather than simply a single value.

\begin{openissue}
The parallel iterator story is under development.  It is expected that
the specification will be expanded regarding parallel iterators soon.
\end{openissue}

\subsection{Iterator Functions}
\label{Iterator_Functions}

The syntax of an iterator declaration is identical to that of a
function declaration.  A function is an iterator if it includes yield
statements.  When a yield is encountered, the value is returned, but
the iterator is not finished evaluating when called within a loop.  It
will continue from the point after the yield and can yield or return
more values.  When a return is encountered, the value is returned and
the iterator finishes.  An iterator also completes after the last
statement in the iterator function is executed.

\subsection{The Yield Statement}
\label{The_Yield_Statement}
\index{yield@\chpl{yield}}

The yield statements can only appear in iterators.  The syntax of the
yield statement is given by
\begin{syntax}
yield-statement:
  `yield' expression ;
\end{syntax}

\subsection{Iterator Calls}
\label{Iterator_Calls}

Iterator functions can be called within for or forall loops, in which
case they are executed in an interleaved manner with the body of the
loop. An iterator function call, or iterator invocation, can be used in an expression context, in which
case it evaluates to a 1-based array of values. 
An iterator invocation can also be passed to a
generic function argument, in which case it will not be evaluted until
the formal argument is referenced within the function.

\subsubsection{Iterators in For and Forall Loops}
\label{Iterators_in_For_and_Forall_Loops}

When an iterator is accessed via a for or forall loop, the iterator is
evaluated alongside the loop body in an interleaved manner.  For each
iteration, the iterator yields a value and the body is executed.

\subsubsection{Iterators as Arrays}
\label{Iterators_as_Arrays}
\index{iterators!and arrays}

If an iterator function is captured into a new variable declaration or
assigned to an array, the iterator is iterated over in total and the
expression evaluates to a one-dimensional arithmetic array that
contains the values returned by the iterator on each iteration.
\begin{example}
Given an iterator
\begin{chapel}
def squares(n: int): int {
  for i in 1..n do
    yield i * i;
}
\end{chapel}
\begin{chapelpost}
writeln(squares(5));
\end{chapelpost}
\begin{chapeloutput}
1 4 9 16 25
\end{chapeloutput}
the expression \chpl{squares(5)} evaluates to the array \chpl{1, 4, 9, 16, 25}.
\end{example}

\subsubsection{Iterators and Generics}
\label{Iterators_and_Generics}
\index{iterators!and generics}

An iterator call expression can be passed to a generic function argument that
has neither a declared type nor default value
(\rsec{Formal_Arguments_without_Types}).
In this case the iterator is passed without being evaluated.
Within the generic function the corresponding formal argument
can be used as an iterator, e.g. in for loops.
The arguments to the iterator call expression, if any, are evaluated
at the call site, i.e. prior to passing the iterator to the generic function.

\subsubsection{Recursive Iterators}
\label{Recursive_Iterators}
\index{iterators!recursive}

Recursive iterators are allowed. A recursive iterator invocation is
typically made by iterating over it in a loop.


\begin{example}
A post-order traversal of a tree data structure could be written like this:
\begin{chapel}
def postorder(tree: Tree): string {
  if tree != nil {
    for child in postorder(tree.left) do
      yield child;
    for child in postorder(tree.right) do
      yield child;
    yield tree.data;
  }
}
\end{chapel}
By contrast, using calls \chpl{postorder(tree.left)}
and \chpl{postorder(tree.right)} as stand-alone statements would
result in generating temporary arrays containing the outcomes of these
recursive calls, which would then be discarded.
\end{example}

\subsection{Parallel Iterators}
\label{Parallel_Iterators}

Iterators used in explicit forall-statements or -expressions must be
parallel iterators.  Reductions, scans and promotion over serial
iterators will be serialized.

The definition of parallel iterators is forthcoming.  Parallel
iterators are defined over standard constructs in Chapel such as
ranges, domains, and arrays (including Block- and Cyclic-distributed
domains and arrays), thereby allowing these constructs to be used with
forall-statements and -expressions.
