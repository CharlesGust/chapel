\sekshun{Locales and Distributions}
\label{Locality_and_Distribution}

Chapel provides high-level abstractions that allow programmers to
exploit locality by controlling the affinity of both data and tasks to
abstract units of processing and storage capabilities
called \emph{locales}.  The \emph{on-statement} allows for the
migration of tasks to \emph{remote} locales.

\index{local}
\index{remote}
Throughout this section, the term \emph{local} will be used to
describe the locale on which a task is running, the data located on
this locale, and any tasks running on this locale.  The
term \emph{remote} will be used to describe another locale, the data
on another locale, and the tasks running on another locale.

Although data of any type can be associated with locales, the {\em
distribution} construct supports partitioning the indices of domains
and the elements of arrays across a set of locales.  In addition to
defining how such data partitioning is done, distributions define the
implementation of data parallelism across the set of locales including
the placement of tasks.

\subsection{Locales}
\label{Locales}
\index{locales}

A \emph{locale} is a portion of the target parallel architecture that
has processing and storage capabilities.  Chapel implementations
should typically define locales for a target architecture such that
tasks running within a locale have roughly uniform access to values
stored in the locale's local memory and longer latencies for accessing
the memories of other locales.  As an example, a cluster of multicore
nodes or SMPs would typically define each node to be a locale.  In
contrast a pure shared memory machine would be defined as a single
locale.

\subsubsection{Locale Types}
\label{The_Locale_Type}
\index{locale@\chpl{locale}}

The identifier \chpl{locale} is a primitive type that abstracts a
locale as described above.  Both data and tasks can be associated with
a value of locale type. The only operators defined over locales are
the equality and inequality comparison operators.

\subsubsection{Locale Methods}
\label{Locale_Methods}
\index{Locales!methods}

The locale type supports the following methods:

\begin{protohead}
def locale.id: int;
\end{protohead}
\begin{protobody}
Returns a unique integer for each locale, from 0 to the number of
locales less one.
\end{protobody}

\begin{protohead}
def locale.numCores: int;
\end{protohead}
\begin{protobody}
Returns the number of processor cores available on a given locale.
\end{protobody}

\begin{protohead}
use Memory;
def locale.physicalMemory(unit: MemUnits=MemUnits.Bytes, type retType=int(64)): retType;
\end{protohead}
\begin{protobody}
Returns the amount of physical memory available on a given locale in
terms of the specified memory units (Bytes, KB, MB, or GB) using a
value of the specified return type.
\end{protobody}

\subsubsection{The Predefined Locales Array}
\label{Predefined_Locales_Array}
\index{Locales@\chpl{Locales}}
\index{numLocales@\chpl{numLocales}}
\index{execution environment}

Chapel provides a predefined environment that stores information about
the locales used during program execution.  This {\em execution
environment} contains definitions for the array of locales on which
the program is executing (\chpl{Locales}), a domain for that array
(\chpl{LocaleSpace}), and the number of locales (\chpl{numLocales}).
\begin{chapel}
config const numLocales: int;
const LocaleSpace: domain(1) = [0..numLocales-1];
const Locales: [LocaleSpace] locale;
\end{chapel}
When a Chapel program starts, a single task executes \chpl{main}
on \chpl{Locales(0)}.

Note that the Locales array is typically defined such that distinct
elements refer to distinct resources on the target parallel
architecture.  In particular, the Locales array itself should not be
used in an oversubscribed manner in which a single processor resource
is represented by multiple locale values (except during development).
Oversubscription should instead be handled by creating an aggregate of
locale values and referring to it in place of the Locales array.

\begin{rationale}
This design choice encourages clarity in the program's source text and
enables more opportunities for optimization.

For development purposes, oversubscription is still very useful and
this should be supported by Chapel implementations to allow
development on smaller machines.
\end{rationale}

\begin{example}
The code
\begin{chapel}
const MyLocales: [loc in 0..numLocales*4] locale = Locales(loc%numLocales);
on MyLocales(i) ...
\end{chapel}
defines a new array \chpl{MyLocales} that is four times the size of
the \chpl{Locales} array.  Each locale is added to
the \chpl{MyLocales} array four times in a round-robin fashion.
\end{example}

\subsubsection{The {\em here} Locale}
\label{here}
\index{here@\chpl{here}}

A predefined constant locale \chpl{here} can be used anywhere in a
Chapel program.  It refers to the locale that the current task is
running on.

\begin{example}
The code
\begin{chapel}
on Locales(1) {
  writeln(here.id);
}
\end{chapel}
results in the output \chpl{1} because the \chpl{writeln} statement is
executed on locale 1.
\end{example}

The identifier \chpl{here} is not a keyword and can be overridden.

\subsubsection{Querying the Locale of an Expression}
\label{Querying_the_Locale_of_a_Variable}
\index{locale@\chpl{locale}}

The locale associated with an expression (where the expression is
stored) is queried using the following syntax:
\begin{syntax}
locale-access-expression:
  expression . `locale'
\end{syntax}
When the expression is a class, the access returns the locale on which
the class object exists rather than the reference to the class.  If
the expression is a value, it is considered local.  The implementation
may warn about this behavior.  If the expression is a locale, it is
returned directly.

\begin{example}
Given a class C and a record R, the code
\begin{chapel}
on Locales(1) {
  var x: int;
  var c: C;
  var r: R;
  on Locales(2) {
    on Locales(3) {
      c = new C();
      r = new R();
    }
    writeln(x.locale);
    writeln(c.locale);
    writeln(r.locale);
  }
}
\end{chapel}
results in the output
\begin{chapel}
1
3
1
\end{chapel}
The variable \chpl{x} is declared and exists on \chpl{Locales(0)}.
The variable \chpl{c} is a class reference.  The reference exists
on \chpl{Locales(1)} but the object itself exists
on \chpl{Locales(3)}.  The locale access returns the locale where the
object exists.  Lastly, the variable \chpl{r} is a record and has
value semantics.  It exists on \chpl{Locales(1)} even though it is
assigned a value on a remote locale.
\end{example}

\subsection{The On Statement}
\label{On}
\index{on@\chpl{on}}

The on statement controls on which locale a block of code should be
executed or data should be placed.  The syntax of the on statement is
given by
\begin{syntax}
on-statement:
  `on' expression `do' statement
  `on' expression block-statement
\end{syntax}
The locale of the expression is automatically queried as described
in~\rsec{Querying_the_Locale_of_a_Variable}.  Execution of the
statement occurs on this specified locale and then continues after
the \chpl{on-statement}.

The following statements may not be lexically enclosed in
on-statements: yield-statements and return-statements.

\begin{openissue}
It may be worthwhile to allow yields in on-statments such that when a
loop iterates over an iterator, on-statements inside the iterator
control where the corresponding loop body is executed.  For example,
an iterator over a distributed tree might include an iterator over the
nodes as defined in the following code:
\begin{chapel}
class Tree {
  var left, right: Tree;
  def nodes {
    on this do yield this;
    if left then
      for t in left.nodes do
        yield t;
    if right then
      for t in right.nodes do
        yield t;
  }
}
\end{chapel}
Given this code and a binary tree of type \chpl{Tree} stored in
variable \chpl{tree}, then we can use the \chpl{nodes} iterator to
iterate over the tree with the following code:
\begin{chapel}
for t in tree.nodes {
  // body executed on t as specified in nodes
}
\end{chapel}
Here, each instance of the body of the \chpl{forall} loop is executed
on the locale where the corresponding object \chpl{t} is located.
This is specified in the \chpl{nodes} iterator where the \chpl{on}
keyword is used.  In the case of zipper or tensor product iteration,
the location of execution is taken from the first iterator.  This can
be overridden by explicitly using \chpl{on} in the body of the loop or
by reordering the product of iteration.
\end{openissue}

\subsubsection{Remote Variable Declarations}
\label{remote_variable_declarations}

By default, when new variables and data objects are created, they are
created in the locale where the task is running.  Variables can be
defined within an \sntx{on-statement} to define them on a particular
locale such that the scope of the variables is outside
the \sntx{on-statement}.  This is accomplished using a similar syntax
but omitting the \chpl{do} keyword and braces.  The syntax is given
by:
\begin{syntax}
remote-variable-declaration-statement:
  `on' expression variable-declaration-statement
\end{syntax}

\subsection{Distributions}
\label{Distributions}
\index{distributions}

A mapping from domain index values to locales is called a {\em
distribution}.

\subsubsection{Distribution Types}
\label{Distribution_Types}

Distribution types are defined by the type of a distribution class
that derives from BaseDist and is typically generic.  They are
distinct from the distribution class type.  Typically, the
distribution class type is only used on its own in defining the
distribution itself~\rsec{User_Defined_Distributions}.

Defining a distribution type involves specifying a distribution class
type and wrapping this in a distribution type \chpl{dist}.
\begin{example}
The code
\begin{chapel}
use BlockDist;
var MyBlockDist: dist(Block(rank=2));
\end{chapel}
defines a Block distribution called \chpl{MyBlockDist} with rank 2 and
a default index type that can be used to distribute 2-dimensional
arithmetic domains.  The Block distribution is described in more
detail in~\rsec{Block_Dist}.
\end{example}

\subsubsection{Distribution Values}
\label{Distribution_Values}

Constructing a distribution involves calling the constructor of a
distribution class and defining a new distribution type \chpl{dist}.
\begin{example}
The code
\begin{chapel}
use BlockDist;
var MyBlockDist = new dist(new Block(rank=2, bbox=[1..n,1..n]));
\end{chapel}
constructs a Block distribution that partitions the index space
specified by \chpl{[1..n, 1..n]} over all of the locales.  The Block
distribution is described in more detail in~\rsec{Block_Dist}.
\end{example}

\subsubsection{Distributed Domains}
\label{Distributed_Domains}

\index{domains!distributed}
A domain for which a distribution is specified is referred to as a
{\em distributed domain}.

\begin{rationale}
Should this be? A domain supports a method, \chpl{locale}, that maps
index values in the domain to locales that correspond to the domain's
distribution.
\end{rationale}

The syntax to create a distributed domain type is the same as the
syntax to create a distributed domain value:
\begin{syntax}
distributed-domain-type:
  domain-type `distributed' distribution-expression

distributed-domain-expression:
  domain-expression `distributed' distribution-expression

distribution-expression:
  expression
\end{syntax}

\begin{example}
The code
\begin{chapel}
use BlockDist;
var MyBlockDist = new dist(new Block(rank=2, bbox=[1..n,1..n]));
var Dom: domain(2) distributed MyBlockDist =
           [1..n, 1..n] distributed MyBlockDist;
\end{chapel}
defines a new domain that is distributed by \chpl{MyBlockDist}.  Note
that, as usual, the type does not need to be specified if the variable
is initialized.
\end{example}

When defining a new distribution inline with the \chpl{distributed}
keyword, a syntactic sugar is supported in which the ``new dist new''
characters may be omitted.
\begin{example}
The code
\begin{chapel}
use BlockDist;
var D = [1..n, 1..n] distributed new dist(new Block(rank=2, bbox=[1..n,1..n]));
\end{chapel}
is equivalent to
\begin{chapel}
use BlockDist;
var D = [1..n, 1..n] distributed Block(rank=2, bbox=[1..n,1..n]);
\end{chapel}
\end{example}

Iteration over a distributed domain implicitly executes the controlled
task in the domain of the associated locale.  Similarly, when
iterating over the elements of an array defined over a distributed
domain, the controlled tasks are determined by the distribution of the
domain.  If there are conflicting distributions in product iterations,
the locale of a task is taken to be the first component in the
product.

\begin{example}
If \chpl{D} is a distributed domain, then in the code
\begin{chapel}
forall d in D {
  // body
}
\end{chapel}
the body of the loop is executed in the locale where the
index \chpl{d} maps to by the distribution of \chpl{D}.
\end{example}

\subsubsection{Distributed Arrays}
\label{Distributed_Arrays}
\index{arrays!distributed}

Arrays defined over a distributed domain will have the element
variables stored on the locale determined by the distribution.  Thus,
if \chpl{d} is an index of distributed domain \chpl{D} and \chpl{A} is
an array defined over that domain, then \chpl{A(d).locale} is the
locale to which \chpl{d} maps to according to \chpl{D}.

\subsubsection{Undistributed Domains and Arrays}
\label{Undistributed_Domains_and_Arrays}

If a domain or an array does not have a distributed part, the domain
or array is not distributed and exists only on the locale on which it
is defined.

\subsection{Standard Distributions}
\label{Standard_Distributions}

Standard distributions include the following:
\begin{itemize}
\item The block distribution \chpl{Block}
\item The cyclic distribution \chpl{Cyclic}
\item The block-cyclic distribution \chpl{BlockCyclic}
\end{itemize}

\begin{openissue}
There is an expectation that the number of standard distributions will
grow dramatically.
\end{openissue}

A design goal is that all standard distributions are defined using the
same mechanisms available to Chapel programmers wishing to define
their own distributions~(\rsec{User_Defined_Distributions}).

\subsubsection{The Standard Block Distribution}
\label{Block_Dist}

The standard Block distribution is defined in the module
called \chpl{BlockDist}.  This module must be explicitly used.

The Block distribution is parameterized by the rank and index type of
the domains for which it will support.  Thus domains of different
ranks or different index types must be distributed with different
distributions.

The Block class constructor is defined as follows:
\begin{chapel}
def Block(param rank: int,
          type idxType = int,
          bbox: domain(rank, idxType),
          targetLocales: [] locale = thisRealm.Locales, 
          tasksPerLocale: int = 0)
\end{chapel}

The argument \chpl{bbox} is a non-distributed domain defining a
bounding box used to partition the space of all indices across the
array of target locales.  The indices inside the bounding box are
partitioned ``evenly'' across the locales and indices outside the
bounding box are mapped to the same locale as the nearest index inside
the bounding box.

The argument \chpl{targetLocales} is a non-distributed array
containing the target locales to which this distribution partitions
indices and data.  The rank of \chpl{targetLocales} must match the
rank of the distribution, or be one.  If the rank
of \chpl{targetLocales} is one, it will be factored and reshaped so
that it matches the rank of the distribution.  A greedy heuristic is
used to ``evenly'' do the factoring.

The argument \chpl{tasksPerLocale} is an integer that specifies the
number of tasks to use on each locale when iterating in parallel over
a Block-distributed domain or array.

\subsubsection{The Standard Cyclic Distribution}
\label{Cyclic_Dist}

This section is forthcoming.

\subsubsection{The Standard Block-Cyclic Distribution}
\label{Block_Cyclic_Dist}

This section is forthcoming.

\subsection{User-Defined Distributions}
\label{User_Defined_Distributions}

This section is forthcoming.
