\sekshun{Ranges}
\label{Ranges}
\index{ranges}

Ranges represent a sequence of integral values.  Ranges are
either \emph{bounded} or \emph{unbounded}.

Bounded ranges are characterized by a low bound~$l$, a high bound~$h$,
and a stride~$s$.  If the stride is positive, the values described by
the range are $l, l+s, l+2s, l+3s, ...$ such that all of the values in
the sequence are less than or equal to $h$.  If the stride is negative,
the values described by the range are $h, h+s, h+2s, h+3s, ...$ such
that all of the values in the sequence are greater than or equal to
$l$.  If $l > h$, the range is considered degenerate and represents an
empty sequence. Ranges support iteration over the values they represent
as described in ~\rsec{The_For_Loop}.

Unbounded ranges are those in which the low and/or high bounds are
omitted.  Unbounded ranges conceptually represent a countably infinite
number of values.

\subsection{Range Types}
\label{Range_Types}
\index{ranges!types}

The type of a range is characterized by three things:
(1)~the type of the values being represented, (2)~the boundedness of
the range, and (3)~whether or not the range is \emph{stridable}.

The type of the range's values is represented using a type parameter
named \emph{idxType}.  This must be one of the \chpl{int} or
\chpl{uint} types.  The default type is \chpl{int}.
The type of a range's stride is the signed equivalent of its \emph{idxType}.

\begin{openissue}
It has been hypothesized that ranges of other types, such as floating
point values, might also be of interest to represent a range of legal
tolerances, for example.  If you believe such support would be of
interest to you, please let us know.
\end{openissue}

The boundedness of the range is represented using an enumerated
parameter named \emph{boundedType} of type \chpl{BoundedRangeType}.
Legal values are \chpl{bounded}, \chpl{boundedLow},
\chpl{boundedHigh}, and \chpl{boundedNone}.  The first value specifies
a bounded range while the other three values specify a range in which
the high bound is omitted, the low bound is omitted, or both bounds
are omitted, respectively.  The default value is \chpl{bounded}.

The stridability of a range is represented by a boolean parameter
named \emph{stridable}.  If this parameter is set to true, the range's
stride can take on any signed integer value other than 0 of the same
bit-width as \chpl{idxType}.  If set to false, the range's stride is
fixed to 1.  The default value is \chpl{false}.

\begin{rationale}
The \emph{boundedType} and \emph{stridable} values of a range are used
to optimize the generated code for common cases of ranges, as well as
to optimize the implementation of domains and arrays defined using
ranges.
\end{rationale}

The syntax of a range type is summarized as follows:
\begin{syntax}
range-type:
  `range' ( named-expression-list )
\end{syntax}

\begin{example}
The following declaration declares a variable \chpl{r}
of range type that can represent ranges of 64-bit integers, with both
high and low bounds specified, and the ability to have a stride other
than 1.
\begin{chapelpre}
% test_rangeVariable.chpl
\end{chapelpre}
\begin{chapel}
var r: range(int(64), BoundedRangeType.bounded, stridable=true);
\end{chapel}
\begin{chapelpost}
writeln(r);
var i64: int(64) = 3;
r = i64..13 by 3;
writeln(r);
\end{chapelpost}
\begin{chapeloutput}
1..0
3..13 by 3
\end{chapeloutput}
\end{example}

The default value for a range is \chpl{1..0}.

\subsection{Literal Range Values}
\label{Range_Literals}
\index{ranges!literals} 

Range literals are specified as follows:
\begin{syntax}
range-literal:
  bounded-range-literal
  unbounded-range-literal
\end{syntax}

\subsubsection{Bounded Range Literals}
\label{Bounded_Ranges}
\index{ranges!bounded}

A bounded range is specified by the syntax
\begin{syntax}
bounded-range-literal:
  expression .. expression
\end{syntax}
The first expression is taken to be the lower bound $l$ and the second
expression is taken to be the upper bound $h$.  The stride of the
range is 1 and can be modified with the \chpl{by} operator as described
in~\rsec{By_Operator_For_Ranges}.

\index{ranges!integral element type}
The element type of the range type is determined by the type of the
low and high bound.  It is either \chpl{int}, \chpl{uint},
\chpl{int(64)}, or \chpl{uint(64)}.  The index type of the range is obtained by
applying integral promotions to the low and high bounds.  The boundedness
of such a range is \chpl{BoundedRangeType.bounded}.  The stridability of
the range is \chpl{false}.

\subsubsection{Unbounded Range Literals}
\label{Unbounded_Ranges}
\index{ranges!unbounded}

An unbounded range is specified by the syntax
\begin{syntax}
unbounded-range-literal:
  expression ..
  .. expression
  ..
\end{syntax}

The first form results in a \chpl{BoundedRangeType.boundedLow} range, the
second in a \chpl{BoundedRangeType.boundedHigh} range, and the third in
a \chpl{BoundedRangeType.boundedNone} range.

When used in zippered iteration (~\rsec{Zipper_Iteration}), the shape of an
unbounded range conforms to that of the other iterator.

\begin{example}
The code
\begin{chapelpre}
% test_zipWithUnbounded.chpl
\end{chapelpre}
\begin{chapel}
for i in (1..5, 3..) do
  write(i, "; ");
\end{chapel}
\begin{chapelpost}
writeln();
\end{chapelpost}
\begin{chapeloutput}
(1, 3); (2, 4); (3, 5); (4, 6); (5, 7); 
\end{chapeloutput}
produces the output ``(1, 3); (2, 4); (3, 5); (4, 6); (5, 7); ''.
\end{example}

It is an error to iterate over a \chpl{BoundedRangeType.boundedNone} range,
a \chpl{BoundedRangeType.boundedLow} range with negative stride or a
\chpl{BoundedRangeType.boundedHigh} range with positive stride.

Unbounded ranges can also be used to index into ranges, domains,
arrays, and strings.  In these cases, omitted bounds are inherited
from the bounds of the expression being indexed.


\subsection{Range Assignment}
\label{Range_Assignment}
\index{ranges!assignment}

Assigning one range to another results in its low, high, and stride
values being copied from the source range to the destination range.

In order for range assignment to be legal, the element type of the
source range must be implicitly coercible to the element type of the
destination range.  The two range types must have the same boundedness
parameter.  It is legal to assign a non-stridable range to a stridable
range, but illegal to assign a stridable range to a non-stridable
range unless the stridable range has a stride value of 1.


\subsection{Range Operators}
\label{Range_Operators}
\index{ranges!operators}

\subsubsection{By Operator}
\label{By_Operator_For_Ranges}
\index{ranges!strided}
\index{ranges!by operator}
\index{by@\chpl{by}}

The \chpl{by} operator can be applied to any range to create a strided
range.

The \chpl{by} operator takes a range and an integer value to yield a
new range that is strided by the integer.  Striding a strided range
results in a stride whose value is the product of the two strides.
The stride argument can either be of type \chpl{idxType} or some other
integer value that can be coerced to a signed integer value of the same
bit-width as \chpl{idxType}.

\begin{example}
In the following declarations, range \chpl{r1} represents the odd integers
between 1 and 20. Range \chpl{r2} strides \chpl{r1} by two and represents
every other odd integer between 1 and 20: 1, 5, 9, ...
\begin{chapelpre}
% test_rangeByOperator.chpl
\end{chapelpre}
\begin{chapel}
var r1 = 1..20 by 2;
var r2 = r1 by 2;
\end{chapel}
\begin{chapelpost}
writeln(r1);
writeln(r2);
\end{chapelpost}
\begin{chapeloutput}
1..20 by 2
1..20 by 4
\end{chapeloutput}
\end{example}

\begin{rationale}
{\it Why isn't the high bound specified first if the stride is
negative?}  The reason for this choice is that the \chpl{by} operator
is binary, not ternary.  Given a range \chpl{R} initialized
to \chpl{1..3}, we want \chpl{R by -1} to contain the ordered sequence
$3,2,1$.  But then \chpl{R by -1} would be different from \chpl{3..1
by -1} even though it should be identical by substituting the value in
R into the expression.
\end{rationale}

\subsubsection{Count Operator}
\label{Count_Operator}
\index{ranges!count operator}

The \chpl{#} operator can be applied to a range that has a high bound,
a low bound, or both.

The \chpl{#} operator takes a range and an integral count and creates
a new range with \emph{count} elements. The stride of the resulting range is
the same as that of the initial range. It is an error for the count to
be negative.  The \emph{idxType} of the resulting range is the same
type that would be obtained by adding the integral count value to a value
with the range's \emph{idxType}.

When applied to a \chpl{BoundedRangeType.bounded} range with a positive
stride, \emph{count} elements are taken starting from the low
bound. When the stride is negative, \emph{count} elements are taken
starting from the high bound. It is an error for \emph{count} to be larger
than the length of the range.

When applied to a \chpl{BoundedRangeType.boundedLow} range, the low bound
is fixed and and the high bound is set based on the count and the
absolute value of the stride.

When applied to a \chpl{BoundedRangeType.boundedHigh} range, the high
bound is fixed and the low bound is set based on the count and the
absolute value of the stride.

It is an error to apply the count operator to a
\chpl{BoundedRangeType.boundedNone} range.

\begin{example}
The following declarations result in equivalent ranges.
\begin{chapelpre}
% test_rangeCountOperator.chpl
\end{chapelpre}
\begin{chapel}
var r1 = 2.. by -2 # 3;
var r2 = ..6 by -2 # 3;
var r3 = 0..6 by -2 # 3;
var r4 = 2..#5 by -2;
\end{chapel}
\begin{chapelpost}
writeln(r1 == r2 \&\& r2 == r3 \&\& r3 == r4);
writeln((r1, r2, r3, r4));
\end{chapelpost}
\begin{chapeloutput}
true
(2..6 by -2, 2..6 by -2, 2..6 by -2, 2..6 by -2)
\end{chapeloutput}
Each of these ranges represents the ordered set of three values: 6, 4, 2.
\end{example}

\subsubsection{Arithmetic Operators}
\label{Range_Arithmetic}
\index{ranges!arithmetic operators}

The following arithmetic operators are defined on ranges and integral
types:

\begin{chapel}
proc +(r: range, s: integral): range
proc +(s: integral, r: range): range
proc -(r: range, s: integral): range
\end{chapel}

The \chpl{+} and \chpl{-} operators apply the scalar via the operator
to the range's low and high bounds, producing a shifted version of the
range.  The element type of the resulting range is the type of the value
that would result from an addition between the scalar value and a value
with the range's element type.  The bounded and stridable parameters for
the result range are the same as for the input range.

\begin{example}
The following code creates a bounded, non-stridable range \chpl{r}
which has an element type of \chpl{int} representing the values ${0,
  1, 2, 3}$.  It then uses the \chpl{+} operator to
create a second range \chpl{r2} representing the values ${1, 2, 3,
  4}$.  The \chpl{r2} range is bounded, non-stridable, and represents
values of type \chpl{int}.
\begin{chapelpre}
% test_rangeAdd.chpl
\end{chapelpre}
\begin{chapel}
var r = 0..3;
var r2 = r + 1;
\end{chapel}
\begin{chapelpost}
writeln((r, r2));
\end{chapelpost}
\begin{chapeloutput}
(0..3, 1..4)
\end{chapeloutput}
\end{example}


\subsubsection{Range Slicing}
\label{Range_Slicing}
\index{ranges!slicing}

Ranges can be \emph{sliced} using other ranges to create new
sub-ranges.  The resulting range represents the intersection between
the two ranges.  Range slicing is defined by using the range as a
function in a call expression where the argument is another range.
If the slicing range is unbounded in one or both directions, it
inherits its missing bounds from the range being sliced.

\begin{example}
In the following example, \chpl{r} represents the integers from 1 to
20 inclusive.  Ranges \chpl{r2} and \chpl{r3} are defined using range
slices and represent the indices from 3 to 20 and the odd integers
between 1 and 20 respectively. Range \chpl{r4} represents the odd
integers between 1 and 20 that are also divisible by 3.
\begin{chapelpre}
% test_rangeSlicing.chpl
\end{chapelpre}
\begin{chapel}
var r = 1..20;
var r2 = r[3..];
var r3 = r[1.. by 2];
var r4 = r3[0.. by 3];
\end{chapel}
\begin{chapelpost}
writeln((r, r2, r3, r4));
\end{chapelpost}
\begin{chapeloutput}
(1..20, 3..20, 1..20 by 2, 3..20 by 6)
\end{chapeloutput}
\end{example}

\subsection{Predefined Functions and Methods on Ranges}
\index{ranges!predefined functions}
\begin{protohead}
proc $range$.idxType type
\end{protohead}
\begin{protobody}
Returns the index type of the range.
\end{protobody}

\begin{protohead}
proc $range$.stridable type
\end{protohead}
\begin{protobody}
Returns true if the range is stridable, false otherwise.
\end{protobody}

\begin{protohead}
proc $range$.boundedType type
\end{protohead}
\begin{protobody}
Returns boundedType of the range.
\end{protobody}

\begin{protohead}
proc $range$.low : idxType
\end{protohead}
\begin{protobody}
Returns the low bound of the range.
\end{protobody}

\begin{protohead}
proc $range$.high : idxType
\end{protohead}
\begin{protobody}
Returns the high bound of the range.
\end{protobody}

\begin{protohead}
proc $range$.alignedLow : idxType
\end{protohead}
\begin{protobody}
Returns the aligned low bound of the range.  If the stride is less than -1, the
aligned low bound may be greater than the declared low bound.
\end{protobody}

\begin{protohead}
proc $range$.alignedHigh : idxType
\end{protohead}
\begin{protobody}
Returns the aligned high bound of the range.  If the stride is greater than 1,
the aligned high bound may be greater than the declared high bound.
\end{protobody}
\begin{example}
The following code:
\begin{chapelpre}
% alignedHigh.chpl
\end{chapelpre}
\begin{chapel}
var r = 0..20 by 3;
writeln(r.alignedHigh);
\end{chapel}
\begin{chapeloutput}
18
\end{chapeloutput}
produces the output ``18''.
\end{example}

\begin{protohead}
proc $range$.first : idxType
\end{protohead}
\begin{protobody}
Returns the first index in the range.  If the stride is positive, the 
\chpl{low} value is returned; otherwise, the \chpl{high} value is returned.
\end{protobody}

\begin{protohead}
proc $range$.last : idxType
\end{protohead}
\begin{protobody}
Returns the last index within the range.  In general, this is given
by \chpl{start + length * stride}.
\end{protobody}

\begin{protohead}
proc $range$.stride : int(numBits(idxType))
\end{protohead}
\begin{protobody}
Returns the stride of the range.
\end{protobody}

\begin{protohead}
proc $range$.length : idxType
\end{protohead}
\begin{protobody}
Returns the number of elements in the range.
\end{protobody}

\begin{protohead}
proc $range$.member(i: idxType): bool
\end{protohead}
\begin{protobody}
Returns whether or not \chpl{i} is in the range.
\end{protobody}

\begin{protohead}
proc $range$.member(other: range): bool
\end{protohead}
\begin{protobody}
Returns whether or not every element in other is also in this.
\end{protobody}

\begin{protohead}
proc $range$.indexOrder(i: idxType): idxType
\end{protohead}
\begin{protobody}
If \chpl{i} is a member of the range, returns an integer giving
the ordinal value of \chpl{i} within the range using 0-based indexing.
Otherwise, it returns \chpl{(-1):idxType}.
\end{protobody}

\begin{example}
The following calls show the order of index 4 in each of the given
ranges:
\begin{chapel}
(0..10).indexOrder(4) == 4
(1..10).indexOrder(4) == 3
(3..5).indexOrder(4) == 1
(0..10 by 2).indexOrder(4) == 2
(3..5 by 2).indexOrder(4) == -1
\end{chapel}
\end{example}
