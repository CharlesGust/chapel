\sekshun{Ranges}
\label{Ranges}
\index{ranges}

Ranges represent a sequence of integer indices.  Ranges have an integral base
type, are either \emph{bounded} or \emph{unbounded} and are \emph{stridable} or not.
Unbounded ranges are those in which the low and/or high bound is
omitted.  
If a range is stridable, it may have a stride and an
alignment.  The stride is the difference between neighboring indices; the
alignment determines the starting index as described below.  If a range is not
stridable, its stride $1$ and its alignment is $0$.

All ranges are characterized by a low bound~$l$, a high bound~$h$, stride~$s$
and alignment~$a$.  When the range is strided, different alignments describe
distinct ranges.  For example if the stride is 2, then an alignment of 0 means
that the sequence contains only even numbers while an alignment of 1 means that the
sequence contains only odd numbers.  The \emph{aligned low bound} $b$ is the first
index greater than or equal to $l$ that matches the alignment.  That
is, $b$ is the lowest index such that $b \geq l, b\!\mod |s| = a\!\mod |s|$.  Similarly,
the aligned high bound $e$ is the highest index such that $e \leq h, e\!\mod |s| =
a\!\mod |s|$.

If the stride is positive, the indices
described by the range are $b, b+s, b+2s, b+3s, ...$ where all of the
indices are less than or equal to $h$.  If the stride is negative, the indices
described by the range are $e, e+s, e+2s, e+3s, ...$ where all of the
indices are greater than or equal to $l$.  
If $l > h$, the range is considered
degenerate and represents an empty sequence. 

Ranges support iteration over the
indices they represent as described in ~\rsec{The_For_Loop}.


\section{Range Types}
\label{Range_Types}
\index{ranges!types}

The type of a range is characterized by three things:
\begin{enumerate}
\item the type of the indices being represented, 
\item the boundedness of the range,
\item whether or not the range is \emph{stridable}.
\end{enumerate}

In a range, the type of the low bound, the high bound and the alignment are
determined by the type parameter \emph{idxType}.
This must be one of the \chpl{int} or
\chpl{uint} types.  The default type is \chpl{int}.
The type of a range's stride is the signed equivalent of its \emph{idxType}.

%% I'm hiding this.  Users can yelp if they want ranges on reals. (hilde 2011/03/22)
%%\begin{openissue}
%%It has been hypothesized that ranges of other types, such as floating
%%point values, might also be of interest to represent a range of legal
%%tolerances, for example.  If you believe such support would be of
%%interest to you, please let us know.
%%\end{openissue}

The boundedness of the range is represented using an enumerated
parameter named \emph{boundedType} of type \chpl{BoundedRangeType}.
Legal values are \chpl{bounded}, \chpl{boundedLow},
\chpl{boundedHigh}, and \chpl{boundedNone}.  
\begin{chapel}
enum BoundedRangeType { bounded, boundedLow, boundedHigh, boundedNone };
\end{chapel}
\noindent
The first value specifies
a bounded range while the other three values specify a range in which
the high bound is omitted, the low bound is omitted, or both bounds
are omitted, respectively.  The default value is \chpl{bounded}.

The stridability of a range is represented by a boolean parameter
named \emph{stridable}.  If this parameter is set to \chpl{true}, the range's
stride can take on any signed integer value other than 0 of the same
bit-width as \chpl{idxType}.  If set to \chpl{false}, the range's stride is
fixed to 1.  The default value is \chpl{false}.

If \chpl{stridable} is set to \chpl{true}, the alignment value can also be set.
It can take on any integer value representable by
the \emph{idxType}.  For a given alignment $a$ and stride $s$, each index $i$
in the range's sequence obeys the relation $i \!\mod |s| = a \!\mod |s|$.  

\begin{rationale}
The \emph{boundedType} and \emph{stridable} parameters are used
to optimize the generated code for common cases of ranges, as well as
to optimize the implementation of domains and arrays defined using ranges.
\end{rationale}

The syntax of a range type is summarized as follows:
\begin{syntax}
range-type:
  `range' ( named-expression-list )
\end{syntax}
\noindent The \sntx{named-expression-list} contains any combination of
  the \chpl{idxType}, \chpl{boundedType} and \chpl{stridable} parameters.

\begin{example}
The following declaration declares a variable \chpl{r}
of range type that can represent ranges of 64-bit integers, with both
high and low bounds specified, the ability to have a stride other
than 1 and an alignment other than zero.
\begin{chapelpre}
% rangeVariable.chpl
\end{chapelpre}
\begin{chapel}
var r: range(int(64), BoundedRangeType.bounded, stridable=true);
\end{chapel}
\begin{chapelpost}
writeln(r);
var i64: int(64) = 3;
r = i64..13 by 3 align 1;
writeln(r);
\end{chapelpost}
\begin{chapeloutput}
1..0
3..13 by 3 align 1
\end{chapeloutput}
\end{example}

\section{Range Fields and Accessors}
\label{Range_Fields}
\index{ranges!fields}

The fields in a range are given by:
\begin{itemize}
\item[\chpl{low}] the low bound,
\item[\chpl{high}] the high bound,
\item[\chpl{stride}] the stride, and
\item[\chpl{alignment}] the alignment.
\end{itemize}
These fields are always valid, regardless of the choice of \chpl{boundedType}
and \chpl{stridable} parameters.  However, certain cases are interpreted
specially.  If the low bound exceeds the high bound, the range is degenerate: It contains no
indices.  If the range has no \chpl{start} value\footnote{The \chpl{hasFirst}
and \chpl{hasLast} predicates can be used to determine if a range possesses the
corresponding limits.}, then it cannot be iterated
upon, nor can it be used with the count (\chpl{\#}) operator.

The default value for a range is \chpl{1..0}, which is equivalent to \chpl{low}, \chpl{high}, \chpl{stride}
and \chpl{alignment} values of 1, 0, 1 and 1, respectively.

Depending on how the \chpl{stride} and \chpl{alignment} fields are set,
the \chpl{low} and \chpl{high} values will not necessarily appear in the
sequence generated by it (see~\rsec{The_For_Loop}).  Use the
accessors \chpl{alignedLow} and \chpl{alignedHigh} to obtain the actual low and
high values appearing in the sequence.  The accessors \chpl{first} and \chpl{last} provide
the first and last indices in the sequence, regardless whether the stride is
positive or negative.  

A range is \emph{naturally aligned} if its alignment coincides with its low or
high bound.  Specifically, a range with \chpl{low}, \chpl{high}, \chpl{stride}
and \chpl{alignment} values of $l$, $h$, $s$ and $a$ (respectively) is naturally aligned if:
\begin{itemize}
\item It is \chpl{bounded}, its stride is positive, and $a\!\mod |s| = l\!\mod s$,
\item It is \chpl{bounded}, its stride is negative, and $a\!\mod |s| = h\!\mod s$,
\item It is \chpl{boundedLow} and $a\!\mod |s| = l\!\mod s$,
\item It is \chpl{boundedHigh} and $a\!\mod |s| = h\!\mod s$, or
\item It is $boundedNone$ and $a = 0$.
\end{itemize}
\noindent The \chpl{isAligned} predicate returns \chpl{true} when the operand
range is naturally aligned.  When a range is formatted for output, the alignment
is printed only if the range is not naturally aligned.

\section{Literal Range Values}
\label{Range_Literals}
\index{ranges!literals} 

Range literals are specified as follows:
\begin{syntax}
range-literal:
  bounded-range-literal
  unbounded-range-literal
\end{syntax}

\subsection{Bounded Range Literals}
\label{Bounded_Ranges}
\index{ranges!bounded}

A bounded range is specified by the syntax
\begin{syntax}
bounded-range-literal:
  expression .. expression
\end{syntax}
The first expression is taken to be the lower bound $l$ and the second
expression is taken to be the upper bound $h$.  The stride of the
range is 1 and can be modified using the \chpl{by} operator as described
in~\rsec{By_Operator_For_Ranges}.  

\index{ranges!integral index type}
The index type of the range type is determined by the type of the
low and high bound.  It is either \chpl{int}, \chpl{uint},
\chpl{int(64)}, or \chpl{uint(64)}.  The index type of the range is obtained by
applying integral promotions to the low and high bounds.  The boundedness
of such a range is \chpl{bounded}.  The stridability of a range literal
is \chpl{false}.

\subsection{Unbounded Range Literals}
\label{Unbounded_Ranges}
\index{ranges!unbounded}

An unbounded range is specified by the syntax
\begin{syntax}
unbounded-range-literal:
  expression ..
  .. expression
  ..
\end{syntax}

The first form results in a \chpl{boundedLow} range, the
second in a \chpl{boundedHigh} range, and the third in
a \chpl{boundedNone} range.  If a bound is given, the index type and alignment are determined
by that bound.

When used in zippered iteration (~\rsec{Zipper_Iteration}), the shape of an
unbounded range conforms to that of the other iterator.

\begin{example}
The code
\begin{chapelpre}
% zipWithUnbounded.chpl
\end{chapelpre}
\begin{chapel}
for i in (1..5, 3..) do
  write(i, "; ");
\end{chapel}
\begin{chapelpost}
writeln();
\end{chapelpost}
\begin{chapeloutput}
(1, 3); (2, 4); (3, 5); (4, 6); (5, 7); 
\end{chapeloutput}
produces the output ``(1, 3); (2, 4); (3, 5); (4, 6); (5, 7); ''.
\end{example}

It is an error to iterate over a \chpl{boundedNone} range,
a \chpl{boundedLow} range with negative stride or a
\chpl{boundedHigh} range with positive stride.

Unbounded ranges can also be used to index into ranges, domains,
arrays, and strings.  In these cases, omitted bounds are inherited
from the bounds of the expression being indexed.


\section{Range Assignment}
\label{Range_Assignment}
\index{ranges!assignment}

Assigning one range to another results in its low, high, stride and alignment
values being copied from the source range to the destination range.

In order for range assignment to be legal, the index type of the
source range must be implicitly coercible to the index type of the
destination range, and the two range types must have the same boundedness
parameter.  It is legal to assign a non-stridable range to a stridable
range, but illegal to assign a stridable range to a non-stridable
range unless the stridable range has a stride of 1.


\section{Range Operators}
\label{Range_Operators}
\index{ranges!operators}

Operations can be applied to range literals and expressions of range type to
derive new range values.  The stride and alignment operators \chpl{by}
and \chpl{align} have special syntax.  Otherwise, they follow the standard
expression or function-call syntax.
\begin{syntax}
range-expression:
  expression
  strided-range-expression
  counted-range-expression
  aligned-range-expression
  sliced-range-expression
\end{syntax}

Range operators are discussed in detail in the following subsections.

\subsection{By Operator}
\label{By_Operator_For_Ranges}
\index{ranges!strided}
\index{ranges!by operator}
\index{by@\chpl{by}}

The \chpl{by} operator can be applied to any range to create a strided
range.  Its syntax is given by:
\begin{syntax}
strided-range-expression:
  range-expression `by' expression
\end{syntax}

The \chpl{by} operator takes a range and an integer value to yield a
new range that is strided by the integer.  Striding a strided range
results in a stride whose value is the product of the two strides.
The stride argument can either be of type \chpl{idxType} or some other
integer value that can be coerced to a signed integer value of the same
bit-width as \chpl{idxType}.  

The resulting range has the same \chpl{idxType} and \chpl{boundedType} as the
operand range, but has its \chpl{stridable} parameter set to \chpl{true}.
The low and high bounds of the operand range are preserved in the result.
The alignment of the new range depends on the \chpl{boundedType} of the range
and the sign of the resulting stride, as follows:
\begin{itemize}
\item If the range is \chpl{bounded} or \chpl{boundedLow} and  the resulting stride is positive, the new range is aligned on
the \chpl{alignedLow} value of the operand range.  
\item If the range
is \chpl{bounded} or \chpl{boundedHigh} and  the resulting stride is
negative, it is aligned with respect to the operand's \chpl{alignedHigh} value.
\item Otherwise, it has the same alignment as the operand range.
\end{itemize}

\begin{example}
In the following declarations, range \chpl{r1} represents the odd integers
between 1 and 20. Range \chpl{r2} strides \chpl{r1} by two and represents
every other odd integer between 1 and 20: 1, 5, 9, 13 and 17.
\begin{chapelpre}
% rangeByOperator.chpl
\end{chapelpre}
\begin{chapel}
var r1 = 1..20 by 2;
var r2 = r1 by 2;
\end{chapel}
\begin{chapelpost}
writeln(r1);
writeln(r2);
\end{chapelpost}
\begin{chapeloutput}
1..20 by 2
1..20 by 4
\end{chapeloutput}
\end{example}

\begin{rationale}
{\it Why isn't the high bound specified first if the stride is
negative?}  The reason for this choice is that the \chpl{by} operator
is binary, not ternary.  Given a range \chpl{R} initialized
to \chpl{1..3}, we want \chpl{R by -1} to contain the ordered sequence
$3,2,1$.  But then \chpl{R by -1} would be different from \chpl{3..1
by -1} even though it should be identical by substituting the value in
R into the expression.
\end{rationale}


\subsection{Align Operator}
\label{Align_Operator}
\index{ranges!align operator}

The \chpl{align} operator can be applied to any range, and creates a new range
with the given alignment.  An alignment value $a$ applied to a range with stride $s$ causes the indices $i$ produced by an iterator
to obey the equation $i\!\mod |s| = a\!\mod |s|$.

The syntax for the \chpl{align} operator is:
\begin{syntax}
aligned-range-expression:
  range-expression `align' expression
\end{syntax}
\noindent The type of the resulting range expression is the same as that of the
range appearing as the left operand.  The resulting range has the
same \chpl{low}, \chpl{high} and \chpl{stride} fields as the source range. The
alignment is set equal to the \chpl{align} operator's right operand.  The type
of the right operand must be compatible with the index type of the operand range.  

\begin{example}
\begin{chapelpre}
% alignedStride.chpl
\end{chapelpre}
\begin{chapel}
var r1 = 0 .. 10 by 3 align 0;
for i in r1 do
  write(" ", i);			// Produces ``0 3 6 9''.
writeln();

var r2 = 0 .. 10 by 3 align 1;
for i in r2 do
  write(" ", i);			// Produces ``1 4 7 10''.
writeln();
\end{chapel}
\begin{chapeloutput}
 0 3 6 9
 1 4 7 10
\end{chapeloutput}
\end{example}

When the stride is negative, the same indices are printed in reverse:
\begin{example}
\begin{chapelpre}
% alignedNegStride.chpl
\end{chapelpre}
\begin{chapel}
var r3 = 0 .. 10 by -3 align 0;
for i in r3 do
  write(" ", i);			// Produces ``9 6 3 0''.
writeln();

var r4 = 0 .. 10 by -3 align 1;
for i in r4 do
  write(" ", i);			// Produces ``10 7 4 1''.
writeln();
\end{chapel}
\begin{chapeloutput}
 9 6 3 0
 10 7 4 1
\end{chapeloutput}
\end{example}

To align a range relative to its \chpl{start} index, use
the \chpl{offset} method (\rsec{Range_Offset_Method}).


\subsection{Count Operator}
\label{Count_Operator}
\index{ranges!count operator}

The \chpl{#} operator takes a range and an integral count and creates a new
range containing the specified number of indices.  The low or high bound of the
left operand is preserved, and the other bound adjusted to provide the specified
number of indices.  If the count is positive, indices are taken from the start
of the range; if the count is negative, indices are taken from the end of the
range.  The count must be less than or equal to the \chpl{length} of the range.

\begin{syntax}
counted-range-expression:
  range-expression # expression
\end{syntax}

The \emph{idxType} of the resulting range is the same type that would be
obtained by adding the integral count value to a value with the
range's \emph{idxType}.  The stride of the resulting range is the same as that
of the initial range.  The alignment of the resulting range is the same as the
initial range.

Depending on the sign of the count and the stride, the high or low bound is
unchanged and the other bound is adjusted so that it is $c * stride - 1$ units
away.  Specifically:
\begin{itemize}
\item If the count times the stride is positive, the low bound is preserved
and the high bound is adjusted to be one less than the low bound plus that
product.
\item Iff the count times the stride is negative, the high bound is preserved
and the low bound is adjusted to be one greater than the high bound plus that
product.
\end{itemize}

\begin{rationale}
Following the principle of preserving as much information from the original
range as possible, we must still choose the other bound so that
exactly \emph{count} indices lie within the range.  Making the two bounds lie
$count * stride - 1$ apart will achieve this, regardless of the current
alignment of the range.

This choice also has the nice symmetry that the alignment can be adjusted
without knowing the bounds of the original range, and the same number of indices
will be produced:
\begin{chapel}
r # 4 align 0   // Contains four indices.
r # 4 align 1   // Contains four indices.
r # 4 align 2   // Contains four indices.
r # 4 align 3   // Contains four indices.
\end{chapel}
\end{rationale}

It is an error to apply the count operator to a range that
has no starting index.  It is also an error to apply the count operator
with a negative count to a range that has no end index.

\begin{rationale}
The count operator is intended to select indices from an \emph{iteratable}
range.  If the range has no \chpl{start} index, then its membership is
indeterminate.  Therefore, indices taken from the start or the end of the range
are not well-defined.  When the count is negative, indices are taken from the
end of the range.  In that case, the end bound must also be established.
\end{rationale}

\begin{example}
The following declarations result in equivalent ranges.
\begin{chapelpre}
% rangeCountOperator.chpl
\end{chapelpre}
\begin{chapel}
var r1 = 1..10 by -2 # -3;
var r2 = ..6 by -2 # 3;
var r3 = -6..6 by -2 # 3;
var r4 = 1..#6 by -2;
\end{chapel}
\begin{chapelpost}
writeln(r1 == r2 \&\& r2 == r3 \&\& r3 == r4);
writeln((r1, r2, r3, r4));
\end{chapelpost}
\begin{chapeloutput}
true
(1..6 by -2, 1..6 by -2, 1..6 by -2, 1..6 by -2)
\end{chapeloutput}
Each of these ranges represents the ordered set of three indices: 6, 4, 2.
\end{example}

\subsection{Arithmetic Operators}
\label{Range_Arithmetic}
\index{ranges!arithmetic operators}

The following arithmetic operators are defined on ranges and integral
types:

\begin{chapel}
proc +(r: range, s: integral): range
proc +(s: integral, r: range): range
proc -(r: range, s: integral): range
\end{chapel}

The \chpl{+} and \chpl{-} operators apply the scalar via the operator
to the range's low and high bounds, producing a shifted version of the
range.  The index type of the resulting range is the type of the value
that would result from an addition between the scalar value and a value
with the range's index type.  The bounded and stridable parameters for
the result range are the same as for the input range.

The stride of the resulting range is the same as the stride of the
original. The alignment of the resulting range is shifted by the same amount as
the high and low bounds.

\begin{example}
The following code creates a bounded, non-stridable range \chpl{r}
which has an index type of \chpl{int} representing the indices ${0,
  1, 2, 3}$.  It then uses the \chpl{+} operator to
create a second range \chpl{r2} representing the indices ${1, 2, 3,
  4}$.  The \chpl{r2} range is bounded, non-stridable, and is represented by
indices of type \chpl{int}.
\begin{chapelpre}
% rangeAdd.chpl
\end{chapelpre}
\begin{chapel}
var r = 0..3;
var r2 = r + 1;
\end{chapel}
\begin{chapelpost}
writeln((r, r2));
\end{chapelpost}
\begin{chapeloutput}
(0..3, 1..4)
\end{chapeloutput}
\end{example}


\subsection{Range Slicing}
\label{Range_Slicing}
\index{ranges!slicing}

Ranges can be \emph{sliced} using other ranges to create new
sub-ranges.  The resulting range represents the intersection between
the two ranges.  The stride and alignment of the resulting range are adjusted as
needed to make this true.  Range slicing is specified by the syntax:
\begin{syntax}
sliced-range-expression:
  range-expression ( range-expression )
\end{syntax}
\noindent If the slicing range is unbounded in one or both directions, it
inherits its missing bounds from the range being sliced.

\begin{example}
In the following example, \chpl{r} represents the integers from 1 to
20 inclusive.  Ranges \chpl{r2} and \chpl{r3} are defined using range
slices and represent the indices from 3 to 20 and the odd integers
between 1 and 20 respectively. Range \chpl{r4} represents the odd
integers between 1 and 20 that are also divisible by 3.
\begin{chapelpre}
% rangeSlicing.chpl
\end{chapelpre}
\begin{chapel}
var r = 1..20;
var r2 = r[3..];
var r3 = r[1.. by 2];
var r4 = r3[0.. by 3];
\end{chapel}
\begin{chapelpost}
writeln((r, r2, r3, r4));
\end{chapelpost}
\begin{chapeloutput}
(1..20, 3..20, 1..20 by 2, 1..20 by 6 align 3)
\end{chapeloutput}
\end{example}

\section{Predefined Functions and Methods on Ranges}
\index{ranges!predefined functions}

\subsection{Range Type Accessors}

\begin{protohead}
proc $range$.idxType type
\end{protohead}
\begin{protobody}
Returns the index type of the range.  The index type is one
of \chpl{int}, \chpl{uint}, \chpl{int(64)} or \chpl{uint(64)}.
\end{protobody}

\begin{protohead}
proc $range$.boundedType type
\end{protohead}
\begin{protobody}
Returns boundedType of the range.  The boundedType of a range is a member of the
BoundedRangeType enumeration (\rsec{Range_Types}).
\end{protobody}

\begin{protohead}
proc $range$.stridable type
\end{protohead}
\begin{protobody}
Returns \chpl{true} if the range is stridable, \chpl{false} otherwise.  If \chpl{stridable} is
\chpl{false}, the stride is effectively 1 and the alignment is effectively 0.
\end{protobody}

\subsection{Range Field Accessors}

\begin{protohead}
proc $range$.align : idxType
\end{protohead}
\begin{protobody}
Returns the alignment of the indices yielded by an iterator.  Alignments are
relative to 0, not the low or high bound.
\end{protobody}

\begin{protohead}
proc $range$.low : idxType
\end{protohead}
\begin{protobody}
Returns the low bound of the range.
\end{protobody}

\begin{protohead}
proc $range$.high : idxType
\end{protohead}
\begin{protobody}
Returns the high bound of the range.
\end{protobody}

\begin{protohead}
proc $range$.stride : int(numBits(idxType))
\end{protohead}
\begin{protobody}
Returns the stride of the range.  If the stride is negative, indices within the
range are enumerated from highest to lowest.
\end{protobody}

\subsection{Range Predicates}

\begin{protohead}
proc ==(r1: range(?), r2: range(?)): bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if the two ranges produce the same sequence
and \chpl{false} otherwise.  The high and low bounds can differ between the two
ranges, and they will still compare equal as long as the same sequence is
produced by each.
\end{protobody}

\begin{protohead}
proc $range$.boundsCheck(r2: range(?)): bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if range \chpl{r2} lies entirely within this range
and \chpl{false} otherwise.  
\end{protobody}

\begin{protohead}
proc range.ident(r1: range(?), r2: range(?)): bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if the two ranges are the same in every respect: i.e. the
two ranges have the same idxType,
boundedType, stridable, low, high, stride and
align values.
\end{protobody}

\begin{protohead}
proc $range$.hasFirst(): bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if this range has a low bound and a positive stride, or a high
bound and a negative stride.
\end{protobody}

\begin{protohead}
proc $range$.hasLast(): bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if this range has a high bound and a positive stride, or a low
bound and a negative stride.
\end{protobody}

\begin{protohead}
proc $range$.hasLowBound() param: bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if the range is bounded below (\chpl{boundedLow} or \chpl{bounded}).
\end{protobody}

\begin{protohead}
proc $range$.hasHighBound() param: bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if the range is bounded above (\chpl{boundedHigh} or \chpl{bounded}).
\end{protobody}

\begin{protohead}
proc $range$.isAligned() bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if the range is naturally aligned and \chpl{false} otherwise.
Specifically,
\begin{itemize}
\item If the range is \chpl{bounded}, then
\begin{itemize}
\item If the stride is positive and the range is aligned on the low bound,
returns \chpl{true}; otherwise, returns \chpl{false}.
\item If the stride is negative and the range is aligned on the high bound,
returns \chpl{true}; otherwise, returnse \chpl{false}.
\item Otherwise, returns \chpl{false}.
\end{itemize}
\item If the range is \chpl{boundedLow} and the range is aligned on the low
bound, then returns \chpl{true}; otherwise, returns \chpl{false}.
\item If the range is \chpl{boundedHigh} and the range is aligned on the high
bound, then returns \chpl{true}; otherwise, returns \chpl{false}.
\item If the range is \chpl{boundedNone} and the alignment is 0, returns \chpl{true};
otherwise, returns \chpl{false}.
\end{itemize}
\end{protobody}

\begin{protohead}
proc $range$.member(i: idxType): bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if \chpl{i} is in the range; \chpl{false} otherwise.
\end{protobody}

\begin{protohead}
proc $range$.member(other: range): bool
\end{protohead}
\begin{protobody}
Returns \chpl{true} if every index in \chpl{other} is also in \chpl{this}, \chpl{false} otherwise.
\end{protobody}

\subsection{Other Range Methods}

\begin{protohead}
proc $range$.alignedLow : idxType
\end{protohead}
\begin{protobody}
Returns the aligned low bound of the range.  
The aligned low bound is the first
index in the range greater than or equal to the low bound that is
aligned relative to the stored \chpl{stride} and \chpl{alignment} values.  That
is, if the low bound, stride and alignment are $l$, $s$ and $a$ respectively,
the aligned low bound $b$ is the lowest index such that $b \geq l, b\!\mod |s| =
a\!\mod |s|$.
\end{protobody}

\begin{protohead}
proc $range$.alignLow()
\end{protohead}
\begin{protobody}
Sets the alignment of a range to its low bound.
\end{protobody}

\begin{protohead}
proc $range$.alignedHigh : idxType
\end{protohead}
\begin{protobody}
Returns the aligned high bound of the range.  
The aligned high bound is the first
index in the range less than or equal to the high bound that is
aligned relative to the stored \chpl{stride} and \chpl{alignment} values.  That
is, if the high bound, stride and alignment are $h$, $s$ and $a$ respectively,
the aligned high bound $e$ is the highest index such that $e \leq h, e\!\mod |s| =
a\!\mod |s|$.
\end{protobody}
\begin{example}
The following code:
\begin{chapelpre}
% alignedHigh.chpl
\end{chapelpre}
\begin{chapel}
var r = 0..20 by 3;
writeln(r.alignedHigh);
\end{chapel}
\begin{chapeloutput}
18
\end{chapeloutput}
produces the output ``18''.
\end{example}

\begin{protohead}
proc $range$.alignHigh()
\end{protohead}
\begin{protobody}
Sets the alignment of this range to its high bound.
\end{protobody}

\begin{protohead}
proc $range$.first : idxType
\end{protohead}
\begin{protobody}
Returns the first index in the range.  If the stride is positive,
\chpl{alignedLow} is returned; otherwise, \chpl{alignedHigh} is returned.
\end{protobody}

\begin{protohead}
proc $range$.indexOrder(i: idxType): idxType
\end{protohead}
\begin{protobody}
If \chpl{i} is a member of the range, returns an integer giving
the ordinal index of \chpl{i} within the range using 0-based indexing.
Otherwise, returns \chpl{(-1):idxType}.
\end{protobody}

\begin{example}
The following calls show the order of index 4 in each of the given
ranges:
\begin{chapel}
(0..10).indexOrder(4) == 4
(1..10).indexOrder(4) == 3
(3..5).indexOrder(4) == 1
(0..10 by 2).indexOrder(4) == 2
(3..5 by 2).indexOrder(4) == -1
\end{chapel}
\end{example}
\begin{protohead}

proc $range$.last : idxType
\end{protohead}
\begin{protobody}
Returns the last index within the range.  In general, this is given
by \chpl{start + length * stride}.
\end{protobody}

\begin{protohead}
proc $range$.length : idxType
\end{protohead}
\begin{protobody}
Returns the number of indices in the range.
\end{protobody}

\label{Range_Offset_Method}
\begin{protohead}
proc $range$.offset(n: idxType)
\end{protohead}
\begin{protobody}
Sets the \chpl{align} field such that indices produced by the iterator are
aligned with \chpl{start + n}.  If the range has no start value (as determined
by the \chpl{hasStart} predicate), then a run-time error occurs.
\end{protobody}

\begin{protohead}
proc $range$.translate(i: integral)
\end{protohead}
\begin{protobody}
Returns a new range with its \chpl{low}, \chpl{high} and \chpl{alignment} values
adjusted by $i$.
\end{protobody}

\begin{protohead}
proc $range$.interior(i: idxType)
\end{protohead}
\begin{protobody}
Returns a new range containing the indices just inside the low or high bound of
the range (low if $i < 0$ and high otherwise).
This differs from the behavior of the count operator, in that \chpl{interior()}
preserves the alignment, and it uses the low and high bounds rather
than \chpl{first} and \chpl{last} to establish the bounds of the resulting range.
\end{protobody}

\begin{protohead}
proc $range$.exterior(i: idxType)
\end{protohead}
\begin{protobody}
Returns a new range containing the indices just outside the low or high bound of
the range (low if $i < 0$ and high otherwise).  The stride and alignment of the
original range are preserved.
\end{protobody}

\begin{protohead}
proc $range$.expand(i: idxType)
\end{protohead}
\begin{protobody}
Returns a new range whose bounds are extended by $i$ units on each end.  If $i <
0$ then the resulting range is contracted by its absolute value.
The stride and alignment of the original range are preserved.
\end{protobody}

\begin{protohead}
\end{protohead}
\begin{protobody}
\end{protobody}

\section{Quick Reference}

The following table contains a examples which provide a quick reference for the
syntax and semantics of ranges.  To describe the semantics precisely, we use the
tuple notation $(l, h, s, a)$ in which $l$ is the low bound, $h$ is the high
bound, $s$ is the stride and $a$ is the alignment.  The range $r = (l, h, s, a)$
produces indices in the set.
\begin{equation}
r = (l, h, s, a) \rightarrow \{i | l \le i \le h, i\!\mod |s| = a\!\mod |s|\}.
\end{equation}
\noindent If the stride is positive, indices in this set are enumerated from lowest to
highest; if the stride is negative, indices in this set are enumerated from
highest to lowest.  

In each line in the table, we assume that the input range has the
standard form $(l, h, s, a)$.  The resulting range is relative to the input
range.  For convenience, we use $b$ to denote the first index in sequence
produced by the input range, and $e$ to denote the last index, as defined in
the introduction above.

\begin{tabular}{|l|l|l|l|}
\hline
Range Syntax & Semantics & Example & Sequence \\ \hline
.. & $(-\inf,\inf,1,0)$ & .. & $\ldots$ -2 -1 0 1 2 $\ldots$ \\
$l$.. & $(l,\inf,1,0)$ & 1.. & 1 2 3 $\dots$ \\
..h &  $(-inf,h,1,0)$ & ..5 & $\ldots$ 3 4 5 \\
$l$..h & $(l,h,1,0)$ & 1..5 & 1 2 3 4 5 \\
r by s, $s > 0$ & $(l,h,s,b)$ & 0..10 by 3 & 0 3 6 9 \\
r by s, $s < 0$ & $(l,h,s,b)$ & 0..10 by -3 & 10 7 4 1 \\
r align a & $(l,h,s,a)$ & 0..10 by 3 align 1 & 1 4 7 10 \\
r.offset(d) & $(l,h,s,l+d)$ & (10..20 by 3).offset(-1) & 12 15 18 \\
(..$h$).offset(d) & $(-\inf,h,s,h+d)$ & (..20 by 3).offset(1) & $\ldots$ 13 16 19 \\
(..).offset(d) & \emph{undefined} & (.. by 5).offset(1) & error \\
r \# c, $s > 0, c > 0$ & $(l, l - 1 + c * s, s, b)$ & 0..20 by 3 \# 4 & 0 3 6 9 \\
r \# c, $s > 0, c < 0$ & $(h + 1 - c * s, e, s, e)$ & 0..20 by 3 \# -4 & 9 12 15 18 \\
r \# c, $s < 0, c > 0$ & $(h + 1 + c * s, e, s, e)$ & 0..20 by -3 \# 4 & 20 17 14 11 \\
r \# c, $s < 0, c < 0$ & $(l, l - 1 - c * s, s, b)$ & 0..20 by -3 \# -4 & 11 8 5 2 \\
r + i & $(l + i, h + i, s, a + i)$ & (1..10 by 3) + 1 & 2 5 8 11 \\
r - i & $(l - i, h - i, s, a - i)$ & (1..10 by 3) - 2 & -1 2 5 8 \\
r1(r2) & $(\max(l_1, l_2), \min(h_1, h_2), s', a')$ & (1.. by 3)(..20 by 2) & 4 10 16 \\
r.interior(i), $i < 0$ & $(l, l - (1-i), s, a)$ & (0..20).interior(-3) & 0 1 2 \\
r.interior(i), $i > 0$ & $(h, h + (1-i), s, a)$ & (0..20).interior(3) & 18 19 20 \\
r.exterior(i), $i < 0$ & $(l - i, l - 1, s, a)$ & (0..20).exterior(-3) & -3 -2 -1 \\
r.exterior(i), $i > 0$ & $(h + 1, h + i, s, a)$ & (0..20).exterior(3) & 21 22 23 \\
r.expand(i) & $(l - i, h + i, s, a)$ & (1..3).expand(1) & 0 1 2 3 4 \\
\hline
\end{tabular}

\noindent where $s' = s_1 * s_2 /\gcd(s_1,s_2)$ and $a'$ is chosen such that the indices common to both ranges are selected.
