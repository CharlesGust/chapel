\sekshun{Standard Distributions}
\label{Standard_Distributions}

The following table lists distributions standard to the Chapel
language:
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
{\bf Distribution} & {\bf Module} & {\bf Supported Domain Types} \\
\hline
\chpl{Block} & \chpl{BlockDist} & Arithmetic \\
\chpl{Cyclic} & \chpl{CyclicDist} & Arithmetic \\
\hline
\end{tabular}
\end{center}

\begin{rationale}
Why supply any standard distributions?  A main design goal of Chapel
requires that the standard distributions be defined using the same
mechanisms available to Chapel programmers wishing to define their own
distributions or layouts~(\rsec{User_Defined_Domain_Maps}).  That way
there shouldn't be a necessary performance cost associated with
user-defined domain maps.  Nevertheless, distributions are an integral
part of the Chapel language which would feel incomplete without a good
set of standard distributions.  It is hoped that many distributions
will begin as user-defined domain maps and later become part of the
standard set of distributions.
\end{rationale}

\subsection{The Standard Block Distribution}
\label{Block_Dist}

The standard Block distribution, defined in the
module \chpl{BlockDist}, maps indices to locales by partitioning the
indices into blocks according to a \emph{bounding box} argument.  It
is parameterized by the rank and index type of the domains it
supports.  Thus domains of different ranks or different index types
must be distributed with different Block distributions.

For Block distributions of rank $d$, given a bounding box
\begin{chapel}
[$l_1$..$h_1$, $\ldots$, $l_d$..$h_d$]
\end{chapel}
and an array of target locales defined over the domain
\begin{chapel}
[$0$..$n_1$-1, $\ldots$, $0$..$n_d-1$]
\end{chapel}
then a Block distribution maps an index $i$ to a locale by computing
the $k$\emph{th} component of an index $j$ into the array of target
locales from the $k$\emph{th} component of $i$ using the following
formula:
\[
j_k = \left\{
  \begin{array}{ll}
    0 & \mbox{if $i_k < l_k$} \\
    \left\lfloor\dfrac{n_k (i_k - l_k)}{h_k - l_k + 1}\right\rfloor & \mbox{if $i_k \geq l_k$ and $i_k \leq h_k$} \\
    n_k-1 & \mbox{if $i_k > h_k$} \\
  \end{array}
\right.
\]

The Block class constructor is defined as follows:
\begin{chapel}
def Block(boundingBox: domain,
          targetLocales: [] locale = Locales, 
          dataParTasksPerLocale = $\mbox{{\it value in global config const of the same name}}$,
          dataParIgnoreRunningTasks = $\mbox{{\it value in global config const of the same name}}$,
          dataParMinGranularity = $\mbox{{\it value in global config const of the same name}}$,
          param rank = boundingBox.rank,
          type idxType = boundingBox.dim(1).eltType)
\end{chapel}

The argument \chpl{boundingBox} is a non-distributed domain defining a
bounding box used to partition the space of all indices across an
array of target locales.

The argument \chpl{targetLocales} is a non-distributed array
containing the target locales to which this distribution maps indices
and data.  The rank of \chpl{targetLocales} must match the rank of the
distribution, or be one.  If the rank of
\chpl{targetLocales} is one, a greedy heuristic is used to reshape the
array of target locales so that it matches the rank of the
distribution and each dimension contains an approximately equal number
of indices.

The
arguments \chpl{dataParTasksPerLocale}, \chpl{dataParIgnoreRunningTasks},
and \chpl{dataParMinGranularity} set the knobs that are used to
control intra-locale data parallelism for Block-distributed domains
and arrays in the same way that the global configuration constants of
these names control data parallelism for ranges and
default-distributed domains and arrays~\rsec{data_parallel_knobs}.

The \chpl{rank} and \chpl{idxType} arguments are inferred from the
\chpl{boundingBox} argument unless explicitly set.

\begin{example}
The following code declares a Block distribution with a bounding box
equal to the domain \chpl{Space} and declares an array, \chpl{A}, over
a domain declared over this distribution.  The computation in
the \chpl{forall} loop sets each array element to the ID of the locale
to which it is mapped.
\begin{chapel}
use BlockDist;

const Space = [1..8, 1..8];
const D: domain(2) dmapped Block(boundingBox=Space) = Space;
var A: [D] int;

forall a in A do
  a = a.locale.id;

writeln(A);
\end{chapel}
When run on 6 locales, the output is:
\begin{chapel}
0 0 0 0 1 1 1 1
0 0 0 0 1 1 1 1
0 0 0 0 1 1 1 1
2 2 2 2 3 3 3 3
2 2 2 2 3 3 3 3
2 2 2 2 3 3 3 3
4 4 4 4 5 5 5 5
4 4 4 4 5 5 5 5
\end{chapel}
\end{example}

\subsection{The Standard Cyclic Distribution}
\label{Cyclic_Dist}
The standard Cyclic distribution, defined in the
module \chpl{CyclicDist}, maps indices to locales in a round-robin
pattern according to a \emph{start index} argument.  It is
parameterized by the rank and index type of the domains it supports.
Thus domains of different ranks or different index types must be
distributed with different Cyclic distributions.

For cyclic distributions of rank $d$, given a start index
\begin{chapel}
($s_1$, $\ldots$, $s_d$)
\end{chapel}
and an array of target locales defined over the domain
\begin{chapel}
[$0$..$n_1$-1, $\ldots$, $0$..$n_d$-1]
\end{chapel}
then a Cyclic distribution maps an index $i$ to a locale by computing
the $k$\emph{th} component of an index $j$ into the array of target
locales from the $k$\emph{th} component of $i$ using the following
formula:
\[j_k = i_k - s_k \pmod{n_k}\]

The Cyclic class constructor is defined as follows:
\begin{chapel}
def Cyclic(startIdx,
           targetLocales: [] locale = Locales,
           dataParTasksPerLocale = $\mbox{{\it value in global config const of the same name}}$,
           dataParIgnoreRunningTasks = $\mbox{{\it value in global config const of the same name}}$,
           dataParMinGranularity = $\mbox{{\it value in global config const of the same name}}$,
           param rank: int = $\mbox{{\it rank inferred from startIdx}}$,
           type idxType = $\mbox{{\it index type inferred from startIdx}}$)
\end{chapel}

The argument \chpl{startIdx} is a tuple of integers defining an index that
will be distributed to the first locale in \chpl{targetLocales}. For a single
dimensional distribution \chpl{startIdx} can be an integer or a tuple with a
single element.

The argument \chpl{targetLocales} is a non-distributed array
containing the target locales to which this distribution maps indices
and data.  The rank of \chpl{targetLocales} must match the rank of the
distribution, or be one.  If the rank of
\chpl{targetLocales} is one, a greedy heuristic is used to reshape the
array of target locales so that it matches the rank of the
distribution and each dimension contains an approximately equal number
of indices.

The
arguments \chpl{dataParTasksPerLocale}, \chpl{dataParIgnoreRunningTasks},
and \chpl{dataParMinGranularity} set the knobs that are used to
control intra-locale data parallelism for Cyclic-distributed domains
and arrays in the same way that the global configuration constants of
these names control data parallelism for ranges and
default-distributed domains and arrays ~\rsec{data_parallel_knobs}.

The \chpl{rank} and \chpl{idxType} arguments are inferred from the
\chpl{startIdx} argument unless explicitly set.

\begin{example}
The following code declares a Cyclic distribution with a start index
of \chpl{(1,1)} and declares an array, \chpl{A}, over a domain
declared over this distribution.  The computation in the \chpl{forall}
loop sets each array element to the ID of the locale to which it is
mapped.
\begin{chapel}
use CyclicDist;

const Space = [1..8, 1..8];
const D: domain(2) dmapped Cyclic(startIdx=Space.low) = Space;
var A: [D] int;

forall a in A do
  a = a.locale.id;

writeln(A);
\end{chapel}
When run on 6 locales, the output is:
\begin{chapel}
0 1 0 1 0 1 0 1
2 3 2 3 2 3 2 3
4 5 4 5 4 5 4 5
0 1 0 1 0 1 0 1
2 3 2 3 2 3 2 3
4 5 4 5 4 5 4 5
0 1 0 1 0 1 0 1
2 3 2 3 2 3 2 3
\end{chapel}
\end{example}
