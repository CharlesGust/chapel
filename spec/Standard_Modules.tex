\sekshun{Standard Modules}
\label{Standard_Modules}
\index{standard modules}
\index{modules!standard}

Standard modules provide standard library support
and are available to every Chapel program.
The functions and other definitions of automatic modules are always
available to a Chapel program.
Optional modules can be accessed via use statements
(\rsec{Using_Modules}).

The automatic modules
are as follows:

\begin{tabular}{lll}
\hspace{1pc} & \chpl{Math} & Math routines \\
             & \chpl{Base} & Basic routines \\
             & \chpl{Types} & Routines related to primitive types \\
\end{tabular}

\noindent The optional modules include:

\begin{tabular}{lll}
\hspace{1pc} & \chpl{BitOps} & Bit manipulation routines \\
             & \chpl{Functions}   & Common higher-order functions \\
             & \chpl{Norm}   & Routines for computing vector and matrix norms \\
             & \chpl{Random} & Random number generation routines \\
             & \chpl{Search} & Generic searching routines \\
             & \chpl{Sort} & Generic sorting routines \\
             & \chpl{Time} & Types and routines related to time \\
\end{tabular}

There is an expectation that each of these modules will be extended
and that more standard modules will be defined over time.

\section{Automatic Modules}
\index{automatic modules}
\index{standard modules!automatic}

Automatic modules are used by a Chapel program automatically.  There
is currently no way to avoid their use by a program, although we
anticipate adding such a capability in the future.

\subsection{Math}
\label{Math}
\index{automatic modules!Math}

The module \chpl{Math} defines routines for mathematical computations.
This module is used by default; there is no need to explicitly use
this module.  The Math module defines routines that are derived from
and implemented via the standard C routines defined in \chpl{math.h}.

\vspace{1pc}

\begin{protohead}
proc abs(i: int(?w)): int(w)
proc abs(i: uint(?w)): uint(w)
proc abs(x: real): real
proc abs(x: real(32)): real(32)
proc abs(x: complex): real
\end{protohead}
\begin{protobody}
Returns the absolute value of the argument.
\end{protobody}

\begin{protohead}
proc acos(x: real): real
proc acos(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the arc cosine of the argument.  It is an error if \chpl{x} is
less than $-1$ or greater than $1$.
\end{protobody}

\begin{protohead}
proc acosh(x: real): real
proc acosh(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the inverse hyperbolic cosine of the argument.  It is an error
if \chpl{x} is less than $1$.
\end{protobody}

\begin{protohead}
proc asin(x: real): real
proc asin(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the arc sine of the argument.  It is an error if \chpl{x} is
less than $-1$ or greater than $1$.
\end{protobody}

\begin{protohead}
proc asinh(x: real): real
proc asinh(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the inverse hyperbolic sine of the argument.
\end{protobody}

\begin{protohead}
proc atan(x: real): real
proc atan(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the arc tangent of the argument.
\end{protobody}

\begin{protohead}
proc atan2(y: real, x: real): real
proc atan2(y: real(32), x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the arc tangent of the two arguments.  This is equivalent to
the arc tangent of \chpl{y / x} except that the signs of \chpl{y}
and \chpl{x} are used to determine the quadrant of the result.
\end{protobody}

\begin{protohead}
proc atanh(x: real): real
proc atanh(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the inverse hyperbolic tangent of the argument.  It is an error
if \chpl{x} is less than $-1$ or greater than $1$.
\end{protobody}

\begin{protohead}
proc cbrt(x: real): real
proc cbrt(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the cube root of the argument.
\end{protobody}

\begin{protohead}
proc ceil(x: real): real
proc ceil(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the value of the argument rounded up to the nearest integer.
\end{protobody}

\begin{protohead}
proc conjg(a: complex(?w)): complex(w)
\end{protohead}
\begin{protobody}
Returns the conjugate of \chpl{a}.
\end{protobody}

\begin{protohead}
proc cos(x: real): real
proc cos(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the cosine of the argument.
\end{protobody}

\begin{protohead}
proc cosh(x: real): real
proc cosh(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the hyperbolic cosine of the argument.
\end{protobody}

\begin{protohead}
proc erf(x: real): real
proc erf(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the error function of the argument defined as
$$\frac{2}{\sqrt{\pi}}\int^x_0e^{-t^2}dt$$
for the argument $x$.
\end{protobody}

\begin{protohead}
proc erfc(x: real): real
proc erfc(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the complementary error function of the argument.  This is
equivalent to \chpl{1.0 - erf(x)}.
\end{protobody}

\begin{protohead}
proc exp(x: real): real
proc exp(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the value of $e$ raised to the power of the argument.
\end{protobody}

\begin{protohead}
proc exp2(x: real): real
proc exp2(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the value of $2$ raised to the power of the argument.
\end{protobody}

\begin{protohead}
proc expm1(x: real): real
proc expm1(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns one less than the value of $e$ raised to the power of the argument.
\end{protobody}

\begin{protohead}
proc floor(x: real): real
proc floor(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the value of the argument rounded down to the nearest integer.
\end{protobody}

\begin{protohead}
proc lgamma(x: real): real
proc lgamma(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the natural logarithm of the absolute value of the gamma
function of the argument.
\end{protobody}

\begin{protohead}
proc log(x: real): real
proc log(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the natural logarithm of the argument.  It is an error if the
argument is less than or equal to zero.
\end{protobody}

\begin{protohead}
proc log10(x: real): real
proc log10(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the base 10 logarithm of the argument.  It is an error if the
argument is less than or equal to zero.
\end{protobody}

\begin{protohead}
proc log1p(x: real): real
proc log1p(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the natural logarithm of \chpl{x+1}.  It is an error
if \chpl{x} is less than or equal to $-1$.
\end{protobody}

\begin{protohead}
proc log2(i: int(?w)): int(w)
proc log2(i: uint(?w)): uint(w)
proc log2(x: real): real
proc log2(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the base 2 logarithm of the argument.  It is an error if the
argument is less than or equal to zero.
\end{protobody}

\begin{protohead}
proc nearbyint(x: real): real
proc nearbyint(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the rounded integral value of the argument determined by the
current rounding direction.
\end{protobody}

\begin{protohead}
proc rint(x: real): real
proc rint(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the rounded integral value of the argument determined by the
current rounding direction.
\end{protobody}

\begin{protohead}
proc round(x: real): real
proc round(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the rounded integral value of the argument.  Cases halfway
between two integral values are rounded towards zero.
\end{protobody}

\begin{protohead}
proc sin(x: real): real
proc sin(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the sine of the argument.
\end{protobody}

\begin{protohead}
proc sinh(x: real): real
proc sinh(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the hyperbolic sine of the argument.
\end{protobody}

\begin{protohead}
proc sqrt(x: real): real
proc sqrt(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the square root of the argument.  It is an error if the
argument is less than zero.
\end{protobody}

\begin{protohead}
proc tan(x: real): real
proc tan(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the tangent of the argument.
\end{protobody}

\begin{protohead}
proc tanh(x: real): real
proc tanh(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the hyperbolic tangent of the argument.
\end{protobody}

\begin{protohead}
proc tgamma(x: real): real
proc tgamma(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the gamma function of the argument defined as
$$\int_0^\infty t^{x-1} e^{-t} dt$$
for the argument $x$.
\end{protobody}

\begin{protohead}
proc trunc(x: real): real
proc trunc(x: real(32)): real(32)
\end{protohead}
\begin{protobody}
Returns the nearest integral value to the argument that is not larger
than the argument in absolute value.
\end{protobody}


\subsection{Base}
\label{Standard}
\index{automatic modules!Base}

\begin{protohead}
proc ascii(s: string): int
\end{protohead}
\begin{protobody}
Returns the ASCII code number of the first letter in the
argument \chpl{s}.
\end{protobody}

\begin{protohead}
proc assert(test: bool) {
\end{protohead}
\begin{protobody}
Exits the program if \chpl{test} is false and prints to standard error
the location in the Chapel code of the call to \chpl{assert}.
If \chpl{test} is true, no action is taken.
\end{protobody}

\begin{protohead}
proc assert(test: bool, args ...?numArgs) {
\end{protohead}
\begin{protobody}
Exits the program if \chpl{test} is false and prints to standard error
the location in the Chapel code of the call to \chpl{assert} as well
as the rest of the arguments to the call.  If \chpl{test} is true, no
action is taken.
\end{protobody}

\begin{protohead}
proc complex.re: real
\end{protohead}
\begin{protobody}
Returns the real component of the complex number.
\end{protobody}

\begin{protohead}
proc complex.im: real
\end{protohead}
\begin{protobody}
Returns the imaginary component of the complex number.
\end{protobody}

\begin{protohead}
proc complex.=re(f: real)
\end{protohead}
\begin{protobody}
Sets the real component of the complex number to \chpl{f}.
\end{protobody}

\begin{protohead}
proc complex.=im(f: real)
\end{protohead}
\begin{protobody}
Sets the imaginary component of the complex number to \chpl{f}.
\end{protobody}

\begin{protohead}
proc exit(status: int)
\end{protohead}
\begin{protobody}
Exits the program with code \chpl{status}.
\end{protobody}

\begin{protohead}
proc halt()
\end{protohead}
\begin{protobody}
Exits the program and prints to standard error the location in the
Chapel code of the call to \chpl{halt}.
\end{protobody}

\begin{protohead}
proc halt(args ...?numArgs)
\end{protohead}
\begin{protobody}
Exits the program and prints to standard error the location in the
Chapel code of the call to \chpl{halt} as well as the rest of the
arguments to the call.
\end{protobody}

\begin{protohead}
proc string.length: int
\end{protohead}
\begin{protobody}
Returns the number of characters in the base expression of type string.
\end{protobody}

\begin{protohead}
proc max(x, y...?k)
\end{protohead}
\begin{protobody}
Returns the maximum of the arguments when compared using the
``greater-than'' operator.  The return type is inferred from the types
of the arguments as allowed by implicit coercions.
\end{protobody}

\begin{protohead}
proc min(x, y...?k)
\end{protohead}
\begin{protobody}
Returns the minimum of the arguments when compared using the
``less-than'' operator.  The return type is inferred from the types of
the arguments as allowed by implicit coercions.
\end{protobody}

\begin{protohead}
proc string.substring(x): string
\end{protohead}
\begin{protobody}
Returns a value of string type that is a substring of the base
expression.  If \chpl{x} is $i$, a value of type \chpl{int}, then the
result is the $i$th character.  If \chpl{x} is a range, the result is
the substring where the characters in the substring are given by the
values in the range.
\end{protobody}

\begin{protohead}
proc typeToString(type t) param : string
\end{protohead}
\begin{protobody}
Returns a string parameter that represents the name of the
type \chpl{t}.
\end{protobody}

\subsection{Types}
\label{Types_standard_module}

\begin{protohead}
proc numBits(type t) param : int
\end{protohead}
\begin{protobody}
Returns the number of bits used to store the values of type \chpl{t}.
This is implemented for all numeric types and fixed-width \chpl{bool} types.
It is not implemented for default-width \chpl{bool}.
\end{protobody}


\begin{protohead}
proc numBytes(type t) param : int
\end{protohead}
\begin{protobody}
Returns the number of bytes used to store the values of type \chpl{t}.
This is implemented for all numeric types and fixed-width \chpl{bool} types.
It is not implemented for default-width \chpl{bool}.
\end{protobody}

\begin{protohead}
proc max(type t): t
\end{protohead}
\begin{protobody}
Returns the maximum value that can be stored in type \chpl{t}.  This
is implemented for all numeric types.
\end{protobody}

\begin{protohead}
proc min(type t): t
\end{protohead}
\begin{protobody}
Returns the minimum value that can be stored in type \chpl{t}.  This
is implemented for all numeric types.
\end{protobody}



\section{Optional Modules}
\index{optional modules}
\index{standard modules!optional}

Optional modules can be used by a Chapel program via the \chpl{use}
keyword (\rsec{Using_Modules}).

\subsection{BitOps}
\label{BitOps}
\index{optional modules!BitOps}

The module \chpl{BitOps} defines routines that manipulate the bits of
values of integral types.

\vspace{1pc}

\begin{protohead}
proc bitPop(i: integral): int
\end{protohead}
\begin{protobody}
Returns the number of bits set to one in the integral
argument \chpl{i}.
\end{protobody}

\begin{protohead}
proc bitMatMultOr(i: uint(64), j: uint(64)): uint(64)
\end{protohead}
\begin{protobody}
Returns the bitwise matrix multiplication of \chpl{i} and \chpl{j}
where the values of \chpl{uint(64)} type are treated as $8 \times 8$
bit matrices and the combinator function is bitwise or.
\end{protobody}

\begin{protohead}
proc bitRotLeft(i: integral, shift: integral): i.type
\end{protohead}
\begin{protobody}
Returns the value of the integral argument \chpl{i} after rotating the
bits to the left \chpl{shift} number of times.
\end{protobody}

\begin{protohead}
proc bitRotRight(i: integral, shift: integral): i.type
\end{protohead}
\begin{protobody}
Returns the value of the integral argument \chpl{i} after rotating the
bits to the right \chpl{shift} number of times.
\end{protobody}


\subsection{Norm}
\label{Norm}
\index{optional modules!Norm}

The module \chpl{Norm} supports the computation of standard vector and
matrix norms on Chapel arrays.  The current interface is minimal and
should be expected to grow and evolve over time.

\begin{protohead}
enum normType {norm1, norm2, normInf, normFrob};
\end{protohead}
\begin{protobody}
An enumerated type indicating the different types of norms supported
by this module: 1-norm, 2-norm, infinity norm and Frobenius norm,
respectively.
\end{protobody}

\begin{protohead}
proc norm(x: [], p: normType) where x.rank == 1 || x.rank == 2
\end{protohead}
\begin{protobody}
Compute the norm indicated by \chpl{p} on the 1D or 2D array \chpl{x}.
\end{protobody}

\begin{protohead}
proc norm(x: [])
\end{protohead}
\begin{protobody}
Compute the default norm on array \chpl{x}.  For a 1D array this is
the 2-norm, for a 2D array, this is the Frobenius norm.
\end{protobody}

\subsection{Random}
\label{Random}
\index{optional modules!Random}

The module \chpl{Random} supports the generation of pseudo-random
values and streams of values.  The current interface is minimal and
should be expected to grow and evolve over time.  In particular, we
expect to support other pseudo-random number generation algorithms,
more random value types (\eg, int), and both serial and parallel
iterators over the RandomStream class.

\begin{protohead}
class RandomStream
proc RandomStream(seed: int(64), param parSafe: bool = true)
proc RandomStream(seedGenerator: SeedGenerator = SeedGenerator.currentTime,
                 param parSafe: bool = true)
\end{protohead}
\begin{protobody}
Implements a pseudo-random stream of values based on a seed value.
The current implementation generates the values using a linear
congruential generator.  In future versions of this module, the
RandomStream class will offer a wider variety of algorithms for
generating pseudo-random values.

To construct a RandomStream class, the seed may be explicitly passed.
It must be an odd integer between $1$ and $2^{46}-1$.  Alternatively,
the RandomStream class can be constructed by passing a value of the
enumerated type SeedGenerator to choose an algorithm to use to set the
seed.  If neither a seed nor a SeedGenerator value is passed to the
RandomStream class, the seed will be initialized based on the current
time in microseconds (rounded via modular arithmetic to the nearest
odd integer between $1$ and $2^{46}-1$.

The parSafe parameter defaults to true and allows for safe use of this
class by concurrent tasks.  This can be overridden when calling
methods to make them safe when called by concurrent tasks.  This
mechanism allows for lower overhead calls when there is no threat of
concurrent calls, but correct calls when there is.
\end{protobody}

\begin{protohead}
enum SeedGenerator { currentTime };
\end{protohead}
\begin{protobody}
Values of this enumerated type may be used to choose a method for
initializing the seed in the RandomStream class.  The only value
supported at present is \chpl{currentTime} which can be used to
initialize the seed based on the current time in microseconds (rounded
via modular arithmetic to the nearest odd integer between $1$ and
$2^{46}-1$.
\end{protobody}

\begin{protohead}
proc RandomStream.fillRandom(x:[?D], param parSafe = this.parSafe)
\end{protohead}
\begin{protobody}
Fill the argument array, \chpl{x}, with the next $|$\chpl{D}$|$ values
of the pseudo-random stream in row-major order.  The array must be an
array of real(64), imag(64), or complex(128) elements.  For complex
arrays, each complex element is initialized with two values from the
stream of random numbers.
\end{protobody}

\begin{protohead}
proc RandomStream.skipToNth(in n: integral, param parSafe = this.parSafe)
\end{protohead}
\begin{protobody}
Skips ahead or back to the \chpl{n}-th value in the
random stream.  The value of n is assumed to be positive, such that
\chpl{n}~==~1 represents the initial value in the stream.
\end{protobody}

\begin{protohead}
proc RandomStream.getNext(param parSafe = this.parSafe): real
\end{protohead}
\begin{protobody}
Returns the next value in the random stream as a real.
\end{protobody}

\begin{protohead}
proc RandomStream.getNth(n: integral, param parSafe = this.parSafe): real
\end{protohead}
\begin{protobody}
Returns the \chpl{n}-th value in the random stream as a real.  Equivalent to
calling \chpl{skipToNth(n)} followed by \chpl{getNext()}.
\end{protobody}

\begin{protohead}
proc fillRandom(x:[], initseed: int(64))
\end{protohead}
\begin{protobody}
A routine provided for convenience to support the functionality of the
fillRandom method (above) without explicitly constructing an instance
of the \chpl{RandomStream} class.  This is useful for filling a single
array or multiple arrays which require no coherence between them.
The \chpl{initseed} argument corresponds to the \chpl{seed} member of
the \chpl{RandomStream} class.  If unspecified, the default for the
class will be used.
\end{protobody}

\subsection{Search}
\label{Search}
\index{optional modules!Search}

The \chpl{Search} module is designed to support standard search
routines.  The current interface is minimal and should be expected to
grow and evolve over time.

\begin{protohead}
proc LinearSearch(Data: [?Dom], val): (bool, index(Dom))
\end{protohead}
\begin{protobody}
Searches through the pre-sorted array \chpl{Data} looking for the
value \chpl{val} using a sequential linear search.  Returns a tuple
indicating (1) whether or not the value was found and (2) the location
of the value if it was found, or the location where the value should
have been if it was not found.
\end{protobody}


\begin{protohead}
proc BinarySearch(Data: [?Dom], val, in lo = Dom.low, in hi = Dom.high)
\end{protohead}
\begin{protobody}
Searches through the pre-sorted array \chpl{Data} looking for the
value \chpl{val} using a sequential binary search.  If provided, only
the indices \chpl{lo} through \chpl{hi} will be considered, otherwise
the whole array will be searched.  Returns a tuple indicating (1)
whether or not the value was found and (2) the location of the value
if it was found, or the location where the value should have been if
it was not found.
\end{protobody}


\subsection{Sort}
\label{Sort}
\index{optional modules!Sort}

The \chpl{Sort} module is designed to support standard sorting
routines.  The current interface is minimal and should be expected to
grow and evolve over time.

\begin{protohead}
proc InsertionSort(Data: [?Dom]) where Dom.rank == 1
\end{protohead}
\begin{protobody}
Sorts the 1D array \chpl{Data} in-place using a sequential insertion
sort algorithm.
\end{protobody}

\begin{protohead}
proc QuickSort(Data: [?Dom]) where Dom.rank == 1
\end{protohead}
\begin{protobody}
Sorts the 1D array \chpl{Data} in-place using a sequential
implementation of the QuickSort algorithm.
\end{protobody}

\subsection{Time}
\label{Time}
\index{optional modules!Time}

The module \chpl{Time} defines routines that query the system time and
a record \chpl{Timer} that is useful for timing portions of code.

\vspace{1pc}

\begin{protohead}
record Timer
\end{protohead}
\begin{protobody}
A timer is used to time portions of code.  Its semantics are similar
to a stopwatch.
\end{protobody}

\begin{protohead}
enum TimeUnits { microseconds, milliseconds, seconds, minutes, hours };
\end{protohead}
\begin{protobody}
The enumeration TimeUnits defines units of time.  These units can be
supplied to routines in this module to specify the desired time units.
\end{protobody}

\begin{protohead}
enum Day { sunday=0, monday, tuesday, wednesday, thursday, friday, saturday };
\end{protohead}
\begin{protobody}
The enumeration Day defines the days of the week, with Sunday defined to be 0.
\end{protobody}


\begin{protohead}
proc getCurrentDate(): (int, int, int)
\end{protohead}
\begin{protobody}
Returns the year, month, and day of the month as integers.  The year
is the year since 0.  The month is in the range 1 to 12.  The day is
in the range 1 to 31.
\end{protobody}

\begin{protohead}
proc getCurrentDayOfWeek(): Day
\end{protohead}
\begin{protobody}
Returns the current day of the week.
\end{protobody}


\begin{protohead}
proc getCurrentTime(unit: TimeUnits = TimeUnits.seconds): real
\end{protohead}
\begin{protobody}
Returns the elapsed time since midnight in the units specified.
\end{protobody}

\begin{protohead}
proc Timer.clear()
\end{protohead}
\begin{protobody}
Clears the elapsed time stored in the Timer.
\end{protobody}

\begin{protohead}
proc Timer.elapsed(unit: TimeUnits = TimeUnits.seconds): real
\end{protohead}
\begin{protobody}
Returns the cumulative elapsed time, in the units specified, between
calls to \chpl{start} and \chpl{stop}.  If the timer is running, the
elapsed time since the last call to \chpl{start} is added to the
return value.
\end{protobody}

\begin{protohead}
proc Timer.start()
\end{protohead}
\begin{protobody}
Starts the timer.  It is an error to start a timer that is already
running.
\end{protobody}

\begin{protohead}
proc Timer.stop()
\end{protohead}
\begin{protobody}
Stops the timer.  It is an error to stop a timer that is not running.
\end{protobody}

\begin{protohead}
proc sleep(t: uint)
\end{protohead}
\begin{protobody}
Delays a task for \chpl{t} seconds.
\end{protobody}

