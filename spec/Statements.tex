\sekshun{Statements}
\label{Statements}

\index{statement}

Chapel is an imperative language with statements that may have side
effects.  Statements allow for the sequencing of program execution.
They are as follows:
\begin{syntax}
statement:
  block-statement
  expression-statement
  assignment-statement
  swap-statement
  conditional-statement
  select-statement
  while-do-statement
  do-while-statement
  for-statement
  label-statement
  break-statement
  continue-statement
  param-for-statement
  return-statement
  yield-statement
  module-declaration-statement
  function-declaration-statement
  method-declaration-statement
  type-declaration-statement
  variable-declaration-statement
  remote-variable-declaration-statement
  use-statement
  type-select-statement
  empty-statement
  parallel-statement
  on-statement
\end{syntax}

The declaration statements are discussed in the sections that define
what they declare.  Module declaration statements are defined
in~\rsec{Modules}.  Function declaration statements are defined
in~\rsec{Functions}.  Method declaration statements are defined
in~\rsec{Class_Methods}.  Type declaration statements are defined
in~\rsec{Types}.  Variable declaration statements are defined
in~\rsec{Variables}.  Remote variable declaration statements are
defined in~\rsec{remote_variable_declarations}.  Tuple variable
declaration statements are defined
in~\rsec{Variable_Declarations_in_a_Tuple}.  Return statements are
defined in~\rsec{The_Return_Statement}.  Yield statements are defined
in~\rsec{The_Yield_Statement}.  The \sntx{parallel-statement} consists
of statements that create or limit parallelism.  These statements are
described in~\rsec{Task_Parallelism_and_Synchronization}
and~\rsec{Data_Parallelism}.  The \sntx{on-statement} is defined
in~\rsec{On}.  The compiler error statement is defined
in~\rsec{User_Defined_Compiler_Errors}.

\subsection{Blocks}
\label{Blocks}

\index{block}

A block is a statement or a possibly empty list of statements that
form their own scope.  A block is given by
\begin{syntax}
block-statement:
  { statements[OPT] }

statements:
  statement
  statement statements
\end{syntax}

Variables defined within a block are local
variables~(\rsec{Local_Variables}).

The statements within a block are executed serially unless the block
is in a cobegin statement~(\rsec{Cobegin}).

\subsection{Expression Statements}
\label{Expression_Statements}

\index{expression statement}
\index{expression!as a statement}
The expression statement evaluates an expression solely for side
effects. The syntax for an expression statement is given by
\begin{syntax}
expression-statement:
  expression ;
\end{syntax}

\subsection{Assignment Statements}
\label{Assignment_Statements}
\index{assignment}

An assignment statement assigns the value of an expression to another
expression that can appear on the left-hand side of the operator, for
example, a variable.  Assignment statements are given by

\index{=@\chpl{=}}
\index{+=@\chpl{+=}}
\index{-=@\chpl{-=}}
\index{*=@\chpl{*=}}
\index{/=@\chpl{/=}}
\index{\%=@\chpl{\%=}}
\index{**=@\chpl{**=}}
\index{&=@\chpl{&=}}
\index{|=@\chpl{|=}}
\index{^=@\chpl{^=}}
\index{||=@\chpl{||=}}
\index{&&=@\chpl{&&=}}
\index{<<=@\chpl{<<=}}
\index{>>=@\chpl{>>=}}
\begin{syntax}
assignment-statement:
  lvalue-expression assignment-operator expression

assignment-operator: one of
   = += -= *= /= %= **= &= |= ^= &&= ||= <<= >>=
\end{syntax}

The expression on the left-hand side of the assignment operator must
be a valid lvalue~(\rsec{lvalue}).  It is evaluated before the
expression on the right-hand side of the assignment operator, which
can be any expression.

The assignment operators that contain a binary operator as a prefix is
a short-hand for applying the binary operator to the left and
right-hand side expressions and then assigning the value of that
application to the already evaluated left-hand side.  Thus, for
example, \chpl{x += y} is equivalent to \chpl{x = x + y} where the
expression \chpl{x} is evaluated once.

In a compound assignment, a cast to the type on the left-hand side is
inserted before the simple assignment if the operator is a shift or
both the right-hand side expression can be assigned to the left-hand
side expression and the type of the left-hand side is a primitive
type.

\begin{rationale}
This cast is necessary to handle \chpl{+=} where the type of the
left-hand side is, for example, \chpl{int(8)} because the \chpl{+}
operator is defined on \chpl{int(32)}, not \chpl{int(8)}.
\end{rationale}

Values of one primitive or enumerated type can be assigned to another
primitive or enumerated type if an implicit coercion exists between
those types~(\rsec{Implicit_Conversions}).

The validity and semantics of assigning between
classes~(\rsec{Class_Assignment}), records~(\rsec{Record_Assignment}),
unions~(\rsec{Union_Assignment}), tuples~(\rsec{Tuple_Assignment}),
ranges~(\rsec{Range_Assignment}),
domains~(\rsec{Domain_Assignment}), and arrays~(\rsec{Array_Assignment})
is discussed in these later sections.

\subsection{The Swap Statement}
\label{The_Swap_Statement}
\index{swap!statement}
\index{swap!operator}
The swap statement indicates to swap the values in the expressions
on either side of the swap operator.  Since both expressions are assigned
to, each must be a valid lvalue expression~(\rsec{lvalue}).
\begin{syntax}
swap-statement:
  lvalue-expression swap-operator lvalue-expression

swap-operator:
  <=>
\end{syntax}

To implement the swap operation, the compiler uses temporary variables
as necessary.

\begin{example}
The following swap statement
\begin{chapel}
var a, b: real;

a <=> b;
\end{chapel}
is semantically equivalent to:
\begin{chapel}
const t = b;
b = a;
a = t;
\end{chapel}
\end{example}

\subsection{The Conditional Statement}
\label{The_Conditional_Statement}

\index{if@\chpl{if}}
\index{then@\chpl{then}}
\index{else@\chpl{else}}
\index{conditional!statement}
The conditional statement allows execution to choose between two
statements based on the evaluation of an expression of \chpl{bool}
type. The syntax for a conditional statement is given by
\begin{syntax}
conditional-statement:
  `if' expression `then' statement else-part[OPT]
  `if' expression block-statement else-part[OPT]

else-part:
  `else' statement
\end{syntax}

A conditional statement evaluates an expression of bool type. If the
expression evaluates to true, the first statement in the conditional
statement is executed.  If the expression evaluates to false and the
optional else-clause exists, the statement following the
\chpl{else} keyword is executed.

If the expression is a parameter, the conditional statement is folded
by the compiler. If the expression evaluates to true, the first
statement replaces the conditional statement. If the expression
evaluates to false, the second statement, if it exists, replaces the
conditional statement; if the second statement does not exist, the
conditional statement is removed.

\index{conditional statement!dangling else}
If the statement that immediately follows the optional \chpl{then}
keyword is a conditional statement and it is not in a block, the
else-clause is bound to the nearest preceding conditional statement
without an else-clause.

Each statement embedded in the {\em conditional-statement} has its own
scope whether or not an explicit block surrounds it.

\subsection{The Select Statement}
\label{The_Select_Statement}

\index{select@\chpl{select}}
\index{when@\chpl{when}}

The select statement is a multi-way variant of the conditional
statement.  The syntax is given by:
\begin{syntax}
select-statement:
  `select' expression { when-statements }

when-statements:
  when-statement
  when-statement when-statements

when-statement:
  `when' expression-list `do' statement
  `when' expression-list block-statement
  `otherwise' statement

expression-list:
  expression
  expression , expression-list
\end{syntax}
The expression that follows the keyword \chpl{select}, the select
expression, is compared with the list of expressions following the
keyword \chpl{when}, the case expressions, using the equality
operator \chpl{==}.  If the expressions cannot be compared with the
equality operator, a compile-time error is generated.  The first case
expression that contains an expression where that comparison
is \chpl{true} will be selected and control transferred to the
associated statement.  If the comparison is always \chpl{false}, the
statement associated with the keyword \chpl{otherwise}, if it exists,
will be selected and control transferred to it.  There may be at most
one \chpl{otherwise} statement and its location within the select
statement does not matter.

Each statement embedded in the {\em when-statement} has its own scope
whether or not an explicit block surrounds it.

\subsection{The While and Do While Loops}
\label{The_While_and_Do_While_Loops}

\index{while loops}
\index{while@\chpl{while}}

There are two variants of the while loop in Chapel.  The syntax of the
while-do loop is given by:
\begin{syntax}
while-do-statement:
  `while' expression `do' statement
  `while' expression block-statement
\end{syntax}
The syntax of the do-while loop is given by:
\begin{syntax}
do-while-statement:
  `do' statement `while' expression ;
\end{syntax}
In both variants, the expression evaluates to a value of type \chpl{bool}
which determines when the loop terminates and control continues with
the statement following the loop.

The while-do loop is executed as follows:
\begin{enumerate}
\item The expression is evaluated.
\item If the expression evaluates to \chpl{false}, the statement is
  not executed and control continues to the statement following the
  loop.
\item If the expression evaluates to \chpl{true}, the statement is
  executed and control continues to step 1, evaluating the expression
  again.
\end{enumerate}

The do-while loop is executed as follows:
\begin{enumerate}
\item The statement is executed.
\item The expression is evaluated.
\item If the expression evaluates to \chpl{false}, control continues
  to the statement following the loop.
\item If the expression evaluates to \chpl{true}, control continues to
  step 1 and the the statement is executed again.
\end{enumerate}
In this second form of the loop, note that the statement is executed
unconditionally the first time.

\subsection{The For Loop}
\label{The_For_Loop}

\index{for@\chpl{for}}
\index{for loops}

The for loop iterates over ranges, domains, arrays, iterators, or any
class that implements an iterator named \chpl{these}.  The syntax of
the for loop is given by:
\begin{syntax}
for-statement:
  `for' loop-control-part loop-body-part

loop-control-part:
  index-expression `in' iterator-expression
  iterator-expression

loop-body-part:
  `do' statement
  block-statement

index-expression:
  expression

iterator-expression:
  expression
\end{syntax}

The index-expression declares new variables for the scope of the loop.
It may specify a new identifier.  Alternatively, the index-expression
may specify multiple identifiers grouped using a tuple notation in
order to destructure the values returned by the iterator expression,
as described in~\rsec{Indices_in_a_Tuple}.

The index-expression is optional and may be omitted if the indices do
not need to be referenced in the loop.

If the iterator-expression is a tuple delimited by parentheses, the
components of the tuple must support iteration, e.g., a tuple of
arrays, and those components are iterated over using a zipper
iteration defined in~\rsec{Zipper_Iteration}.  If the
iterator-expression is a tuple delimited by brackets, the components
of the tuple must support iteration and these components are iterated
over using a tensor product iteration defined
in~\rsec{Tensor_Product_Iteration}.

\subsubsection{Zipper Iteration}
\label{Zipper_Iteration}
\index{zipper iteration}

When multiple iterators are iterated over in a zipper context, on each
iteration, each expression is iterated over, the values are returned
by the iterators in a tuple and assigned to the index, and the
statement is executed.

The shape of each iterator, the rank and the extents in each
dimension, must be identical.

\begin{example}
The output of
\begin{chapel}
for (i, j) in (1..3, 4..6) do
  write(i, " ", j, " ");
\end{chapel}
is ``1 4 2 5 3 6 ''.
\end{example}

\subsubsection{Tensor Product Iteration}
\label{Tensor_Product_Iteration}
\index{tensor product iterator}
When multiple iterators are iterated over in a tensor product context,
they are iterated over as if they were nested in distinct for loops.
There is no constraint on the iterators as there is in the zipper
context.

\begin{example}
The output of
\begin{chapel}
for (i, j) in [1..3, 4..6] do
  write(i, " ", j, " ");
\end{chapel}
is ``1 4 1 5 1 6 2 4 2 5 2 6 3 4 3 5 3 6 ''. The statement is
equivalent to
\begin{chapel}
for i in 1..3 do
  for j in 4..6 do
    write(i, " ", j, " ");
\end{chapel}
\end{example}

\subsubsection{Parameter For Loops}
\label{Parameter_For_Loops}

\index{for loops!parameters}
\index{for@\chpl{for}}
\index{param@\chpl{param}}

Parameter for loops are unrolled by the compiler so that the index
variable is a parameter rather than a variable.  The syntax for a
parameter for loop statement is given by:
\begin{syntax}
param-iterator-expression:
  range-literal
  range-literal `by' integer-literal

param-for-statement:
  `for' `param' identifier `in' param-iterator-expression `do' statement
  `for' `param' identifier `in' param-iterator-expression block-statement
\end{syntax}
Parameter for loops are restricted to iteration over range literals
with an optional by expression where the bounds and stride must be
parameters.  The loop is then unrolled for each iteration.

\subsection{The Label, Break, and Continue Statements}
\label{Label_Break_Continue}
\index{label@\chpl{label}}
\index{break@\chpl{break}}
\index{continue@\chpl{continue}}

The label-statement is used to name a specific loop which can then
be the target of a break- or continue-statement.  If a break-
or continue-statement has no label, the target is the lexically
inner-most loop. Labels can only be given to for-, while-do- and
do-while-statements.

The syntax for label, break, and continue statements is given by:
\begin{syntax}
label-statement:
  `label' identifier statement

break-statement:
  `break' identifier[OPT] ;

continue-statement:
  `continue' identifier[OPT] ;
\end{syntax}

If a break-statement is encountered, control will be transferred to
after the associated loop.  If a continue-statement is encountered,
control will be transferred to the end of the associated loop, but
still inside the loop.  Break-statements cannot be used to break out of
parallel loops.  Neither break- nor continue-statements can
cross out of cobegin-, coforall-, begin-, or sync-statements.

\begin{example}
In the following code, the index of the first element in each row of
\chpl{A} that is equal to \chpl{findVal} is printed.  Once a match is
found, the continue statement is executed causing the outer loop to
move to the next row.
\begin{chapel}
label outer for i in 1..n {
  for j in 1..n {
    if A[i, j] == findVal {
      writeln("index: ", (i, j), " matches.");
      continue outer;
    }
  }
}
\end{chapel}
\end{example}

\subsection{The Use Statement}
\label{The_Use_Statement}
\index{use@\chpl{use}}
\index{modules!using}

The use statement makes symbols in modules available without accessing
them via the module name.  The syntax of the use statement is given
by:
\begin{syntax}
use-statement:
  `use' module-name-list ;

module-name-list:
  module-name
  module-name , module-name-list

module-name:
  identifier
  module-name . module-name
\end{syntax}
The use statement makes symbols in each listed module's scope available
from the scope where the use statement occurs.

Symbols injected by a use statement are at an outer scope from those
defined directly in the scope where the use statement occurs, but at a
nearer scope than symbols defined in the scope containing the scope where
the use statement occurs.

If used modules themselves use other modules, symbols are scoped according
the depth of use statements followed to find them. It is an error for two
variables, types, or modules to be defined at the same depth.

\begin{openissue}
There is an expectation that this statement will be extended to allow
the programmer to restrict which symbols are 'used' as well as to
rename symbols that are used.
\end{openissue}

\subsection{The Type Select Statement}
\label{The_Type_Select_Statement}

\index{type select statements}

A type select statement has two uses.  It can be used to determine the
type of a union, as discussed
in~\rsec{The_Type_Select_Statement_and_Unions}.  In its more general
form, it can be used to determine the types of one or more values
using the same mechanisms used to disambiguate function definitions.
It syntax is given by:
\begin{syntax}
type-select-statement:
  `type' `select' expression-list { type-when-statements }

type-when-statements:
  type-when-statement
  type-when-statement type-when-statements

type-when-statement:
  `when' type-list `do' statement
  `when' type-list block-statement
  `otherwise' statement

expression-list:
  expression
  expression , expression-list

type-list:
  type-specifier
  type-specifier , type-list
\end{syntax}

Call the expressions following the keyword \chpl{select}, the select
expressions.  The number of select expressions must be equal to the
number of types following each of the \chpl{when} keywords.  Like the
select statement, one of the statements associated with a \chpl{when}
will be executed.  In this case, that statement is chosen by the
function resolution mechanism.  The select expressions are the actual
arguments, the types following the \chpl{when} keywords are the types
of the formal arguments for different anonymous functions.  The
function that would be selected by function resolution determines the
statement that is executed.  If none of the functions are chosen, the
the statement associated with the keyword \chpl{otherwise}, if it
exists, will be selected.

As with function resolution, this can result in an ambiguous
situation.  Unlike with function resolution, in the event of an
ambiguity, the first statement in the list of when statements is
chosen.

\subsection{The Empty Statement}
\label{The_Empty_Statement}

An empty statement has no effect.  The syntax of an empty statement is
given by
\begin{syntax}
empty-statement:
  ;
\end{syntax}
