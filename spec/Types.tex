\sekshun{Types}
\label{Types}

Chapel is a statically typed language with a rich set of types.  These
include a set of predefined primitive types, enumerated types,
locality types, structured types (classes, records, unions, tuples),
data parallel types (ranges, domains, arrays), and synchronization
types (sync, single).

% This section defines the primitive
% types, enumerated types, and type aliases.  

The syntax of a type is summarized by the following syntax:

\begin{syntax}
type-specifier:
  primitive-type
  enum-type
  locality-type
  structured-type
  dataparallel-type
  synchronization-type
\end{syntax}

The structured types are summarized by the following syntax:

\begin{syntax}
structured-type:
  class-type
  record-type
  union-type
  tuple-type
\end{syntax}
% in README.firstClassFns: function-type

Classes are discussed in~\rsec{Classes}.  Records are discussed
in~\rsec{Records}.  Unions are discussed in~\rsec{Unions}.  Tuples are
discussed in~\rsec{Tuples}.  

The data parallel types are summarized by the following syntax:

\begin{syntax}
dataparallel-type:
  range-type
  domain-type
  mapped-domain-type
  array-type
  index-type
\end{syntax}

Ranges are discussed in~\rsec{Ranges}.  Domains, arrays, and index
types are discussed in~\rsec{Domains} and~\rsec{Arrays}.

The synchronization types are summarized by the following syntax:

\begin{syntax}
synchronization-type:
  sync-type
  single-type
\end{syntax}

Sync and single types are discussed in~\rsec{Sync_Variables}
and~\rsec{Single_Variables}.

Programmers can define their own enumerated types, classes, records,
unions, and type aliases in type declaration statements summarized by
the following syntax:
\begin{syntax}
type-declaration-statement:
  enum-declaration-statement
  class-declaration-statement
  record-declaration-statement
  union-declaration-statement
  type-alias-declaration-statement
\end{syntax}

\subsection{Primitive Types}
\label{Primitive_Types}
\index{types!primitive}

The primitive types include the following types: \chpl{bool},
\chpl{int}, \chpl{uint}, \chpl{real}, \chpl{imag}, \chpl{complex},
\chpl{string}, and \chpl{locale}.  These primitive types are defined
in this section.

The primitive types are summarized by the following syntax:
\begin{syntax}
primitive-type:
  `bool' primitive-type-parameter-part[OPT]
  `int' primitive-type-parameter-part[OPT]
  `uint' primitive-type-parameter-part[OPT]
  `real' primitive-type-parameter-part[OPT]
  `imag' primitive-type-parameter-part[OPT]
  `complex' primitive-type-parameter-part[OPT]
  `string'

primitive-type-parameter-part:
  ( integer-parameter-expression )

integer-parameter-expression:
  expression
\end{syntax}


\begin{openissue}
There is an expectation of future support for larger bit width
primitive types depending on a platform's native support for those
types.
\end{openissue}


\subsubsection{The Bool Type}
\label{The_Bool_Type}
\index{bool@\chpl{bool}}

Chapel defines a logical data type designated by the symbol
\chpl{bool} with the two predefined values \chpl{true} and
\chpl{false}.  This default boolean type is stored using an
implementation-dependent number of bits.  A particular number of bits
can be specified using a parameter value following the \chpl{bool}
keyword, such as \chpl{bool(8)} to request an 8-bit boolean value.
Legal sizes are 8, 16, 32, and 64 bits.

%% The relational operators return values of \chpl{bool} type and the
%% logical operators operate on values of \chpl{bool} type.

Some statements require expressions of \chpl{bool} type and Chapel
supports a special conversion of values to \chpl{bool} type when used
in this context~(\rsec{Implicit_Statement_Bool_Conversions}).

\subsubsection{Signed and Unsigned Integral Types}
\label{Signed_and_Unsigned_Integral_Types}
\index{uint@\chpl{uint}}
\index{int@\chpl{int}}

The integral types can be parameterized by the number of bits used to
represent them.  The default signed integral type, \chpl{int}, and the
default unsigned integral type, \chpl{uint}, are 32 bits.

The integral types and their ranges are given in the following table:

\begin{center}
\begin{tabular}{|l|r|r|}
\hline
{\bf Type} & {\bf Minimum Value} & {\bf Maximum Value} \\
\hline
{\tt int(8)} & -128 & 127 \\
{\tt uint(8)} & 0 & 255 \\
{\tt int(16)} & -32768 & 32767 \\
{\tt uint(16)} & 0 & 65535 \\
{\tt int(32)}, {\tt int} & -2147483648 & 2147483647 \\
{\tt uint(32)}, {\tt uint} & 0 & 4294967295 \\
{\tt int(64)} & -9223372036854775808 & 9223372036854775807 \\
{\tt uint(64)} & 0 & 18446744073709551615 \\
\hline
\end{tabular}
\end{center}

The unary and binary operators that are pre-defined over the integral
types operate with 32- and 64-bit precision.  Using these operators on
integral types represented with fewer bits results in a coercion
according to the rules defined in~\rsec{Implicit_Conversions}.

\begin{openissue}
There is on going discussion on whether the default size of the
integral types should be changed to 64 bits.
\end{openissue}


\subsubsection{Real Types}
\label{Real_Types}
\index{real@\chpl{real}}

Like the integral types, the real types can be parameterized by the
number of bits used to represent them.  The default real
type, \chpl{real}, is 64 bits.  The real types that are supported are
machine-dependent, but usually include \chpl{real(32)} (single
precision) and \chpl{real(64)} (double precision) following the IEEE
754 standard.

\subsubsection{Imaginary Types}
\label{Imaginary_Types}
\index{imaginary@\chpl{imaginary}}

The imaginary types can be parameterized by the number of bits used to
represent them.  The default imaginary type, \chpl{imag}, is 64 bits.
The imaginary types that are supported are machine-dependent, but
usually include \chpl{imag(32)} and \chpl{imag(64)}.

\begin{rationale}
The imaginary type is included to avoid numeric instabilities and
under-optimized code stemming from always coercing real values to
complex values with a zero imaginary part.
\end{rationale}

\subsubsection{Complex Types}
\label{Complex_Types}
\index{complex@\chpl{complex}}

Like the integral and real types, the complex types can be
parameterized by the number of bits used to represent them.  A complex
number is composed of two real numbers so the number of bits used to
represent a complex is twice the number of bits used to represent the
real numbers.  The default complex type, \chpl{complex}, is 128 bits;
it consists of two 64-bit real numbers.  The complex types that are
supported are machine-dependent, but usually
include \chpl{complex(64)} and \chpl{complex(128)}.

The real and imaginary components can be accessed via the methods
\chpl{re} and \chpl{im}.  The type of these components is real.
See~\rsec{Math} for math routines for complex types.

%
% Add something in the standard modules section
%

\begin{example}
Given a complex number \chpl{c} with the value \chpl{3.14+2.72i}, the
expressions \chpl{c.re} and \chpl{c.im} refer to \chpl{3.14}
and \chpl{2.72} respectively.
\end{example}

\subsubsection{The String Type}
\label{The_String_Type}
\index{string@\chpl{string}}

Strings are a primitive type designated by the symbol \chpl{string}
comprised of ASCII characters.  Their length is unbounded.
See~\rsec{Standard} for routines for manipulating strings.


\begin{openissue}
There is an expectation of future support for fixed-length strings.
\end{openissue}

\begin{openissue}
There is an expectation of future support for different character
sets, possibly including internationalization.
\end{openissue}

\subsection{Enumerated Types}
\label{Enumerated_Types}
\index{enumerated types}

Enumerated types are declared with the following syntax:
\begin{syntax}
enum-declaration-statement:
  `enum' identifier { enum-constant-list } ;

enum-constant-list:
  enum-constant
  enum-constant , enum-constant-list

enum-constant:
  identifier init-part[OPT]

init-part:
  = expression
\end{syntax}

The enumerated type can then be specified with its name as summarized
by the following syntax:
\begin{syntax}
enum-type:
  identifier
\end{syntax}

An enumerated type defines a set of named constants that can be
specified in a program as a member access on the enumerated type.
These are associated with parameters of integral type.  Each
enumerated type is a distinct type. If the \sntx{init-part} is
omitted, the \sntx{enum-constant} has an integral value one higher
than the previous \sntx{enum-constant} in the enum, with the first
having the value \chpl{1}.

\begin{example}
The code
\begin{chapel}
enum statesman { Aristotle, Roosevelt, Churchill, Kissinger } ;
\end{chapel}
defines an enumerated type with four constants.  The function
\begin{chapel}
def quote(s: statesman) {
  select s {
    when statesman.Aristotle do
       writeln("All paid jobs absorb and degrade the mind.");
    when statesman.Roosevelt do
       writeln("Every reform movement has a lunatic fringe.");
    when statesman.Churchill do
       writeln("A joke is a very serious thing.");
    when statesman.Kissinger do
       { write("No one will ever win the battle of the sexes; ");
         writeln("there's too much fraternizing with the enemy."); }
  }
}
\end{chapel}
outputs a quote from the given statesman.  Note that enumerated
constants must be prefixed by the enumerated type and a dot.
\end{example}

\subsection{Locality Types}
\label{Locality_Types}
\index{types!locality}

Locale types are summarized by the following syntax:

\begin{syntax}
locality-type:
  `locale'
\end{syntax}

The \chpl{locale} type is defined in~\rsec{The_Locale_Type}.

\begin{openissue}
We expect to support \emph{realms} as another locality type.
\end{openissue}

\subsection{Structured Types}
\label{Structured_Types}
\index{types!structured}

\subsubsection{Class Types}

The class type defines a type that contains variables and constants,
called fields, and functions, called methods.  Classes are defined
in~\rsec{Classes}.  The class type can also contain type aliases and
parameters.  Such a class is generic and is defined
in~\rsec{Generic_Types}.

\subsubsection{Record Types}

The record type is similar to a class type; the primary difference is
that a record is a value rather than a reference.  Records are defined
in~\rsec{Records}.

\subsubsection{Union Types}

The union type defines a type that contains one of a set of variables.
Like classes and records, unions may also define methods.  Unions are
defined in~\rsec{Unions}.

\subsubsection{Tuple Types}

A tuple is a light-weight record that consists of one or more
anonymous fields.  If all the fields are of the same type, the tuple
is homogeneous.  Tuples are defined in~\rsec{Tuples}.

\subsection{Data Parallel Types}
\label{Data_Parallel_Types}
\index{types!dataparallel}

\subsubsection{Range Types}

A range defines an integral sequence of some integral type.  Ranges
are defined in~\rsec{Ranges}.

\subsubsection{Domain, Array, and Index Types}
\label{Domain_and_Array_Types}

A domain defines a set of indices and an array defines a set of
elements that are mapped by the indices in an associated domain.  A
domain's indicies can be of any type.  Domains, arrays, and index
types are defined in~\rsec{Domains}~and~\rsec{Arrays}.

\subsection{Type Aliases}
\label{Type_Aliases}
\index{type aliases}

Type aliases are declared with the following syntax:
\begin{syntax}
type-alias-declaration-statement:
  `config'[OPT] `type' type-alias-declaration-list ;

type-alias-declaration-list:
  type-alias-declaration
  type-alias-declaration , type-alias-declaration-list

type-alias-declaration:
  identifier = type-specifier
  identifier
\end{syntax}
A type alias is a symbol that aliases the type specified in the
\sntx{type-part}.  A use of a type alias has the same meaning as using
the type specified by \sntx{type-part} directly.

If the keyword \chpl{config} precedes the keyword \chpl{type}, the
type alias is called a configuration type alias.  Configuration type
aliases are set at compilation time via compilation flags or other
implementation dependent means.  The \chpl{type-specifier} in the
program is ignored if the type-alias is alternatively set.

The \sntx{type-part} is optional in the definition of a class or
record.  Such a type alias is called an unspecified type
alias. Classes and records that contain type aliases, specified or
unspecified, are generic~(\rsec{Type_Aliases_in_Generic_Types}).

\begin{openissue}
There is on going discussion on whether a type alias is a new
type or simply an alias.  The former should enable redefinition of
default values, identity elements, etc.
\end{openissue}
