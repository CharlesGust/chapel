This should go as comments to BlockCyclic1d.

/*

Let's review the math of BlockCyclic - for a single dimension.

*** Given:

distribution parameters:
 lowIdx
 blockSize >= 1
 numLocales >= 1

a range 'whole' with parameters (aligned):
 wLo
 wHi
 wSt

user's domain index (a member of 'whole'):
 i
 i0 = (i-lowIdx)  - "zero-based" index
 (the formulas assume 1:1 correspondence between i and i0, for brevity)

 note:  wLo <= i <= wHi
        advanced: i = wLo + iSt * |wSt| where iSt - a non-negative integer

*** Notation:
 floor(a,b) = floor((real)a/(real)b)
 a div b = { assert a>=0 && b>=0; return floor(a,b); }
 a mod b = { assert b >= 0; return a - b*floor(a,b); }
 "advanced" = "skip upon first reading"

*** Define the "cycle" of indices that starts at lowIdx, traverses
each locale 0..#numLocales, while traversing offsets 0..#blockSize
on each locale, then starts over:

 cycSize = blockSize * numLocales
 cycNo(i) = floor(i0,cycSize)
 cycOff(i) = i0 mod cycSize

 note:  cycNo(wLo) <= cycNo(i) <= cycNo(wHi)
        0 <= cycOff(i) < cycSize

 // the locale number that hosts 'i', aka locId or "block number" blkNum
 locNo(i) = cycOff(i) div blockSize

 note:  0 <= locNo(i) < numLocales

 // position of 'i' within the locale, aka "block offset" blkOff
 locOff(i) = cycOff(i) mod blockSize

 note: 0 <= locOff(i) < blockSize

 advanced property:
   If i1 and i2 are members of 'whole'
     and fall on the same cycle and on the same locale
     (i.e. cycNo and locNo are the same),
   then
     (locOff(i1) div |wSt|) vs. (locOff(i2) div |wSt|) are distinct
       IFF
     i1 vs. i2 are distinct.

 advanced proof:
   In general,
     i1 == lowIdx + cycNo(i1)*cycSize + locNo(i1)*blockSize + locOff(i1)
     i1 == wLo + i1St * |wSt| for some integer i1St
   then
     locOff(i1) div |wSt| == (i1A + i1St * |wSt|) div |wSt| == i1B + i1St
   where
     i1A = wLo - (lowIdx + cycNo(i1)*cycSize + locNo(i1)*blockSize)
     i1B = i1A div |wSt|

   likewise
     locOff(i2) div |wSt| = i2B + i2St

   Note i1B==i2B - because cycNo and locNo are the same for i1 and i2.
   Note i1==i2 IFF i1St==i2St - because of the definition of i1St, i2St.
   The property, then, follows.

*** Assign each index of 'whole' to "storage" on its locale as follows:

 // the pair (locNo(j), storageOff(j)) is unique for each integer j
 storageOff(i) = cycNo(i) * blockSize + locOff(i)

Advdanced: compress the storage based on the above advanced property,
which implies that:
 the pair (locNo(i), storageOff(i) div |wSt|) is unique
 for each 'i' - member of 'whole'.

 storageIdx(i) = cycNo(i) * storagePerCycle + (locOff(i) div |wSt|)

where storagePerCycle is determined to ensure uniqueness of storageIdx(i)

 storagePerCycle
   = 1 + max(locOff(i) div |wSt|) for any i s.t.
                                  whole.member(i)==true and locNo(i) is fixed
   approximated as: 1 + ( (max locOff(i) for any i) div |wSt| )
   = 1 + ((blockSize-1) div |wSt|)

*** Advanced: replacing mod with Chapel's %.
Calculate i0 using the following:

 i0 = i - lowIdx + cycSize * cycAdj
   choosing any fixed integer cycAdj >= ceil( (lowIdx-wLo), cycSize )

This guarantees i0>=0, but modifies cycNo(i) by cycAdj.
The latter is acceptable for our purposes.
Having i0>=0 ensures that (i0 mod cycSize) == (i0 % cycSize).

Additional consideration: for any given i, we want cycNo(i)
to stay the same throughout the life of a domain descriptor.
(This is so that our storage indices remain consistent - which is
useful to implement Chapel's preservation of array contents upon
domain assignments.)
This implies that the same cycAdj should accomodate wLo for any
domain bounds that can be assigned to our domain descriptor.
That may not be convenient in practice.

*/
